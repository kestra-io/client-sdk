/*
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.kestra.sdk.api;

// Custom imports for injected code
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import reactor.core.publisher.Flux;
import java.io.BufferedReader;
import io.kestra.sdk.model.ExecutionStatusEvent;

import com.fasterxml.jackson.core.type.TypeReference;

import io.kestra.sdk.internal.ApiException;
import io.kestra.sdk.internal.ApiClient;
import io.kestra.sdk.internal.BaseApi;
import io.kestra.sdk.internal.Configuration;
import io.kestra.sdk.internal.Pair;

import io.kestra.sdk.model.BulkResponse;
import io.kestra.sdk.model.ConcurrencyLimit;
import java.io.File;
import io.kestra.sdk.model.Flow;
import io.kestra.sdk.model.FlowControllerTaskValidationType;
import io.kestra.sdk.model.FlowGraph;
import io.kestra.sdk.model.FlowInterface;
import io.kestra.sdk.model.FlowTopologyGraph;
import io.kestra.sdk.model.FlowWithSource;
import io.kestra.sdk.model.IdWithNamespace;
import io.kestra.sdk.model.PagedResultsConcurrencyLimit;
import io.kestra.sdk.model.PagedResultsFlow;
import io.kestra.sdk.model.PagedResultsSearchResultFlow;
import io.kestra.sdk.model.QueryFilter;
import io.kestra.sdk.model.Task;
import io.kestra.sdk.model.ValidateConstraintViolation;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.16.0")public class FlowsApi extends BaseApi {

  public FlowsApi() {
    super(Configuration.getDefaultApiClient());
  }

  public FlowsApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param allowNamespaceChild If namespace child should are allowed to be updated (required)
   * @param tenant  (required)
   * @param namespace The namespace where to update flows (optional)
   * @param body A list of flows source code splitted with \&quot;---\&quot; (optional)
   * @return List&lt;FlowInterface&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowInterface> bulkUpdateFlows(@jakarta.annotation.Nonnull Boolean delete, @jakarta.annotation.Nonnull Boolean allowNamespaceChild, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable String namespace, @jakarta.annotation.Nullable String body) throws ApiException {
    return this.bulkUpdateFlows(delete, allowNamespaceChild, tenant, namespace, body, Collections.emptyMap());
  }

  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param allowNamespaceChild If namespace child should are allowed to be updated (required)
   * @param tenant  (required)
   * @param namespace The namespace where to update flows (optional)
   * @param body A list of flows source code splitted with \&quot;---\&quot; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowInterface&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowInterface> bulkUpdateFlows(@jakarta.annotation.Nonnull Boolean delete, @jakarta.annotation.Nonnull Boolean allowNamespaceChild, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable String namespace, @jakarta.annotation.Nullable String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling bulkUpdateFlows");
    }
    
    // verify the required parameter 'allowNamespaceChild' is set
    if (allowNamespaceChild == null) {
      throw new ApiException(400, "Missing the required parameter 'allowNamespaceChild' when calling bulkUpdateFlows");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling bulkUpdateFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/bulk"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarQueryParams.addAll(apiClient.parameterToPair("allowNamespaceChild", allowNamespaceChild));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<FlowInterface>> localVarReturnType = new TypeReference<List<FlowInterface>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Create a flow from yaml source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource createFlow(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body) throws ApiException {
    return this.createFlow(tenant, body, Collections.emptyMap());
  }

  /**
   * Create a flow from yaml source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource createFlow(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling createFlow");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling createFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowWithSource> localVarReturnType = new TypeReference<FlowWithSource>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteFlow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant) throws ApiException {
    this.deleteFlow(namespace, id, tenant, Collections.emptyMap());
  }

  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void deleteFlow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling deleteFlow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }






  /**
   * Delete flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.deleteFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }

  /**
   * Delete flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling deleteFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/delete/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Delete flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters) throws ApiException {
    return this.deleteFlowsByQuery(tenant, filters, Collections.emptyMap());
  }

  /**
   * Delete flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/delete/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Disable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.disableFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }

  /**
   * Disable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling disableFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling disableFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/disable/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Disable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters) throws ApiException {
    return this.disableFlowsByQuery(tenant, filters, Collections.emptyMap());
  }

  /**
   * Disable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling disableFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/disable/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Enable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.enableFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }

  /**
   * Enable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling enableFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling enableFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/enable/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Enable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters) throws ApiException {
    return this.enableFlowsByQuery(tenant, filters, Collections.emptyMap());
  }

  /**
   * Enable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling enableFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/enable/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.exportFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByIds(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling exportFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling exportFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/export/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<byte[]> localVarReturnType = new TypeReference<byte[]>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters) throws ApiException {
    return this.exportFlowsByQuery(tenant, filters, Collections.emptyMap());
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByQuery(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<QueryFilter> filters, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling exportFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/export/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<byte[]> localVarReturnType = new TypeReference<byte[]>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param tenant  (required)
   * @param revision Get latest revision by default (optional)
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource flow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull Boolean source, @jakarta.annotation.Nonnull Boolean allowDeleted, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable Integer revision) throws ApiException {
    return this.flow(namespace, id, source, allowDeleted, tenant, revision, Collections.emptyMap());
  }

  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param tenant  (required)
   * @param revision Get latest revision by default (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource flow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull Boolean source, @jakarta.annotation.Nonnull Boolean allowDeleted, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling flow");
    }
    
    // verify the required parameter 'source' is set
    if (source == null) {
      throw new ApiException(400, "Missing the required parameter 'source' when calling flow");
    }
    
    // verify the required parameter 'allowDeleted' is set
    if (allowDeleted == null) {
      throw new ApiException(400, "Missing the required parameter 'allowDeleted' when calling flow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling flow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarQueryParams.addAll(apiClient.parameterToPair("allowDeleted", allowDeleted));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowWithSource> localVarReturnType = new TypeReference<FlowWithSource>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly If true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param expandAll If true, expand all dependencies recursively (required)
   * @param tenant  (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph flowDependencies(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull Boolean destinationOnly, @jakarta.annotation.Nonnull Boolean expandAll, @jakarta.annotation.Nonnull String tenant) throws ApiException {
    return this.flowDependencies(namespace, id, destinationOnly, expandAll, tenant, Collections.emptyMap());
  }

  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly If true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param expandAll If true, expand all dependencies recursively (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph flowDependencies(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull Boolean destinationOnly, @jakarta.annotation.Nonnull Boolean expandAll, @jakarta.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flowDependencies");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling flowDependencies");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling flowDependencies");
    }
    
    // verify the required parameter 'expandAll' is set
    if (expandAll == null) {
      throw new ApiException(400, "Missing the required parameter 'expandAll' when calling flowDependencies");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling flowDependencies");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    localVarQueryParams.addAll(apiClient.parameterToPair("expandAll", expandAll));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Retrieve flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph flowDependenciesFromNamespace(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull Boolean destinationOnly, @jakarta.annotation.Nonnull String tenant) throws ApiException {
    return this.flowDependenciesFromNamespace(namespace, destinationOnly, tenant, Collections.emptyMap());
  }

  /**
   * Retrieve flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph flowDependenciesFromNamespace(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull Boolean destinationOnly, @jakarta.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flowDependenciesFromNamespace");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling flowDependenciesFromNamespace");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling flowDependenciesFromNamespace");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/namespaces/{namespace}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraph(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable Integer revision, @jakarta.annotation.Nullable List<String> subflows) throws ApiException {
    return this.generateFlowGraph(namespace, id, tenant, revision, subflows, Collections.emptyMap());
  }

  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraph(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable Integer revision, @jakarta.annotation.Nullable List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling generateFlowGraph");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling generateFlowGraph");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling generateFlowGraph");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/graph"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Generate a graph for a flow source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraphFromSource(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body, @jakarta.annotation.Nullable List<String> subflows) throws ApiException {
    return this.generateFlowGraphFromSource(tenant, body, subflows, Collections.emptyMap());
  }

  /**
   * Generate a graph for a flow source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraphFromSource(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body, @jakarta.annotation.Nullable List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling generateFlowGraphFromSource");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling generateFlowGraphFromSource");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/graph"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param failOnError If should fail on invalid flows (required)
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows(@jakarta.annotation.Nonnull Boolean failOnError, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable File fileUpload) throws ApiException {
    return this.importFlows(failOnError, tenant, fileUpload, Collections.emptyMap());
  }

  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param failOnError If should fail on invalid flows (required)
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows(@jakarta.annotation.Nonnull Boolean failOnError, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable File fileUpload, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'failOnError' is set
    if (failOnError == null) {
      throw new ApiException(400, "Missing the required parameter 'failOnError' when calling importFlows");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling importFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/import"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("failOnError", failOnError));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    if (fileUpload != null)
      localVarFormParams.put("fileUpload", fileUpload);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "multipart/form-data"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * List all distinct namespaces
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespaces(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable String q) throws ApiException {
    return this.listDistinctNamespaces(tenant, q, Collections.emptyMap());
  }

  /**
   * List all distinct namespaces
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespaces(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable String q, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listDistinctNamespaces");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/distinct-namespaces"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> listFlowRevisions(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant) throws ApiException {
    return this.listFlowRevisions(namespace, id, tenant, Collections.emptyMap());
  }

  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> listFlowRevisions(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling listFlowRevisions");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling listFlowRevisions");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listFlowRevisions");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/revisions"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<FlowWithSource>> localVarReturnType = new TypeReference<List<FlowWithSource>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param tenant  (required)
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> listFlowsByNamespace(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String tenant) throws ApiException {
    return this.listFlowsByNamespace(namespace, tenant, Collections.emptyMap());
  }

  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> listFlowsByNamespace(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling listFlowsByNamespace");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listFlowsByNamespace");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<Flow>> localVarReturnType = new TypeReference<List<Flow>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Search for flow concurrency limits
   * 
   * @param tenant  (required)
   * @return PagedResultsConcurrencyLimit
   * @throws ApiException if fails to make API call
   */
  public PagedResultsConcurrencyLimit searchConcurrencyLimits(@jakarta.annotation.Nonnull String tenant) throws ApiException {
    return this.searchConcurrencyLimits(tenant, Collections.emptyMap());
  }

  /**
   * Search for flow concurrency limits
   * 
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsConcurrencyLimit
   * @throws ApiException if fails to make API call
   */
  public PagedResultsConcurrencyLimit searchConcurrencyLimits(@jakarta.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling searchConcurrencyLimits");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/concurrency-limit/search"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<PagedResultsConcurrencyLimit> localVarReturnType = new TypeReference<PagedResultsConcurrencyLimit>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param filters Filters (optional)
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow searchFlows(@jakarta.annotation.Nonnull Integer page, @jakarta.annotation.Nonnull Integer size, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<QueryFilter> filters) throws ApiException {
    return this.searchFlows(page, size, tenant, sort, filters, Collections.emptyMap());
  }

  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param filters Filters (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow searchFlows(@jakarta.annotation.Nonnull Integer page, @jakarta.annotation.Nonnull Integer size, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<QueryFilter> filters, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchFlows");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchFlows");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling searchFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/search"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "sort", sort));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsFlow> localVarReturnType = new TypeReference<PagedResultsFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow searchFlowsBySourceCode(@jakarta.annotation.Nonnull Integer page, @jakarta.annotation.Nonnull Integer size, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable String q, @jakarta.annotation.Nullable String namespace) throws ApiException {
    return this.searchFlowsBySourceCode(page, size, tenant, sort, q, namespace, Collections.emptyMap());
  }

  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow searchFlowsBySourceCode(@jakarta.annotation.Nonnull Integer page, @jakarta.annotation.Nonnull Integer size, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable String q, @jakarta.annotation.Nullable String namespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchFlowsBySourceCode");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchFlowsBySourceCode");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling searchFlowsBySourceCode");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/source"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsSearchResultFlow> localVarReturnType = new TypeReference<PagedResultsSearchResultFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task taskFromFlow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String taskId, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable Integer revision) throws ApiException {
    return this.taskFromFlow(namespace, id, taskId, tenant, revision, Collections.emptyMap());
  }

  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task taskFromFlow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String taskId, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nullable Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling taskFromFlow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling taskFromFlow");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling taskFromFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling taskFromFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Task> localVarReturnType = new TypeReference<Task>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Update a flow concurrency limit
   * 
   * @param flowId  (required)
   * @param namespace  (required)
   * @param tenant  (required)
   * @param concurrencyLimit  (required)
   * @return ConcurrencyLimit
   * @throws ApiException if fails to make API call
   */
  public ConcurrencyLimit updateConcurrencyLimit(@jakarta.annotation.Nonnull String flowId, @jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull ConcurrencyLimit concurrencyLimit) throws ApiException {
    return this.updateConcurrencyLimit(flowId, namespace, tenant, concurrencyLimit, Collections.emptyMap());
  }

  /**
   * Update a flow concurrency limit
   * 
   * @param flowId  (required)
   * @param namespace  (required)
   * @param tenant  (required)
   * @param concurrencyLimit  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ConcurrencyLimit
   * @throws ApiException if fails to make API call
   */
  public ConcurrencyLimit updateConcurrencyLimit(@jakarta.annotation.Nonnull String flowId, @jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull ConcurrencyLimit concurrencyLimit, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = concurrencyLimit;
    
    // verify the required parameter 'flowId' is set
    if (flowId == null) {
      throw new ApiException(400, "Missing the required parameter 'flowId' when calling updateConcurrencyLimit");
    }
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateConcurrencyLimit");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateConcurrencyLimit");
    }
    
    // verify the required parameter 'concurrencyLimit' is set
    if (concurrencyLimit == null) {
      throw new ApiException(400, "Missing the required parameter 'concurrencyLimit' when calling updateConcurrencyLimit");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/concurrency-limit/{namespace}/{flowId}"
      .replaceAll("\\{" + "flowId" + "\\}", apiClient.escapeString(apiClient.parameterToString(flowId)))
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ConcurrencyLimit> localVarReturnType = new TypeReference<ConcurrencyLimit>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Update a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource updateFlow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body) throws ApiException {
    return this.updateFlow(namespace, id, tenant, body, Collections.emptyMap());
  }

  /**
   * Update a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource updateFlow(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateFlow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateFlow");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling updateFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowWithSource> localVarReturnType = new TypeReference<FlowWithSource>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Update a complete namespace from yaml source
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param namespace The flow namespace (required)
   * @param delete If missing flow should be deleted (required)
   * @param tenant  (required)
   * @param body A list of flows source code (required)
   * @return List&lt;FlowInterface&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowInterface> updateFlowsInNamespace(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull Boolean delete, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body) throws ApiException {
    return this.updateFlowsInNamespace(namespace, delete, tenant, body, Collections.emptyMap());
  }

  /**
   * Update a complete namespace from yaml source
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param namespace The flow namespace (required)
   * @param delete If missing flow should be deleted (required)
   * @param tenant  (required)
   * @param body A list of flows source code (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowInterface&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowInterface> updateFlowsInNamespace(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull Boolean delete, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateFlowsInNamespace");
    }
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling updateFlowsInNamespace");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateFlowsInNamespace");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling updateFlowsInNamespace");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<FlowInterface>> localVarReturnType = new TypeReference<List<FlowInterface>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param task The task (required)
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String taskId, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull Task task) throws ApiException {
    return this.updateTask(namespace, id, taskId, tenant, task, Collections.emptyMap());
  }

  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param task The task (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask(@jakarta.annotation.Nonnull String namespace, @jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull String taskId, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull Task task, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = task;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateTask");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateTask");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling updateTask");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateTask");
    }
    
    // verify the required parameter 'task' is set
    if (task == null) {
      throw new ApiException(400, "Missing the required parameter 'task' when calling updateTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Flow> localVarReturnType = new TypeReference<Flow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param body A list of flows source code in a single string (required)
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body) throws ApiException {
    return this.validateFlows(tenant, body, Collections.emptyMap());
  }

  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param body A list of flows source code in a single string (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateFlows");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<ValidateConstraintViolation>> localVarReturnType = new TypeReference<List<ValidateConstraintViolation>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Validate a task
   * 
   * @param section The type of task (required)
   * @param tenant  (required)
   * @param body A task definition that can be from tasks or triggers (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask(@jakarta.annotation.Nonnull FlowControllerTaskValidationType section, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull Object body) throws ApiException {
    return this.validateTask(section, tenant, body, Collections.emptyMap());
  }

  /**
   * Validate a task
   * 
   * @param section The type of task (required)
   * @param tenant  (required)
   * @param body A task definition that can be from tasks or triggers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask(@jakarta.annotation.Nonnull FlowControllerTaskValidationType section, @jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull Object body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'section' is set
    if (section == null) {
      throw new ApiException(400, "Missing the required parameter 'section' when calling validateTask");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateTask");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate/task"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    localVarQueryParams.addAll(apiClient.parameterToPair("section", section));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml", "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }






  /**
   * Validate trigger
   * 
   * @param tenant  (required)
   * @param body The trigger (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull Object body) throws ApiException {
    return this.validateTrigger(tenant, body, Collections.emptyMap());
  }

  /**
   * Validate trigger
   * 
   * @param tenant  (required)
   * @param body The trigger (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger(@jakarta.annotation.Nonnull String tenant, @jakarta.annotation.Nonnull Object body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateTrigger");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTrigger");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate/trigger"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams =  new HashMap<String, Object>();
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }





}
