/*
Kestra EE

All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.

API version: 1.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kestra_api_client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
	"sync/atomic"
	"time"

	"github.com/tmaxmax/go-sse"
)

// ExecutionsAPIService ExecutionsAPI service
type ExecutionsAPIService service

type ApiCreateExecutionRequest struct {
	ctx          context.Context
	ApiService   *ExecutionsAPIService
	namespace    string
	id           string
	wait         *bool
	tenant       string
	labels       *[]string
	revision     *int32
	scheduleDate *time.Time
	breakpoints  *string
	kind         *ExecutionKind
	formData     *map[string]any
}

// If the server will wait the end of the execution
func (r ApiCreateExecutionRequest) Wait(wait bool) ApiCreateExecutionRequest {
	r.wait = &wait
	return r
}

// The labels as a list of &#39;key:value&#39;
func (r ApiCreateExecutionRequest) Labels(labels []string) ApiCreateExecutionRequest {
	r.labels = &labels
	return r
}

// The flow revision or latest if null
func (r ApiCreateExecutionRequest) Revision(revision int32) ApiCreateExecutionRequest {
	r.revision = &revision
	return r
}

// Schedule the flow on a specific date
func (r ApiCreateExecutionRequest) ScheduleDate(scheduleDate time.Time) ApiCreateExecutionRequest {
	r.scheduleDate = &scheduleDate
	return r
}

// Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiCreateExecutionRequest) Breakpoints(breakpoints string) ApiCreateExecutionRequest {
	r.breakpoints = &breakpoints
	return r
}

// Specific execution kind
func (r ApiCreateExecutionRequest) Kind(kind ExecutionKind) ApiCreateExecutionRequest {
	r.kind = &kind
	return r
}

// the request multipart/form-data content
func (r ApiCreateExecutionRequest) FormData(formData map[string]any) ApiCreateExecutionRequest {
	r.formData = &formData
	return r
}

func (r ApiCreateExecutionRequest) Execute() (*ExecutionControllerExecutionResponse, *http.Response, error) {
	return r.ApiService.CreateExecutionExecute(r)
}

/*
CreateExecution Create a new execution for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param tenant
	@return ApiCreateExecutionRequest
*/
func (a *ExecutionsAPIService) CreateExecution(ctx context.Context, namespace string, id string, tenant string) ApiCreateExecutionRequest {
	return ApiCreateExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return ExecutionControllerExecutionResponse
func (a *ExecutionsAPIService) CreateExecutionExecute(r ApiCreateExecutionRequest) (*ExecutionControllerExecutionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionControllerExecutionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.CreateExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{namespace}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wait == nil {
		return localVarReturnValue, nil, reportError("wait is required and must be specified")
	}

	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	if r.scheduleDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleDate", r.scheduleDate, "form", "")
	}
	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}
	if r.kind != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kind", r.kind, "form", "")
	}

	if r.formData != nil {
		for key, val := range *r.formData {
			switch v := val.(type) {
			case string:
				localVarFormParams.Add(key, v)
			case *string:
				if v != nil {
					localVarFormParams.Add(key, *v)
				}
			case []string:
				for _, s := range v {
					localVarFormParams.Add(key, s)
				}
			case []interface{}:
				for _, item := range v {
					localVarFormParams.Add(key, fmt.Sprint(item))
				}
			case time.Time:
				localVarFormParams.Add(key, v.Format(time.RFC3339))
			case *time.Time:
				if v != nil {
					localVarFormParams.Add(key, v.Format(time.RFC3339))
				}
			default:
				localVarFormParams.Add(key, fmt.Sprint(v))
			}
		}
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExecutionRequest struct {
	ctx           context.Context
	ApiService    *ExecutionsAPIService
	executionId   string
	tenant        string
	deleteLogs    *bool
	deleteMetrics *bool
	deleteStorage *bool
}

// Whether to delete execution logs
func (r ApiDeleteExecutionRequest) DeleteLogs(deleteLogs bool) ApiDeleteExecutionRequest {
	r.deleteLogs = &deleteLogs
	return r
}

// Whether to delete execution metrics
func (r ApiDeleteExecutionRequest) DeleteMetrics(deleteMetrics bool) ApiDeleteExecutionRequest {
	r.deleteMetrics = &deleteMetrics
	return r
}

// Whether to delete execution files in the internal storage
func (r ApiDeleteExecutionRequest) DeleteStorage(deleteStorage bool) ApiDeleteExecutionRequest {
	r.deleteStorage = &deleteStorage
	return r
}

func (r ApiDeleteExecutionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecutionExecute(r)
}

/*
DeleteExecution Delete an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiDeleteExecutionRequest
*/
func (a *ExecutionsAPIService) DeleteExecution(ctx context.Context, executionId string, tenant string) ApiDeleteExecutionRequest {
	return ApiDeleteExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
func (a *ExecutionsAPIService) DeleteExecutionExecute(r ApiDeleteExecutionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DeleteExecution")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteLogs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteLogs", r.deleteLogs, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteLogs = &defaultValue
	}
	if r.deleteMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteMetrics", r.deleteMetrics, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteMetrics = &defaultValue
	}
	if r.deleteStorage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteStorage", r.deleteStorage, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteStorage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteExecutionsByIdsRequest struct {
	ctx                  context.Context
	ApiService           *ExecutionsAPIService
	tenant               string
	requestBody          *[]string
	includeNonTerminated *bool
	deleteLogs           *bool
	deleteMetrics        *bool
	deleteStorage        *bool
}

// The execution id
func (r ApiDeleteExecutionsByIdsRequest) RequestBody(requestBody []string) ApiDeleteExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

// Whether to delete non-terminated executions
func (r ApiDeleteExecutionsByIdsRequest) IncludeNonTerminated(includeNonTerminated bool) ApiDeleteExecutionsByIdsRequest {
	r.includeNonTerminated = &includeNonTerminated
	return r
}

// Whether to delete execution logs
func (r ApiDeleteExecutionsByIdsRequest) DeleteLogs(deleteLogs bool) ApiDeleteExecutionsByIdsRequest {
	r.deleteLogs = &deleteLogs
	return r
}

// Whether to delete execution metrics
func (r ApiDeleteExecutionsByIdsRequest) DeleteMetrics(deleteMetrics bool) ApiDeleteExecutionsByIdsRequest {
	r.deleteMetrics = &deleteMetrics
	return r
}

// Whether to delete execution files in the internal storage
func (r ApiDeleteExecutionsByIdsRequest) DeleteStorage(deleteStorage bool) ApiDeleteExecutionsByIdsRequest {
	r.deleteStorage = &deleteStorage
	return r
}

func (r ApiDeleteExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.DeleteExecutionsByIdsExecute(r)
}

/*
DeleteExecutionsByIds Delete a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiDeleteExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) DeleteExecutionsByIds(ctx context.Context, tenant string) ApiDeleteExecutionsByIdsRequest {
	return ApiDeleteExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) DeleteExecutionsByIdsExecute(r ApiDeleteExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DeleteExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.includeNonTerminated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNonTerminated", r.includeNonTerminated, "form", "")
	} else {
		var defaultValue bool = false
		r.includeNonTerminated = &defaultValue
	}
	if r.deleteLogs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteLogs", r.deleteLogs, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteLogs = &defaultValue
	}
	if r.deleteMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteMetrics", r.deleteMetrics, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteMetrics = &defaultValue
	}
	if r.deleteStorage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteStorage", r.deleteStorage, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteStorage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExecutionsByQueryRequest struct {
	ctx                  context.Context
	ApiService           *ExecutionsAPIService
	tenant               string
	filters              *[]QueryFilter
	includeNonTerminated *bool
	deleteLogs           *bool
	deleteMetrics        *bool
	deleteStorage        *bool
}

// Filters
func (r ApiDeleteExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiDeleteExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

// Whether to delete non-terminated executions
func (r ApiDeleteExecutionsByQueryRequest) IncludeNonTerminated(includeNonTerminated bool) ApiDeleteExecutionsByQueryRequest {
	r.includeNonTerminated = &includeNonTerminated
	return r
}

// Whether to delete execution logs
func (r ApiDeleteExecutionsByQueryRequest) DeleteLogs(deleteLogs bool) ApiDeleteExecutionsByQueryRequest {
	r.deleteLogs = &deleteLogs
	return r
}

// Whether to delete execution metrics
func (r ApiDeleteExecutionsByQueryRequest) DeleteMetrics(deleteMetrics bool) ApiDeleteExecutionsByQueryRequest {
	r.deleteMetrics = &deleteMetrics
	return r
}

// Whether to delete execution files in the internal storage
func (r ApiDeleteExecutionsByQueryRequest) DeleteStorage(deleteStorage bool) ApiDeleteExecutionsByQueryRequest {
	r.deleteStorage = &deleteStorage
	return r
}

func (r ApiDeleteExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteExecutionsByQueryExecute(r)
}

/*
DeleteExecutionsByQuery Delete executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiDeleteExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) DeleteExecutionsByQuery(ctx context.Context, tenant string) ApiDeleteExecutionsByQueryRequest {
	return ApiDeleteExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) DeleteExecutionsByQueryExecute(r ApiDeleteExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DeleteExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	if r.includeNonTerminated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNonTerminated", r.includeNonTerminated, "form", "")
	} else {
		var defaultValue bool = false
		r.includeNonTerminated = &defaultValue
	}
	if r.deleteLogs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteLogs", r.deleteLogs, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteLogs = &defaultValue
	}
	if r.deleteMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteMetrics", r.deleteMetrics, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteMetrics = &defaultValue
	}
	if r.deleteStorage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteStorage", r.deleteStorage, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteStorage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadFileFromExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	path        *string
	tenant      string
}

// The internal storage uri
func (r ApiDownloadFileFromExecutionRequest) Path(path string) ApiDownloadFileFromExecutionRequest {
	r.path = &path
	return r
}

func (r ApiDownloadFileFromExecutionRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFileFromExecutionExecute(r)
}

/*
DownloadFileFromExecution Download file for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiDownloadFileFromExecutionRequest
*/
func (a *ExecutionsAPIService) DownloadFileFromExecution(ctx context.Context, executionId string, tenant string) ApiDownloadFileFromExecutionRequest {
	return ApiDownloadFileFromExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *ExecutionsAPIService) DownloadFileFromExecutionExecute(r ApiDownloadFileFromExecutionRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DownloadFileFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ExecutionExecute(r)
}

/*
Execution Get an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiExecutionRequest
*/
func (a *ExecutionsAPIService) Execution(ctx context.Context, executionId string, tenant string) ApiExecutionRequest {
	return ApiExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ExecutionExecute(r ApiExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.Execution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecutionFlowGraphRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	subflows    *[]string
}

// The subflow tasks to display
func (r ApiExecutionFlowGraphRequest) Subflows(subflows []string) ApiExecutionFlowGraphRequest {
	r.subflows = &subflows
	return r
}

func (r ApiExecutionFlowGraphRequest) Execute() (*FlowGraph, *http.Response, error) {
	return r.ApiService.ExecutionFlowGraphExecute(r)
}

/*
ExecutionFlowGraph Generate a graph for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiExecutionFlowGraphRequest
*/
func (a *ExecutionsAPIService) ExecutionFlowGraph(ctx context.Context, executionId string, tenant string) ApiExecutionFlowGraphRequest {
	return ApiExecutionFlowGraphRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return FlowGraph
func (a *ExecutionsAPIService) ExecutionFlowGraphExecute(r ApiExecutionFlowGraphRequest) (*FlowGraph, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FlowGraph
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ExecutionFlowGraph")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/graph"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.subflows != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subflows", r.subflows, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportExecutionsRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	filters    *[]QueryFilter
	tenant     string
}

// A list of filters
func (r ApiExportExecutionsRequest) Filters(filters []QueryFilter) ApiExportExecutionsRequest {
	r.filters = &filters
	return r
}

func (r ApiExportExecutionsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ExportExecutionsExecute(r)
}

/*
ExportExecutions Export all executions as a streamed CSV file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiExportExecutionsRequest
*/
func (a *ExecutionsAPIService) ExportExecutions(ctx context.Context, tenant string) ApiExportExecutionsRequest {
	return ApiExportExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *ExecutionsAPIService) ExportExecutionsExecute(r ApiExportExecutionsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ExportExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/export/by-query/csv"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filters == nil {
		return localVarReturnValue, nil, reportError("filters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFileMetadatasFromExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	path        *string
	tenant      string
}

// The internal storage uri
func (r ApiFileMetadatasFromExecutionRequest) Path(path string) ApiFileMetadatasFromExecutionRequest {
	r.path = &path
	return r
}

func (r ApiFileMetadatasFromExecutionRequest) Execute() (*FileMetas, *http.Response, error) {
	return r.ApiService.FileMetadatasFromExecutionExecute(r)
}

/*
FileMetadatasFromExecution Get file meta information for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiFileMetadatasFromExecutionRequest
*/
func (a *ExecutionsAPIService) FileMetadatasFromExecution(ctx context.Context, executionId string, tenant string) ApiFileMetadatasFromExecutionRequest {
	return ApiFileMetadatasFromExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return FileMetas
func (a *ExecutionsAPIService) FileMetadatasFromExecutionExecute(r ApiFileMetadatasFromExecutionRequest) (*FileMetas, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileMetas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FileMetadatasFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/file/metas"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowFromExecutionRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	flowId     string
	tenant     string
	revision   *int32
}

// The flow revision
func (r ApiFlowFromExecutionRequest) Revision(revision int32) ApiFlowFromExecutionRequest {
	r.revision = &revision
	return r
}

func (r ApiFlowFromExecutionRequest) Execute() (*FlowForExecution, *http.Response, error) {
	return r.ApiService.FlowFromExecutionExecute(r)
}

/*
FlowFromExecution Get flow information's for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The namespace of the flow
	@param flowId The flow id
	@param tenant
	@return ApiFlowFromExecutionRequest
*/
func (a *ExecutionsAPIService) FlowFromExecution(ctx context.Context, namespace string, flowId string, tenant string) ApiFlowFromExecutionRequest {
	return ApiFlowFromExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		flowId:     flowId,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return FlowForExecution
func (a *ExecutionsAPIService) FlowFromExecutionExecute(r ApiFlowFromExecutionRequest) (*FlowForExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FlowForExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FlowFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/flows/{namespace}/{flowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterValueToString(r.flowId, "flowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowFromExecutionByIdRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiFlowFromExecutionByIdRequest) Execute() (*FlowForExecution, *http.Response, error) {
	return r.ApiService.FlowFromExecutionByIdExecute(r)
}

/*
FlowFromExecutionById Get flow information's for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution that you want flow informations
	@param tenant
	@return ApiFlowFromExecutionByIdRequest
*/
func (a *ExecutionsAPIService) FlowFromExecutionById(ctx context.Context, executionId string, tenant string) ApiFlowFromExecutionByIdRequest {
	return ApiFlowFromExecutionByIdRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return FlowForExecution
func (a *ExecutionsAPIService) FlowFromExecutionByIdExecute(r ApiFlowFromExecutionByIdRequest) (*FlowForExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FlowForExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FlowFromExecutionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/flow"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowDependenciesExecutionRequest struct {
	ctx             context.Context
	ApiService      *ExecutionsAPIService
	tenant          string
	executionId     string
	destinationOnly *bool
	expandAll       *bool
}

/*
FollowExecution Asynchronously follow a Running execution dependencies, all dependent Execution data will be streamed
When the queried Execution is completed, the channel will be closed.
This function rely on SSE.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background(). You can use it too to cancel the SSE connection
	@param executionId The execution id
	@param tenant
	@return ApiFollowExecutionRequest
*/
func (a *ExecutionsAPIService) FollowDependenciesExecution(ctx context.Context, executionId string, tenant string) ApiFollowDependenciesExecutionRequest {
	return ApiFollowDependenciesExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		tenant:      tenant,
		executionId: executionId,
	}
}

// If true, list only destination dependencies, otherwise list also source dependencies
func (r ApiFollowDependenciesExecutionRequest) DestinationOnly(destinationOnly bool) ApiFollowDependenciesExecutionRequest {
	r.destinationOnly = &destinationOnly
	return r
}

// If true, expand all dependencies recursively
func (r ApiFollowDependenciesExecutionRequest) ExpandAll(expandAll bool) ApiFollowDependenciesExecutionRequest {
	r.expandAll = &expandAll
	return r
}

func (r ApiFollowDependenciesExecutionRequest) Execute() (<-chan *ExecutionStatusEvent, error) {
	return r.ApiService.FollowDependenciesExecutionExecute(r)
}

/*
Follows an Execution events and send them to the output channel.
*/
func (a *ExecutionsAPIService) FollowDependenciesExecutionExecute(r ApiFollowDependenciesExecutionRequest) (<-chan *ExecutionStatusEvent, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	executionEvents := make(chan *ExecutionStatusEvent)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FollowDependenciesExecution")
	if err != nil {
		return executionEvents, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/follow-dependencies"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.destinationOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationOnly", *r.destinationOnly, "form", "")
	}
	if r.expandAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expandAll", *r.expandAll, "form", "")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	ctx, cancel := context.WithCancel(r.ctx)
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return executionEvents, err
	}

	conn := sse.NewConnection(req)

	stopSend := atomic.Bool{}

	conn.SubscribeToAll(func(event sse.Event) {
		if stopSend.Load() {
			return
		}
		switch event.LastEventID {
		case "start":
			// ignore first event
		case "progress", "end":
			exec, err := a.decodeExecutionStatusEvent(event.Data)
			if err != nil {
				fmt.Fprintln(os.Stderr, err)
				stopSend.Store(true)
				cancel()
			} else {
				executionEvents <- exec
			}
		case "end-all":
			_, err := a.decodeExecutionStatusEvent(event.Data)
			if err != nil {
				fmt.Fprintln(os.Stderr, err)
			}
			stopSend.Store(true)
			cancel()
		default: // no event name
			fmt.Printf("unhandled SSE event, id: %s, type: %s, data: %s\n", event.LastEventID, event.Type, event.Data)
		}
	})

	// SSE goroutine
	go func() {
		defer cancel()
		defer close(executionEvents)

		if err := conn.Connect(); err != nil {
			fmt.Fprintln(os.Stderr, err)
		}
	}()

	return executionEvents, nil
}

func (a *ExecutionsAPIService) decodeExecutionStatusEvent(body string) (*ExecutionStatusEvent, error) {
	executionStatusEvent := ExecutionStatusEvent{}
	err := a.client.decode(&executionStatusEvent, []byte(body), "application/json")
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  []byte(body),
			error: err.Error(),
		}
		return &executionStatusEvent, newErr
	}
	return &executionStatusEvent, nil
}

type ApiFollowExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	executionId string
}

/*
FollowExecution Asynchronously follow a Running execution, the current data of the Execution will be streamed in
the output channel everytime the Execution is updated (State changed, a Task finished..).
When the Execution is completed, the channel will be closed.
This function rely on SSE.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background(). You can use it too to cancel the SSE connection
	@param executionId The execution id
	@param tenant
	@return ApiFollowExecutionRequest
*/
func (a *ExecutionsAPIService) FollowExecution(ctx context.Context, executionId string, tenant string) ApiFollowExecutionRequest {
	return ApiFollowExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		tenant:      tenant,
		executionId: executionId,
	}
}
func (r ApiFollowExecutionRequest) Execute() (<-chan *Execution, error) {
	return r.ApiService.FollowExecutionExecute(r)
}

/*
Follows an Execution events and send them to the output channel.
*/
func (a *ExecutionsAPIService) FollowExecutionExecute(r ApiFollowExecutionRequest) (<-chan *Execution, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	executionEvents := make(chan *Execution)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FollowExecution")
	if err != nil {
		return executionEvents, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/follow"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	ctx, cancel := context.WithCancel(r.ctx)
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return executionEvents, err
	}

	conn := sse.NewConnection(req)

	stopSend := atomic.Bool{}

	conn.SubscribeToAll(func(event sse.Event) {
		if stopSend.Load() {
			return
		}
		switch event.LastEventID {
		case "start":
			// ignore first event
		case "progress":
			exec, err := a.decodeExecution(event.Data)
			if err != nil {
				fmt.Fprintln(os.Stderr, err)
				stopSend.Store(true)
				cancel()
			} else {
				executionEvents <- exec
			}
		case "end":
			exec, err := a.decodeExecution(event.Data)
			if err != nil {
				fmt.Fprintln(os.Stderr, err)
			} else {
				executionEvents <- exec
			}
			stopSend.Store(true)
			cancel()
		default: // no event name
			fmt.Printf("unhandled SSE event, id: %s, type: %s, data: %s\n", event.LastEventID, event.Type, event.Data)
		}
	})

	// SSE goroutine
	go func() {
		defer cancel()
		defer close(executionEvents)

		if err := conn.Connect(); err != nil {
			fmt.Fprintln(os.Stderr, err)
		}
	}()

	return executionEvents, nil
}

func (a *ExecutionsAPIService) decodeExecution(body string) (*Execution, error) {
	execution := Execution{}
	err := a.client.decode(&execution, []byte(body), "application/json")
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  []byte(body),
			error: err.Error(),
		}
		return &execution, newErr
	}
	return &execution, nil
}

type ApiForceRunByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiForceRunByIdsRequest) RequestBody(requestBody []string) ApiForceRunByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiForceRunByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.ForceRunByIdsExecute(r)
}

/*
ForceRunByIds Force run a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiForceRunByIdsRequest
*/
func (a *ExecutionsAPIService) ForceRunByIds(ctx context.Context, tenant string) ApiForceRunByIdsRequest {
	return ApiForceRunByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) ForceRunByIdsExecute(r ApiForceRunByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ForceRunByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/force-run/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceRunExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiForceRunExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ForceRunExecutionExecute(r)
}

/*
ForceRunExecution Force run an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiForceRunExecutionRequest
*/
func (a *ExecutionsAPIService) ForceRunExecution(ctx context.Context, executionId string, tenant string) ApiForceRunExecutionRequest {
	return ApiForceRunExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ForceRunExecutionExecute(r ApiForceRunExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ForceRunExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/force-run"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceRunExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	filters    *[]QueryFilter
}

// Filters
func (r ApiForceRunExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiForceRunExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiForceRunExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ForceRunExecutionsByQueryExecute(r)
}

/*
ForceRunExecutionsByQuery Force run executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiForceRunExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) ForceRunExecutionsByQuery(ctx context.Context, tenant string) ApiForceRunExecutionsByQueryRequest {
	return ApiForceRunExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ForceRunExecutionsByQueryExecute(r ApiForceRunExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ForceRunExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/force-run/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKillExecutionRequest struct {
	ctx             context.Context
	ApiService      *ExecutionsAPIService
	executionId     string
	isOnKillCascade *bool
	tenant          string
}

// Specifies whether killing the execution also kill all subflow executions.
func (r ApiKillExecutionRequest) IsOnKillCascade(isOnKillCascade bool) ApiKillExecutionRequest {
	r.isOnKillCascade = &isOnKillCascade
	return r
}

func (r ApiKillExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KillExecutionExecute(r)
}

/*
KillExecution Kill an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiKillExecutionRequest
*/
func (a *ExecutionsAPIService) KillExecution(ctx context.Context, executionId string, tenant string) ApiKillExecutionRequest {
	return ApiKillExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) KillExecutionExecute(r ApiKillExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.KillExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/kill"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isOnKillCascade == nil {
		return localVarReturnValue, nil, reportError("isOnKillCascade is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "isOnKillCascade", r.isOnKillCascade, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKillExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiKillExecutionsByIdsRequest) RequestBody(requestBody []string) ApiKillExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiKillExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.KillExecutionsByIdsExecute(r)
}

/*
KillExecutionsByIds Kill a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiKillExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) KillExecutionsByIds(ctx context.Context, tenant string) ApiKillExecutionsByIdsRequest {
	return ApiKillExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) KillExecutionsByIdsExecute(r ApiKillExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.KillExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/kill/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKillExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	filters    *[]QueryFilter
}

// Filters
func (r ApiKillExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiKillExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiKillExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KillExecutionsByQueryExecute(r)
}

/*
KillExecutionsByQuery Kill executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiKillExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) KillExecutionsByQuery(ctx context.Context, tenant string) ApiKillExecutionsByQueryRequest {
	return ApiKillExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) KillExecutionsByQueryExecute(r ApiKillExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.KillExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/kill/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLatestExecutionsRequest struct {
	ctx                                    context.Context
	ApiService                             *ExecutionsAPIService
	tenant                                 string
	executionRepositoryInterfaceFlowFilter *[]ExecutionRepositoryInterfaceFlowFilter
}

func (r ApiLatestExecutionsRequest) ExecutionRepositoryInterfaceFlowFilter(executionRepositoryInterfaceFlowFilter []ExecutionRepositoryInterfaceFlowFilter) ApiLatestExecutionsRequest {
	r.executionRepositoryInterfaceFlowFilter = &executionRepositoryInterfaceFlowFilter
	return r
}

func (r ApiLatestExecutionsRequest) Execute() ([]ExecutionControllerLastExecutionResponse, *http.Response, error) {
	return r.ApiService.LatestExecutionsExecute(r)
}

/*
LatestExecutions Get the latest execution for given flows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiLatestExecutionsRequest
*/
func (a *ExecutionsAPIService) LatestExecutions(ctx context.Context, tenant string) ApiLatestExecutionsRequest {
	return ApiLatestExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []ExecutionControllerLastExecutionResponse
func (a *ExecutionsAPIService) LatestExecutionsExecute(r ApiLatestExecutionsRequest) ([]ExecutionControllerLastExecutionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionControllerLastExecutionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.LatestExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionRepositoryInterfaceFlowFilter == nil {
		return localVarReturnValue, nil, reportError("executionRepositoryInterfaceFlowFilter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionRepositoryInterfaceFlowFilter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiPauseExecutionRequest) Execute() (*http.Response, error) {
	return r.ApiService.PauseExecutionExecute(r)
}

/*
PauseExecution Pause a running execution.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiPauseExecutionRequest
*/
func (a *ExecutionsAPIService) PauseExecution(ctx context.Context, executionId string, tenant string) ApiPauseExecutionRequest {
	return ApiPauseExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
func (a *ExecutionsAPIService) PauseExecutionExecute(r ApiPauseExecutionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PauseExecution")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPauseExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiPauseExecutionsByIdsRequest) RequestBody(requestBody []string) ApiPauseExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPauseExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.PauseExecutionsByIdsExecute(r)
}

/*
PauseExecutionsByIds Pause a list of running executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiPauseExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) PauseExecutionsByIds(ctx context.Context, tenant string) ApiPauseExecutionsByIdsRequest {
	return ApiPauseExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) PauseExecutionsByIdsExecute(r ApiPauseExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PauseExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/pause/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	filters    *[]QueryFilter
}

// Filters
func (r ApiPauseExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiPauseExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiPauseExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PauseExecutionsByQueryExecute(r)
}

/*
PauseExecutionsByQuery Pause executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiPauseExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) PauseExecutionsByQuery(ctx context.Context, tenant string) ApiPauseExecutionsByQueryRequest {
	return ApiPauseExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) PauseExecutionsByQueryExecute(r ApiPauseExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PauseExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/pause/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	taskRunId   *string
	revision    *int32
	breakpoints *string
}

// The taskrun id
func (r ApiReplayExecutionRequest) TaskRunId(taskRunId string) ApiReplayExecutionRequest {
	r.taskRunId = &taskRunId
	return r
}

// The flow revision to use for new execution
func (r ApiReplayExecutionRequest) Revision(revision int32) ApiReplayExecutionRequest {
	r.revision = &revision
	return r
}

// Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiReplayExecutionRequest) Breakpoints(breakpoints string) ApiReplayExecutionRequest {
	r.breakpoints = &breakpoints
	return r
}

func (r ApiReplayExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ReplayExecutionExecute(r)
}

/*
ReplayExecution Create a new execution from an old one and start it from a specified task run id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId the original execution id to clone
	@param tenant
	@return ApiReplayExecutionRequest
*/
func (a *ExecutionsAPIService) ReplayExecution(ctx context.Context, executionId string, tenant string) ApiReplayExecutionRequest {
	return ApiReplayExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ReplayExecutionExecute(r ApiReplayExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/replay"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskRunId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskRunId", r.taskRunId, "form", "")
	}
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionWithinputsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	taskRunId   *string
	revision    *int32
	breakpoints *string
	formData    *map[string]any
}

// The taskrun id
func (r ApiReplayExecutionWithinputsRequest) TaskRunId(taskRunId string) ApiReplayExecutionWithinputsRequest {
	r.taskRunId = &taskRunId
	return r
}

// The flow revision to use for new execution
func (r ApiReplayExecutionWithinputsRequest) Revision(revision int32) ApiReplayExecutionWithinputsRequest {
	r.revision = &revision
	return r
}

// Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiReplayExecutionWithinputsRequest) Breakpoints(breakpoints string) ApiReplayExecutionWithinputsRequest {
	r.breakpoints = &breakpoints
	return r
}

// the request multipart/form-data content
func (r ApiReplayExecutionWithinputsRequest) FormData(formData map[string]any) ApiReplayExecutionWithinputsRequest {
	r.formData = &formData
	return r
}

func (r ApiReplayExecutionWithinputsRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ReplayExecutionWithinputsExecute(r)
}

/*
ReplayExecutionWithinputs Create a new execution from an old one and start it from a specified task run id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId the original execution id to clone
	@param tenant
	@return ApiReplayExecutionWithinputsRequest
*/
func (a *ExecutionsAPIService) ReplayExecutionWithinputs(ctx context.Context, executionId string, tenant string) ApiReplayExecutionWithinputsRequest {
	return ApiReplayExecutionWithinputsRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ReplayExecutionWithinputsExecute(r ApiReplayExecutionWithinputsRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecutionWithinputs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/replay-with-inputs"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskRunId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskRunId", r.taskRunId, "form", "")
	}
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}

	if r.formData != nil {
		for key, val := range *r.formData {
			switch v := val.(type) {
			case string:
				localVarFormParams.Add(key, v)
			case *string:
				if v != nil {
					localVarFormParams.Add(key, *v)
				}
			case []string:
				for _, s := range v {
					localVarFormParams.Add(key, s)
				}
			case []interface{}:
				for _, item := range v {
					localVarFormParams.Add(key, fmt.Sprint(item))
				}
			case time.Time:
				localVarFormParams.Add(key, v.Format(time.RFC3339))
			case *time.Time:
				if v != nil {
					localVarFormParams.Add(key, v.Format(time.RFC3339))
				}
			default:
				localVarFormParams.Add(key, fmt.Sprint(v))
			}
		}
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionsByIdsRequest struct {
	ctx            context.Context
	ApiService     *ExecutionsAPIService
	tenant         string
	requestBody    *[]string
	latestRevision *bool
}

// The list of executions id
func (r ApiReplayExecutionsByIdsRequest) RequestBody(requestBody []string) ApiReplayExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

// If latest revision should be used
func (r ApiReplayExecutionsByIdsRequest) LatestRevision(latestRevision bool) ApiReplayExecutionsByIdsRequest {
	r.latestRevision = &latestRevision
	return r
}

func (r ApiReplayExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.ReplayExecutionsByIdsExecute(r)
}

/*
ReplayExecutionsByIds Create new executions from old ones. Keep the flow revision

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiReplayExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) ReplayExecutionsByIds(ctx context.Context, tenant string) ApiReplayExecutionsByIdsRequest {
	return ApiReplayExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) ReplayExecutionsByIdsExecute(r ApiReplayExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/replay/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.latestRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestRevision", r.latestRevision, "form", "")
	} else {
		var defaultValue bool = false
		r.latestRevision = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionsByQueryRequest struct {
	ctx            context.Context
	ApiService     *ExecutionsAPIService
	tenant         string
	filters        *[]QueryFilter
	latestRevision *bool
}

// Filters
func (r ApiReplayExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiReplayExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

// If latest revision should be used
func (r ApiReplayExecutionsByQueryRequest) LatestRevision(latestRevision bool) ApiReplayExecutionsByQueryRequest {
	r.latestRevision = &latestRevision
	return r
}

func (r ApiReplayExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ReplayExecutionsByQueryExecute(r)
}

/*
ReplayExecutionsByQuery Create new executions from old ones filter by query parameters. Keep the flow revision

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiReplayExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) ReplayExecutionsByQuery(ctx context.Context, tenant string) ApiReplayExecutionsByQueryRequest {
	return ApiReplayExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ReplayExecutionsByQueryExecute(r ApiReplayExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/replay/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	if r.latestRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestRevision", r.latestRevision, "form", "")
	} else {
		var defaultValue bool = false
		r.latestRevision = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	revision    *int32
}

// The flow revision to use for new execution
func (r ApiRestartExecutionRequest) Revision(revision int32) ApiRestartExecutionRequest {
	r.revision = &revision
	return r
}

func (r ApiRestartExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.RestartExecutionExecute(r)
}

/*
RestartExecution Restart a new execution from an old one

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiRestartExecutionRequest
*/
func (a *ExecutionsAPIService) RestartExecution(ctx context.Context, executionId string, tenant string) ApiRestartExecutionRequest {
	return ApiRestartExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) RestartExecutionExecute(r ApiRestartExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.RestartExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiRestartExecutionsByIdsRequest) RequestBody(requestBody []string) ApiRestartExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRestartExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.RestartExecutionsByIdsExecute(r)
}

/*
RestartExecutionsByIds Restart a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiRestartExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) RestartExecutionsByIds(ctx context.Context, tenant string) ApiRestartExecutionsByIdsRequest {
	return ApiRestartExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) RestartExecutionsByIdsExecute(r ApiRestartExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.RestartExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/restart/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	filters    *[]QueryFilter
}

// Filters
func (r ApiRestartExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiRestartExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiRestartExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RestartExecutionsByQueryExecute(r)
}

/*
RestartExecutionsByQuery Restart executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiRestartExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) RestartExecutionsByQuery(ctx context.Context, tenant string) ApiRestartExecutionsByQueryRequest {
	return ApiRestartExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) RestartExecutionsByQueryExecute(r ApiRestartExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.RestartExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/restart/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	formData    *map[string]any
}

// the request multipart/form-data content
func (r ApiResumeExecutionRequest) FormData(formData map[string]any) ApiResumeExecutionRequest {
	r.formData = &formData
	return r
}

func (r ApiResumeExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ResumeExecutionExecute(r)
}

/*
ResumeExecution Resume a paused execution.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiResumeExecutionRequest
*/
func (a *ExecutionsAPIService) ResumeExecution(ctx context.Context, executionId string, tenant string) ApiResumeExecutionRequest {
	return ApiResumeExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ResumeExecutionExecute(r ApiResumeExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.formData != nil {
		for key, val := range *r.formData {
			switch v := val.(type) {
			case string:
				localVarFormParams.Add(key, v)
			case *string:
				if v != nil {
					localVarFormParams.Add(key, *v)
				}
			case []string:
				for _, s := range v {
					localVarFormParams.Add(key, s)
				}
			case []interface{}:
				for _, item := range v {
					localVarFormParams.Add(key, fmt.Sprint(item))
				}
			case time.Time:
				localVarFormParams.Add(key, v.Format(time.RFC3339))
			case *time.Time:
				if v != nil {
					localVarFormParams.Add(key, v.Format(time.RFC3339))
				}
			default:
				localVarFormParams.Add(key, fmt.Sprint(v))
			}
		}
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiResumeExecutionsByIdsRequest) RequestBody(requestBody []string) ApiResumeExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiResumeExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.ResumeExecutionsByIdsExecute(r)
}

/*
ResumeExecutionsByIds Resume a list of paused executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiResumeExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) ResumeExecutionsByIds(ctx context.Context, tenant string) ApiResumeExecutionsByIdsRequest {
	return ApiResumeExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) ResumeExecutionsByIdsExecute(r ApiResumeExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/resume/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	filters    *[]QueryFilter
}

// Filters
func (r ApiResumeExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiResumeExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiResumeExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ResumeExecutionsByQueryExecute(r)
}

/*
ResumeExecutionsByQuery Resume executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiResumeExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) ResumeExecutionsByQuery(ctx context.Context, tenant string) ApiResumeExecutionsByQueryRequest {
	return ApiResumeExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ResumeExecutionsByQueryExecute(r ApiResumeExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/resume/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchExecutionsRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	page       *int32
	size       *int32
	tenant     string
	sort       *[]string
	filters    *[]QueryFilter
}

// The current page
func (r ApiSearchExecutionsRequest) Page(page int32) ApiSearchExecutionsRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchExecutionsRequest) Size(size int32) ApiSearchExecutionsRequest {
	r.size = &size
	return r
}

// The sort of current page
func (r ApiSearchExecutionsRequest) Sort(sort []string) ApiSearchExecutionsRequest {
	r.sort = &sort
	return r
}

// Filters
func (r ApiSearchExecutionsRequest) Filters(filters []QueryFilter) ApiSearchExecutionsRequest {
	r.filters = &filters
	return r
}

func (r ApiSearchExecutionsRequest) Execute() (*PagedResultsExecution, *http.Response, error) {
	return r.ApiService.SearchExecutionsExecute(r)
}

/*
SearchExecutions Search for executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSearchExecutionsRequest
*/
func (a *ExecutionsAPIService) SearchExecutions(ctx context.Context, tenant string) ApiSearchExecutionsRequest {
	return ApiSearchExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsExecution
func (a *ExecutionsAPIService) SearchExecutionsExecute(r ApiSearchExecutionsRequest) (*PagedResultsExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SearchExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/search"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if *r.size < 1 {
		return localVarReturnValue, nil, reportError("size must be greater than 1")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchExecutionsByFlowIdRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  *string
	flowId     *string
	page       *int32
	size       *int32
	tenant     string
}

// The flow namespace
func (r ApiSearchExecutionsByFlowIdRequest) Namespace(namespace string) ApiSearchExecutionsByFlowIdRequest {
	r.namespace = &namespace
	return r
}

// The flow id
func (r ApiSearchExecutionsByFlowIdRequest) FlowId(flowId string) ApiSearchExecutionsByFlowIdRequest {
	r.flowId = &flowId
	return r
}

// The current page
func (r ApiSearchExecutionsByFlowIdRequest) Page(page int32) ApiSearchExecutionsByFlowIdRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchExecutionsByFlowIdRequest) Size(size int32) ApiSearchExecutionsByFlowIdRequest {
	r.size = &size
	return r
}

func (r ApiSearchExecutionsByFlowIdRequest) Execute() (*PagedResultsExecution, *http.Response, error) {
	return r.ApiService.SearchExecutionsByFlowIdExecute(r)
}

/*
SearchExecutionsByFlowId Search for executions for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSearchExecutionsByFlowIdRequest
*/
func (a *ExecutionsAPIService) SearchExecutionsByFlowId(ctx context.Context, tenant string) ApiSearchExecutionsByFlowIdRequest {
	return ApiSearchExecutionsByFlowIdRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsExecution
func (a *ExecutionsAPIService) SearchExecutionsByFlowIdExecute(r ApiSearchExecutionsByFlowIdRequest) (*PagedResultsExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SearchExecutionsByFlowId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.namespace == nil {
		return localVarReturnValue, nil, reportError("namespace is required and must be specified")
	}
	if r.flowId == nil {
		return localVarReturnValue, nil, reportError("flowId is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if *r.size < 1 {
		return localVarReturnValue, nil, reportError("size must be greater than 1")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLabelsOnTerminatedExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	label       *[]Label
}

// The labels to add to the execution
func (r ApiSetLabelsOnTerminatedExecutionRequest) Label(label []Label) ApiSetLabelsOnTerminatedExecutionRequest {
	r.label = &label
	return r
}

func (r ApiSetLabelsOnTerminatedExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetLabelsOnTerminatedExecutionExecute(r)
}

/*
SetLabelsOnTerminatedExecution Add or update labels of a terminated execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiSetLabelsOnTerminatedExecutionRequest
*/
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecution(ctx context.Context, executionId string, tenant string) ApiSetLabelsOnTerminatedExecutionRequest {
	return ApiSetLabelsOnTerminatedExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionExecute(r ApiSetLabelsOnTerminatedExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SetLabelsOnTerminatedExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLabelsOnTerminatedExecutionsByIdsRequest struct {
	ctx                                      context.Context
	ApiService                               *ExecutionsAPIService
	tenant                                   string
	executionControllerSetLabelsByIdsRequest *ExecutionControllerSetLabelsByIdsRequest
}

// The request containing a list of labels and a list of executions
func (r ApiSetLabelsOnTerminatedExecutionsByIdsRequest) ExecutionControllerSetLabelsByIdsRequest(executionControllerSetLabelsByIdsRequest ExecutionControllerSetLabelsByIdsRequest) ApiSetLabelsOnTerminatedExecutionsByIdsRequest {
	r.executionControllerSetLabelsByIdsRequest = &executionControllerSetLabelsByIdsRequest
	return r
}

func (r ApiSetLabelsOnTerminatedExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.SetLabelsOnTerminatedExecutionsByIdsExecute(r)
}

/*
SetLabelsOnTerminatedExecutionsByIds Set labels on a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSetLabelsOnTerminatedExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByIds(ctx context.Context, tenant string) ApiSetLabelsOnTerminatedExecutionsByIdsRequest {
	return ApiSetLabelsOnTerminatedExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByIdsExecute(r ApiSetLabelsOnTerminatedExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SetLabelsOnTerminatedExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/labels/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionControllerSetLabelsByIdsRequest == nil {
		return localVarReturnValue, nil, reportError("executionControllerSetLabelsByIdsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionControllerSetLabelsByIdsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLabelsOnTerminatedExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	label      *[]Label
	filters    *[]QueryFilter
}

// The labels to add to the execution
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Label(label []Label) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.label = &label
	return r
}

// Filters
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetLabelsOnTerminatedExecutionsByQueryExecute(r)
}

/*
SetLabelsOnTerminatedExecutionsByQuery Set label on executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSetLabelsOnTerminatedExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByQuery(ctx context.Context, tenant string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	return ApiSetLabelsOnTerminatedExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByQueryExecute(r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SetLabelsOnTerminatedExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/labels/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerExecutionByGetWebhookRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	id         string
	key        string
	tenant     string
}

func (r ApiTriggerExecutionByGetWebhookRequest) Execute() (*ExecutionControllerWebhookResponse, *http.Response, error) {
	return r.ApiService.TriggerExecutionByGetWebhookExecute(r)
}

/*
TriggerExecutionByGetWebhook Trigger a new execution by GET webhook trigger

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param key The webhook trigger uid
	@param tenant
	@return ApiTriggerExecutionByGetWebhookRequest
*/
func (a *ExecutionsAPIService) TriggerExecutionByGetWebhook(ctx context.Context, namespace string, id string, key string, tenant string) ApiTriggerExecutionByGetWebhookRequest {
	return ApiTriggerExecutionByGetWebhookRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		key:        key,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return ExecutionControllerWebhookResponse
func (a *ExecutionsAPIService) TriggerExecutionByGetWebhookExecute(r ApiTriggerExecutionByGetWebhookRequest) (*ExecutionControllerWebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionControllerWebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.TriggerExecutionByGetWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnqueueExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	state       *StateType
	tenant      string
}

// The new state of the execution
func (r ApiUnqueueExecutionRequest) State(state StateType) ApiUnqueueExecutionRequest {
	r.state = &state
	return r
}

func (r ApiUnqueueExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.UnqueueExecutionExecute(r)
}

/*
UnqueueExecution Unqueue an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiUnqueueExecutionRequest
*/
func (a *ExecutionsAPIService) UnqueueExecution(ctx context.Context, executionId string, tenant string) ApiUnqueueExecutionRequest {
	return ApiUnqueueExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) UnqueueExecutionExecute(r ApiUnqueueExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UnqueueExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/unqueue"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnqueueExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	state       *StateType
	tenant      string
	requestBody *[]string
}

// The new state of the unqueued executions
func (r ApiUnqueueExecutionsByIdsRequest) State(state StateType) ApiUnqueueExecutionsByIdsRequest {
	r.state = &state
	return r
}

// The list of executions id
func (r ApiUnqueueExecutionsByIdsRequest) RequestBody(requestBody []string) ApiUnqueueExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUnqueueExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.UnqueueExecutionsByIdsExecute(r)
}

/*
UnqueueExecutionsByIds Unqueue a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUnqueueExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) UnqueueExecutionsByIds(ctx context.Context, tenant string) ApiUnqueueExecutionsByIdsRequest {
	return ApiUnqueueExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) UnqueueExecutionsByIdsExecute(r ApiUnqueueExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UnqueueExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/unqueue/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnqueueExecutionsByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
	filters    *[]QueryFilter
	newState   *StateType
}

// Filters
func (r ApiUnqueueExecutionsByQueryRequest) Filters(filters []QueryFilter) ApiUnqueueExecutionsByQueryRequest {
	r.filters = &filters
	return r
}

// The new state of the unqueued executions
func (r ApiUnqueueExecutionsByQueryRequest) NewState(newState StateType) ApiUnqueueExecutionsByQueryRequest {
	r.newState = &newState
	return r
}

func (r ApiUnqueueExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnqueueExecutionsByQueryExecute(r)
}

/*
UnqueueExecutionsByQuery Unqueue executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUnqueueExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) UnqueueExecutionsByQuery(ctx context.Context, tenant string) ApiUnqueueExecutionsByQueryRequest {
	return ApiUnqueueExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) UnqueueExecutionsByQueryExecute(r ApiUnqueueExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UnqueueExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/unqueue/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	if r.newState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newState", r.newState, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExecutionStatusRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	status      *StateType
	tenant      string
}

// The new state of the execution
func (r ApiUpdateExecutionStatusRequest) Status(status StateType) ApiUpdateExecutionStatusRequest {
	r.status = &status
	return r
}

func (r ApiUpdateExecutionStatusRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.UpdateExecutionStatusExecute(r)
}

/*
UpdateExecutionStatus Change the state of an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiUpdateExecutionStatusRequest
*/
func (a *ExecutionsAPIService) UpdateExecutionStatus(ctx context.Context, executionId string, tenant string) ApiUpdateExecutionStatusRequest {
	return ApiUpdateExecutionStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) UpdateExecutionStatusExecute(r ApiUpdateExecutionStatusRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateExecutionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/change-status"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExecutionsStatusByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	newStatus   *StateType
	tenant      string
	requestBody *[]string
}

// The new state of the executions
func (r ApiUpdateExecutionsStatusByIdsRequest) NewStatus(newStatus StateType) ApiUpdateExecutionsStatusByIdsRequest {
	r.newStatus = &newStatus
	return r
}

// The list of executions id
func (r ApiUpdateExecutionsStatusByIdsRequest) RequestBody(requestBody []string) ApiUpdateExecutionsStatusByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUpdateExecutionsStatusByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.UpdateExecutionsStatusByIdsExecute(r)
}

/*
UpdateExecutionsStatusByIds Change executions state by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUpdateExecutionsStatusByIdsRequest
*/
func (a *ExecutionsAPIService) UpdateExecutionsStatusByIds(ctx context.Context, tenant string) ApiUpdateExecutionsStatusByIdsRequest {
	return ApiUpdateExecutionsStatusByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) UpdateExecutionsStatusByIdsExecute(r ApiUpdateExecutionsStatusByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateExecutionsStatusByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/change-status/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newStatus == nil {
		return localVarReturnValue, nil, reportError("newStatus is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "newStatus", r.newStatus, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExecutionsStatusByQueryRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	newStatus  *StateType
	tenant     string
	filters    *[]QueryFilter
}

// The new state of the executions
func (r ApiUpdateExecutionsStatusByQueryRequest) NewStatus(newStatus StateType) ApiUpdateExecutionsStatusByQueryRequest {
	r.newStatus = &newStatus
	return r
}

// Filters
func (r ApiUpdateExecutionsStatusByQueryRequest) Filters(filters []QueryFilter) ApiUpdateExecutionsStatusByQueryRequest {
	r.filters = &filters
	return r
}

func (r ApiUpdateExecutionsStatusByQueryRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.UpdateExecutionsStatusByQueryExecute(r)
}

/*
UpdateExecutionsStatusByQuery Change executions state by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUpdateExecutionsStatusByQueryRequest
*/
func (a *ExecutionsAPIService) UpdateExecutionsStatusByQuery(ctx context.Context, tenant string) ApiUpdateExecutionsStatusByQueryRequest {
	return ApiUpdateExecutionsStatusByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) UpdateExecutionsStatusByQueryExecute(r ApiUpdateExecutionsStatusByQueryRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateExecutionsStatusByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/change-status/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newStatus == nil {
		return localVarReturnValue, nil, reportError("newStatus is required and must be specified")
	}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "newStatus", r.newStatus, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTaskRunStateRequest struct {
	ctx                             context.Context
	ApiService                      *ExecutionsAPIService
	executionId                     string
	tenant                          string
	executionControllerStateRequest *ExecutionControllerStateRequest
}

// the taskRun id and state to apply
func (r ApiUpdateTaskRunStateRequest) ExecutionControllerStateRequest(executionControllerStateRequest ExecutionControllerStateRequest) ApiUpdateTaskRunStateRequest {
	r.executionControllerStateRequest = &executionControllerStateRequest
	return r
}

func (r ApiUpdateTaskRunStateRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.UpdateTaskRunStateExecute(r)
}

/*
UpdateTaskRunState Change state for a taskrun in an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiUpdateTaskRunStateRequest
*/
func (a *ExecutionsAPIService) UpdateTaskRunState(ctx context.Context, executionId string, tenant string) ApiUpdateTaskRunStateRequest {
	return ApiUpdateTaskRunStateRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) UpdateTaskRunStateExecute(r ApiUpdateTaskRunStateRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateTaskRunState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/state"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionControllerStateRequest == nil {
		return localVarReturnValue, nil, reportError("executionControllerStateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionControllerStateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
