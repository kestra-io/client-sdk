/*
 * Kestra EE
 * All API operations allow an optional tenant identifier in the HTTP path, if you don't use multi-tenancy you must omit the tenant identifier.<br/> This means that, for example, when trying to access the Flows API, instead of using <code>/api/v1/{tenant}/flows</code> you must use <code>/api/v1/flows</code>.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.kestra.api.sdk.api;

import com.fasterxml.jackson.core.type.TypeReference;

import io.kestra.api.sdk.internal.ApiException;
import io.kestra.api.sdk.internal.ApiClient;
import io.kestra.api.sdk.internal.BaseApi;
import io.kestra.api.sdk.internal.Configuration;
import io.kestra.api.sdk.internal.Pair;

import io.kestra.api.sdk.model.BulkResponse;
import io.kestra.api.sdk.model.Create5200Response;
import java.io.File;
import io.kestra.api.sdk.model.Flow;
import io.kestra.api.sdk.model.FlowControllerTaskValidationType;
import io.kestra.api.sdk.model.FlowGraph;
import io.kestra.api.sdk.model.FlowScope;
import io.kestra.api.sdk.model.FlowTopologyGraph;
import io.kestra.api.sdk.model.FlowWithSource;
import io.kestra.api.sdk.model.IdWithNamespace;
import io.kestra.api.sdk.model.PagedResultsFlow;
import io.kestra.api.sdk.model.PagedResultsSearchResultFlow;
import io.kestra.api.sdk.model.Task;
import io.kestra.api.sdk.model.Update3200Response;
import io.kestra.api.sdk.model.UpdateNamespace200Response;
import io.kestra.api.sdk.model.ValidateConstraintViolation;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-31T15:48:45.246126227Z[Etc/UTC]", comments = "Generator version: 7.11.0-SNAPSHOT")
public class FlowsApi extends BaseApi {

  public FlowsApi() {
    super(Configuration.getDefaultApiClient());
  }

  public FlowsApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param body  (required)
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> bulkUpdate(Boolean delete, String body) throws ApiException {
    return this.bulkUpdate(delete, body, Collections.emptyMap());
  }


  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> bulkUpdate(Boolean delete, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling bulkUpdate");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling bulkUpdate");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/bulk";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<FlowWithSource>> localVarReturnType = new TypeReference<List<FlowWithSource>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param tenant  (required)
   * @param body  (required)
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> bulkUpdate1(Boolean delete, String tenant, String body) throws ApiException {
    return this.bulkUpdate1(delete, tenant, body, Collections.emptyMap());
  }


  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param tenant  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> bulkUpdate1(Boolean delete, String tenant, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling bulkUpdate1");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling bulkUpdate1");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling bulkUpdate1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/bulk"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<FlowWithSource>> localVarReturnType = new TypeReference<List<FlowWithSource>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a flow from json object
   * 
   * @param tenant  (required)
   * @param flow  (required)
   * @return Create5200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Create5200Response create30(String tenant, Flow flow) throws ApiException {
    return this.create30(tenant, flow, Collections.emptyMap());
  }


  /**
   * Create a flow from json object
   * 
   * @param tenant  (required)
   * @param flow  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Create5200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Create5200Response create30(String tenant, Flow flow, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = flow;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling create30");
    }
    
    // verify the required parameter 'flow' is set
    if (flow == null) {
      throw new ApiException(400, "Missing the required parameter 'flow' when calling create30");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Create5200Response> localVarReturnType = new TypeReference<Create5200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a flow from json object
   * 
   * @param flow  (required)
   * @return Create5200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Create5200Response create5(Flow flow) throws ApiException {
    return this.create5(flow, Collections.emptyMap());
  }


  /**
   * Create a flow from json object
   * 
   * @param flow  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Create5200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Create5200Response create5(Flow flow, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = flow;
    
    // verify the required parameter 'flow' is set
    if (flow == null) {
      throw new ApiException(400, "Missing the required parameter 'flow' when calling create5");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Create5200Response> localVarReturnType = new TypeReference<Create5200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @throws ApiException if fails to make API call
   */
  public void delete33(String namespace, String id, String tenant) throws ApiException {
    this.delete33(namespace, id, tenant, Collections.emptyMap());
  }


  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void delete33(String namespace, String id, String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling delete33");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling delete33");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling delete33");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }

  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @throws ApiException if fails to make API call
   */
  public void delete5(String namespace, String id) throws ApiException {
    this.delete5(namespace, id, Collections.emptyMap());
  }


  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void delete5(String namespace, String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling delete5");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling delete5");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }

  /**
   * Delete flows by their IDs.
   * 
   * @param idWithNamespace  (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByIds1(List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.deleteByIds1(idWithNamespace, Collections.emptyMap());
  }


  /**
   * Delete flows by their IDs.
   * 
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByIds1(List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling deleteByIds1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/delete/by-ids";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByIds4(String tenant, List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.deleteByIds4(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Delete flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByIds4(String tenant, List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteByIds4");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling deleteByIds4");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/delete/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete flows returned by the query parameters.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByQuery1(String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.deleteByQuery1(q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Delete flows returned by the query parameters.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByQuery1(String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/delete/by-query";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByQuery4(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.deleteByQuery4(tenant, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Delete flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteByQuery4(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteByQuery4");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/delete/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies(String namespace, String id, Boolean destinationOnly) throws ApiException {
    return this.dependencies(namespace, id, destinationOnly, Collections.emptyMap());
  }


  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies(String namespace, String id, Boolean destinationOnly, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling dependencies");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling dependencies");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling dependencies");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies1(String namespace, Boolean destinationOnly) throws ApiException {
    return this.dependencies1(namespace, destinationOnly, Collections.emptyMap());
  }


  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies1(String namespace, Boolean destinationOnly, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling dependencies1");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling dependencies1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/namespaces/{namespace}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies2(String namespace, String id, Boolean destinationOnly, String tenant) throws ApiException {
    return this.dependencies2(namespace, id, destinationOnly, tenant, Collections.emptyMap());
  }


  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies2(String namespace, String id, Boolean destinationOnly, String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling dependencies2");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling dependencies2");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling dependencies2");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling dependencies2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies3(String namespace, Boolean destinationOnly, String tenant) throws ApiException {
    return this.dependencies3(namespace, destinationOnly, tenant, Collections.emptyMap());
  }


  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph dependencies3(String namespace, Boolean destinationOnly, String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling dependencies3");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling dependencies3");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling dependencies3");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/namespaces/{namespace}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Disable flows by their IDs.
   * 
   * @param idWithNamespace  (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByIds(List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.disableByIds(idWithNamespace, Collections.emptyMap());
  }


  /**
   * Disable flows by their IDs.
   * 
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByIds(List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling disableByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/disable/by-ids";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Disable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByIds1(String tenant, List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.disableByIds1(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Disable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByIds1(String tenant, List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling disableByIds1");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling disableByIds1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/disable/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Disable flows returned by the query parameters.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByQuery(String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.disableByQuery(q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Disable flows returned by the query parameters.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByQuery(String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/disable/by-query";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Disable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByQuery1(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.disableByQuery1(tenant, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Disable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableByQuery1(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling disableByQuery1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/disable/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Enable flows by their IDs.
   * 
   * @param idWithNamespace  (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByIds(List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.enableByIds(idWithNamespace, Collections.emptyMap());
  }


  /**
   * Enable flows by their IDs.
   * 
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByIds(List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling enableByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/enable/by-ids";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Enable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByIds1(String tenant, List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.enableByIds1(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Enable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByIds1(String tenant, List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling enableByIds1");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling enableByIds1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/enable/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Enable flows returned by the query parameters.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByQuery(String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.enableByQuery(q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Enable flows returned by the query parameters.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByQuery(String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/enable/by-query";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Enable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByQuery1(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.enableByQuery1(tenant, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Enable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableByQuery1(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling enableByQuery1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/enable/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param idWithNamespace  (required)
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByIds(List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.exportByIds(idWithNamespace, Collections.emptyMap());
  }


  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByIds(List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling exportByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/export/by-ids";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<byte[]>> localVarReturnType = new TypeReference<List<byte[]>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByIds2(String tenant, List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.exportByIds2(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param idWithNamespace  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByIds2(String tenant, List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling exportByIds2");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling exportByIds2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/export/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<byte[]>> localVarReturnType = new TypeReference<List<byte[]>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByQuery(String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.exportByQuery(q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByQuery(String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/export/by-query";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<byte[]>> localVarReturnType = new TypeReference<List<byte[]>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByQuery2(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.exportByQuery2(tenant, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public List<byte[]> exportByQuery2(String tenant, String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling exportByQuery2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/export/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<byte[]>> localVarReturnType = new TypeReference<List<byte[]>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow find31(Integer page, Integer size, String tenant, List<String> sort, String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.find31(page, size, tenant, sort, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow find31(Integer page, Integer size, String tenant, List<String> sort, String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling find31");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling find31");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling find31");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/search"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<PagedResultsFlow> localVarReturnType = new TypeReference<PagedResultsFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow find5(Integer page, Integer size, List<String> sort, String q, List<FlowScope> scope, String namespace, List<String> labels) throws ApiException {
    return this.find5(page, size, sort, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow find5(Integer page, Integer size, List<String> sort, String q, List<FlowScope> scope, String namespace, List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling find5");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling find5");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/search";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<PagedResultsFlow> localVarReturnType = new TypeReference<PagedResultsFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraph1(String namespace, String id, Integer revision, List<String> subflows) throws ApiException {
    return this.flowGraph1(namespace, id, revision, subflows, Collections.emptyMap());
  }


  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraph1(String namespace, String id, Integer revision, List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flowGraph1");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling flowGraph1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}/graph"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraph3(String namespace, String id, String tenant, Integer revision, List<String> subflows) throws ApiException {
    return this.flowGraph3(namespace, id, tenant, revision, subflows, Collections.emptyMap());
  }


  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraph3(String namespace, String id, String tenant, Integer revision, List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flowGraph3");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling flowGraph3");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling flowGraph3");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/graph"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Generate a graph for a flow source
   * 
   * @param body  (required)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraphSource(String body, List<String> subflows) throws ApiException {
    return this.flowGraphSource(body, subflows, Collections.emptyMap());
  }


  /**
   * Generate a graph for a flow source
   * 
   * @param body  (required)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraphSource(String body, List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling flowGraphSource");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/graph";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Generate a graph for a flow source
   * 
   * @param tenant  (required)
   * @param body  (required)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraphSource1(String tenant, String body, List<String> subflows) throws ApiException {
    return this.flowGraphSource1(tenant, body, subflows, Collections.emptyMap());
  }


  /**
   * Generate a graph for a flow source
   * 
   * @param tenant  (required)
   * @param body  (required)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph flowGraphSource1(String tenant, String body, List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling flowGraphSource1");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling flowGraphSource1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/graph"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param revision The flow revision (optional)
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task flowTask(String namespace, String id, String taskId, Integer revision) throws ApiException {
    return this.flowTask(namespace, id, taskId, revision, Collections.emptyMap());
  }


  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param revision The flow revision (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task flowTask(String namespace, String id, String taskId, Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flowTask");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling flowTask");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling flowTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}/tasks/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Task> localVarReturnType = new TypeReference<Task>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task flowTask1(String namespace, String id, String taskId, String tenant, Integer revision) throws ApiException {
    return this.flowTask1(namespace, id, taskId, tenant, revision, Collections.emptyMap());
  }


  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task flowTask1(String namespace, String id, String taskId, String tenant, Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling flowTask1");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling flowTask1");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling flowTask1");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling flowTask1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Task> localVarReturnType = new TypeReference<Task>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> getFlowsByNamespace1(String namespace) throws ApiException {
    return this.getFlowsByNamespace1(namespace, Collections.emptyMap());
  }


  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> getFlowsByNamespace1(String namespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling getFlowsByNamespace1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<Flow>> localVarReturnType = new TypeReference<List<Flow>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param tenant  (required)
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> getFlowsByNamespace3(String namespace, String tenant) throws ApiException {
    return this.getFlowsByNamespace3(namespace, tenant, Collections.emptyMap());
  }


  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> getFlowsByNamespace3(String namespace, String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling getFlowsByNamespace3");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling getFlowsByNamespace3");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<Flow>> localVarReturnType = new TypeReference<List<Flow>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows(File fileUpload) throws ApiException {
    return this.importFlows(fileUpload, Collections.emptyMap());
  }


  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows(File fileUpload, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/import";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    if (fileUpload != null)
      localVarFormParams.put("fileUpload", fileUpload);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "multipart/form-data"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows1(String tenant, File fileUpload) throws ApiException {
    return this.importFlows1(tenant, fileUpload, Collections.emptyMap());
  }


  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows1(String tenant, File fileUpload, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling importFlows1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/import"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    if (fileUpload != null)
      localVarFormParams.put("fileUpload", fileUpload);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "multipart/form-data"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param tenant  (required)
   * @param revision Get latest revision by default (optional)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object index24(String namespace, String id, Boolean source, Boolean allowDeleted, String tenant, Integer revision) throws ApiException {
    return this.index24(namespace, id, source, allowDeleted, tenant, revision, Collections.emptyMap());
  }


  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param tenant  (required)
   * @param revision Get latest revision by default (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object index24(String namespace, String id, Boolean source, Boolean allowDeleted, String tenant, Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling index24");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling index24");
    }
    
    // verify the required parameter 'source' is set
    if (source == null) {
      throw new ApiException(400, "Missing the required parameter 'source' when calling index24");
    }
    
    // verify the required parameter 'allowDeleted' is set
    if (allowDeleted == null) {
      throw new ApiException(400, "Missing the required parameter 'allowDeleted' when calling index24");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling index24");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarQueryParams.addAll(apiClient.parameterToPair("allowDeleted", allowDeleted));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param revision Get latest revision by default (optional)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object index3(String namespace, String id, Boolean source, Boolean allowDeleted, Integer revision) throws ApiException {
    return this.index3(namespace, id, source, allowDeleted, revision, Collections.emptyMap());
  }


  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param revision Get latest revision by default (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object index3(String namespace, String id, Boolean source, Boolean allowDeleted, Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling index3");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling index3");
    }
    
    // verify the required parameter 'source' is set
    if (source == null) {
      throw new ApiException(400, "Missing the required parameter 'source' when calling index3");
    }
    
    // verify the required parameter 'allowDeleted' is set
    if (allowDeleted == null) {
      throw new ApiException(400, "Missing the required parameter 'allowDeleted' when calling index3");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarQueryParams.addAll(apiClient.parameterToPair("allowDeleted", allowDeleted));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all distinct namespaces
   * 
   * @param q A string filter (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespace1(String q) throws ApiException {
    return this.listDistinctNamespace1(q, Collections.emptyMap());
  }


  /**
   * List all distinct namespaces
   * 
   * @param q A string filter (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespace1(String q, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/distinct-namespaces";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all distinct namespaces
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespace4(String tenant, String q) throws ApiException {
    return this.listDistinctNamespace4(tenant, q, Collections.emptyMap());
  }


  /**
   * List all distinct namespaces
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespace4(String tenant, String q, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listDistinctNamespace4");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/distinct-namespaces"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> revisions(String namespace, String id) throws ApiException {
    return this.revisions(namespace, id, Collections.emptyMap());
  }


  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> revisions(String namespace, String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling revisions");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling revisions");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}/revisions"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<FlowWithSource>> localVarReturnType = new TypeReference<List<FlowWithSource>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> revisions1(String namespace, String id, String tenant) throws ApiException {
    return this.revisions1(namespace, id, tenant, Collections.emptyMap());
  }


  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> revisions1(String namespace, String id, String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling revisions1");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling revisions1");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling revisions1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/revisions"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<FlowWithSource>> localVarReturnType = new TypeReference<List<FlowWithSource>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow source(Integer page, Integer size, List<String> sort, String q, String namespace) throws ApiException {
    return this.source(page, size, sort, q, namespace, Collections.emptyMap());
  }


  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow source(Integer page, Integer size, List<String> sort, String q, String namespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling source");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling source");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/source";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<PagedResultsSearchResultFlow> localVarReturnType = new TypeReference<PagedResultsSearchResultFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow source1(Integer page, Integer size, String tenant, List<String> sort, String q, String namespace) throws ApiException {
    return this.source1(page, size, tenant, sort, q, namespace, Collections.emptyMap());
  }


  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow source1(Integer page, Integer size, String tenant, List<String> sort, String q, String namespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling source1");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling source1");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling source1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/source"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<PagedResultsSearchResultFlow> localVarReturnType = new TypeReference<PagedResultsSearchResultFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a flow
   * 
   * @param tenant  (required)
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param body  (required)
   * @return Update3200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Update3200Response update21(String tenant, String namespace, String id, String body) throws ApiException {
    return this.update21(tenant, namespace, id, body, Collections.emptyMap());
  }


  /**
   * Update a flow
   * 
   * @param tenant  (required)
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Update3200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Update3200Response update21(String tenant, String namespace, String id, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling update21");
    }
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling update21");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling update21");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling update21");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)))
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Update3200Response> localVarReturnType = new TypeReference<Update3200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param body  (required)
   * @return Update3200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Update3200Response update3(String namespace, String id, String body) throws ApiException {
    return this.update3(namespace, id, body, Collections.emptyMap());
  }


  /**
   * Update a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Update3200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Update3200Response update3(String namespace, String id, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling update3");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling update3");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling update3");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Update3200Response> localVarReturnType = new TypeReference<Update3200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a complete namespace from json object
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param namespace The flow namespace (required)
   * @param delete If missing flow should be deleted (required)
   * @param flow  (required)
   * @return UpdateNamespace200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateNamespace200Response updateNamespace(String namespace, Boolean delete, List<Flow> flow) throws ApiException {
    return this.updateNamespace(namespace, delete, flow, Collections.emptyMap());
  }


  /**
   * Update a complete namespace from json object
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param namespace The flow namespace (required)
   * @param delete If missing flow should be deleted (required)
   * @param flow  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return UpdateNamespace200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateNamespace200Response updateNamespace(String namespace, Boolean delete, List<Flow> flow, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = flow;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateNamespace");
    }
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling updateNamespace");
    }
    
    // verify the required parameter 'flow' is set
    if (flow == null) {
      throw new ApiException(400, "Missing the required parameter 'flow' when calling updateNamespace");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json", "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<UpdateNamespace200Response> localVarReturnType = new TypeReference<UpdateNamespace200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a complete namespace from json object
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param tenant  (required)
   * @param namespace The flow namespace (required)
   * @param delete If missing flow should be deleted (required)
   * @param flow  (required)
   * @return UpdateNamespace200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateNamespace200Response updateNamespace2(String tenant, String namespace, Boolean delete, List<Flow> flow) throws ApiException {
    return this.updateNamespace2(tenant, namespace, delete, flow, Collections.emptyMap());
  }


  /**
   * Update a complete namespace from json object
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param tenant  (required)
   * @param namespace The flow namespace (required)
   * @param delete If missing flow should be deleted (required)
   * @param flow  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return UpdateNamespace200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateNamespace200Response updateNamespace2(String tenant, String namespace, Boolean delete, List<Flow> flow, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = flow;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateNamespace2");
    }
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateNamespace2");
    }
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling updateNamespace2");
    }
    
    // verify the required parameter 'flow' is set
    if (flow == null) {
      throw new ApiException(400, "Missing the required parameter 'flow' when calling updateNamespace2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)))
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json", "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<UpdateNamespace200Response> localVarReturnType = new TypeReference<UpdateNamespace200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param task  (required)
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask(String namespace, String id, String taskId, Task task) throws ApiException {
    return this.updateTask(namespace, id, taskId, task, Collections.emptyMap());
  }


  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param task  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask(String namespace, String id, String taskId, Task task, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = task;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateTask");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateTask");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling updateTask");
    }
    
    // verify the required parameter 'task' is set
    if (task == null) {
      throw new ApiException(400, "Missing the required parameter 'task' when calling updateTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/{namespace}/{id}/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Flow> localVarReturnType = new TypeReference<Flow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param task  (required)
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask1(String namespace, String id, String taskId, String tenant, Task task) throws ApiException {
    return this.updateTask1(namespace, id, taskId, tenant, task, Collections.emptyMap());
  }


  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param task  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask1(String namespace, String id, String taskId, String tenant, Task task, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = task;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateTask1");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateTask1");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling updateTask1");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateTask1");
    }
    
    // verify the required parameter 'task' is set
    if (task == null) {
      throw new ApiException(400, "Missing the required parameter 'task' when calling updateTask1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<Flow> localVarReturnType = new TypeReference<Flow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate a list of flows
   * 
   * @param body  (required)
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows(String body) throws ApiException {
    return this.validateFlows(body, Collections.emptyMap());
  }


  /**
   * Validate a list of flows
   * 
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows(String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/validate";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<ValidateConstraintViolation>> localVarReturnType = new TypeReference<List<ValidateConstraintViolation>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param body  (required)
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows1(String tenant, String body) throws ApiException {
    return this.validateFlows1(tenant, body, Collections.emptyMap());
  }


  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows1(String tenant, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateFlows1");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateFlows1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<ValidateConstraintViolation>> localVarReturnType = new TypeReference<List<ValidateConstraintViolation>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate a list of flows
   * 
   * @param section Type of task (required)
   * @param body  (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask(FlowControllerTaskValidationType section, String body) throws ApiException {
    return this.validateTask(section, body, Collections.emptyMap());
  }


  /**
   * Validate a list of flows
   * 
   * @param section Type of task (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask(FlowControllerTaskValidationType section, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'section' is set
    if (section == null) {
      throw new ApiException(400, "Missing the required parameter 'section' when calling validateTask");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/validate/task";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("section", section));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml", "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param section Type of task (required)
   * @param body  (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask1(String tenant, FlowControllerTaskValidationType section, String body) throws ApiException {
    return this.validateTask1(tenant, section, body, Collections.emptyMap());
  }


  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param section Type of task (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask1(String tenant, FlowControllerTaskValidationType section, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateTask1");
    }
    
    // verify the required parameter 'section' is set
    if (section == null) {
      throw new ApiException(400, "Missing the required parameter 'section' when calling validateTask1");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTask1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate/task"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("section", section));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml", "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate trigger
   * 
   * @param body  (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger(String body) throws ApiException {
    return this.validateTrigger(body, Collections.emptyMap());
  }


  /**
   * Validate trigger
   * 
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger(String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTrigger");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/flows/validate/trigger";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate trigger
   * 
   * @param tenant  (required)
   * @param body  (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger1(String tenant, String body) throws ApiException {
    return this.validateTrigger1(tenant, body, Collections.emptyMap());
  }


  /**
   * Validate trigger
   * 
   * @param tenant  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger1(String tenant, String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateTrigger1");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTrigger1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate/trigger"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }
}
