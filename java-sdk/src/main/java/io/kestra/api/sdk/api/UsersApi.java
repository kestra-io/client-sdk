/*
 * Kestra EE
 * All API operations allow an optional tenant identifier in the HTTP path, if you don't use multi-tenancy you must omit the tenant identifier.<br/> This means that, for example, when trying to access the Flows API, instead of using <code>/api/v1/{tenant}/flows</code> you must use <code>/api/v1/flows</code>.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.kestra.api.sdk.api;

import com.fasterxml.jackson.core.type.TypeReference;

import io.kestra.api.sdk.internal.ApiException;
import io.kestra.api.sdk.internal.ApiClient;
import io.kestra.api.sdk.internal.BaseApi;
import io.kestra.api.sdk.internal.Configuration;
import io.kestra.api.sdk.internal.Pair;

import io.kestra.api.sdk.model.AbstractUserControllerPasswordRequest;
import io.kestra.api.sdk.model.AbstractUserControllerUserApiAutocomplete;
import io.kestra.api.sdk.model.ApiServiceAccount;
import io.kestra.api.sdk.model.ApiUser;
import io.kestra.api.sdk.model.CreateApiTokenRequest;
import io.kestra.api.sdk.model.MeControllerUpdatePasswordRequest;
import io.kestra.api.sdk.model.PagedResultsApiUser;
import io.kestra.api.sdk.model.UserType;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-06-05T07:35:23.657005690Z[Etc/UTC]", comments = "Generator version: 7.14.0-SNAPSHOT")
public class UsersApi extends BaseApi {

  public UsersApi() {
    super(Configuration.getDefaultApiClient());
  }

  public UsersApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * List users for autocomplete
   * 
   * @param tenant  (required)
   * @param abstractUserControllerUserApiAutocomplete Autocomplete request (required)
   * @return List&lt;ApiUser&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ApiUser> autocompleteUsers(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull AbstractUserControllerUserApiAutocomplete abstractUserControllerUserApiAutocomplete) throws ApiException {
    return this.autocompleteUsers(tenant, abstractUserControllerUserApiAutocomplete, Collections.emptyMap());
  }


  /**
   * List users for autocomplete
   * 
   * @param tenant  (required)
   * @param abstractUserControllerUserApiAutocomplete Autocomplete request (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ApiUser&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ApiUser> autocompleteUsers(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull AbstractUserControllerUserApiAutocomplete abstractUserControllerUserApiAutocomplete, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = abstractUserControllerUserApiAutocomplete;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling autocompleteUsers");
    }
    
    // verify the required parameter 'abstractUserControllerUserApiAutocomplete' is set
    if (abstractUserControllerUserApiAutocomplete == null) {
      throw new ApiException(400, "Missing the required parameter 'abstractUserControllerUserApiAutocomplete' when calling autocompleteUsers");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/autocomplete"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<ApiUser>> localVarReturnType = new TypeReference<List<ApiUser>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List users for autocomplete
   * 
   * @param resourceTenant  (required)
   * @param abstractUserControllerUserApiAutocomplete Autocomplete request (required)
   * @return List&lt;ApiUser&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ApiUser> autocompleteUsersWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull AbstractUserControllerUserApiAutocomplete abstractUserControllerUserApiAutocomplete) throws ApiException {
    return this.autocompleteUsersWithResourceTenantasSuperAdmin(resourceTenant, abstractUserControllerUserApiAutocomplete, Collections.emptyMap());
  }


  /**
   * List users for autocomplete
   * 
   * @param resourceTenant  (required)
   * @param abstractUserControllerUserApiAutocomplete Autocomplete request (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ApiUser&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ApiUser> autocompleteUsersWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull AbstractUserControllerUserApiAutocomplete abstractUserControllerUserApiAutocomplete, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = abstractUserControllerUserApiAutocomplete;
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling autocompleteUsersWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'abstractUserControllerUserApiAutocomplete' is set
    if (abstractUserControllerUserApiAutocomplete == null) {
      throw new ApiException(400, "Missing the required parameter 'abstractUserControllerUserApiAutocomplete' when calling autocompleteUsersWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/autocomplete"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<ApiUser>> localVarReturnType = new TypeReference<List<ApiUser>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List users for autocomplete
   * 
   * @param abstractUserControllerUserApiAutocomplete Autocomplete request (required)
   * @return List&lt;ApiUser&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ApiUser> autocompleteUsersasSuperAdmin(@javax.annotation.Nonnull AbstractUserControllerUserApiAutocomplete abstractUserControllerUserApiAutocomplete) throws ApiException {
    return this.autocompleteUsersasSuperAdmin(abstractUserControllerUserApiAutocomplete, Collections.emptyMap());
  }


  /**
   * List users for autocomplete
   * 
   * @param abstractUserControllerUserApiAutocomplete Autocomplete request (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ApiUser&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ApiUser> autocompleteUsersasSuperAdmin(@javax.annotation.Nonnull AbstractUserControllerUserApiAutocomplete abstractUserControllerUserApiAutocomplete, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = abstractUserControllerUserApiAutocomplete;
    
    // verify the required parameter 'abstractUserControllerUserApiAutocomplete' is set
    if (abstractUserControllerUserApiAutocomplete == null) {
      throw new ApiException(400, "Missing the required parameter 'abstractUserControllerUserApiAutocomplete' when calling autocompleteUsersasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/autocomplete";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<ApiUser>> localVarReturnType = new TypeReference<List<ApiUser>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create new API Token for a specific user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param createApiTokenRequest The create api-token request (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object createApiTokensForUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull CreateApiTokenRequest createApiTokenRequest) throws ApiException {
    return this.createApiTokensForUser(id, tenant, createApiTokenRequest, Collections.emptyMap());
  }


  /**
   * Create new API Token for a specific user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param createApiTokenRequest The create api-token request (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object createApiTokensForUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull CreateApiTokenRequest createApiTokenRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createApiTokenRequest;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling createApiTokensForUser");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling createApiTokensForUser");
    }
    
    // verify the required parameter 'createApiTokenRequest' is set
    if (createApiTokenRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createApiTokenRequest' when calling createApiTokensForUser");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}/api-tokens"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create new API Token for a specific user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param createApiTokenRequest The create api-token request (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object createApiTokensForUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull CreateApiTokenRequest createApiTokenRequest) throws ApiException {
    return this.createApiTokensForUserWithResourceTenantasSuperAdmin(id, resourceTenant, createApiTokenRequest, Collections.emptyMap());
  }


  /**
   * Create new API Token for a specific user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param createApiTokenRequest The create api-token request (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object createApiTokensForUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull CreateApiTokenRequest createApiTokenRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createApiTokenRequest;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling createApiTokensForUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling createApiTokensForUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'createApiTokenRequest' is set
    if (createApiTokenRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createApiTokenRequest' when calling createApiTokensForUserWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/api-tokens"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create new API Token for a specific user
   * 
   * @param id The user id (required)
   * @param createApiTokenRequest The create api-token request (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object createApiTokensForUserasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull CreateApiTokenRequest createApiTokenRequest) throws ApiException {
    return this.createApiTokensForUserasSuperAdmin(id, createApiTokenRequest, Collections.emptyMap());
  }


  /**
   * Create new API Token for a specific user
   * 
   * @param id The user id (required)
   * @param createApiTokenRequest The create api-token request (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object createApiTokensForUserasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull CreateApiTokenRequest createApiTokenRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createApiTokenRequest;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling createApiTokensForUserasSuperAdmin");
    }
    
    // verify the required parameter 'createApiTokenRequest' is set
    if (createApiTokenRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createApiTokenRequest' when calling createApiTokensForUserasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/api-tokens"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a user service account
   * 
   * @param tenant  (required)
   * @param apiServiceAccount The service account (required)
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount createServiceAccount(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount) throws ApiException {
    return this.createServiceAccount(tenant, apiServiceAccount, Collections.emptyMap());
  }


  /**
   * Create a user service account
   * 
   * @param tenant  (required)
   * @param apiServiceAccount The service account (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount createServiceAccount(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiServiceAccount;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling createServiceAccount");
    }
    
    // verify the required parameter 'apiServiceAccount' is set
    if (apiServiceAccount == null) {
      throw new ApiException(400, "Missing the required parameter 'apiServiceAccount' when calling createServiceAccount");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/service-accounts"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiServiceAccount> localVarReturnType = new TypeReference<ApiServiceAccount>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a user service account
   * 
   * @param resourceTenant  (required)
   * @param apiServiceAccount The service account (required)
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount createServiceAccountWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount) throws ApiException {
    return this.createServiceAccountWithResourceTenantasSuperAdmin(resourceTenant, apiServiceAccount, Collections.emptyMap());
  }


  /**
   * Create a user service account
   * 
   * @param resourceTenant  (required)
   * @param apiServiceAccount The service account (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount createServiceAccountWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiServiceAccount;
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling createServiceAccountWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'apiServiceAccount' is set
    if (apiServiceAccount == null) {
      throw new ApiException(400, "Missing the required parameter 'apiServiceAccount' when calling createServiceAccountWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/service-accounts"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiServiceAccount> localVarReturnType = new TypeReference<ApiServiceAccount>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a user service account
   * 
   * @param apiServiceAccount The service account (required)
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount createServiceAccountasSuperAdmin(@javax.annotation.Nonnull ApiServiceAccount apiServiceAccount) throws ApiException {
    return this.createServiceAccountasSuperAdmin(apiServiceAccount, Collections.emptyMap());
  }


  /**
   * Create a user service account
   * 
   * @param apiServiceAccount The service account (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount createServiceAccountasSuperAdmin(@javax.annotation.Nonnull ApiServiceAccount apiServiceAccount, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiServiceAccount;
    
    // verify the required parameter 'apiServiceAccount' is set
    if (apiServiceAccount == null) {
      throw new ApiException(400, "Missing the required parameter 'apiServiceAccount' when calling createServiceAccountasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/service-accounts";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiServiceAccount> localVarReturnType = new TypeReference<ApiServiceAccount>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a standard user
   * 
   * @param tenant  (required)
   * @param apiUser The user (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUser(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiUser apiUser) throws ApiException {
    return this.createUser(tenant, apiUser, Collections.emptyMap());
  }


  /**
   * Create a standard user
   * 
   * @param tenant  (required)
   * @param apiUser The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUser(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiUser apiUser, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiUser;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling createUser");
    }
    
    // verify the required parameter 'apiUser' is set
    if (apiUser == null) {
      throw new ApiException(400, "Missing the required parameter 'apiUser' when calling createUser");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a basic auth password for a standard user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param abstractUserControllerPasswordRequest The password (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserBasicAuth(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull AbstractUserControllerPasswordRequest abstractUserControllerPasswordRequest) throws ApiException {
    return this.createUserBasicAuth(id, tenant, abstractUserControllerPasswordRequest, Collections.emptyMap());
  }


  /**
   * Create a basic auth password for a standard user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param abstractUserControllerPasswordRequest The password (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserBasicAuth(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull AbstractUserControllerPasswordRequest abstractUserControllerPasswordRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = abstractUserControllerPasswordRequest;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling createUserBasicAuth");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling createUserBasicAuth");
    }
    
    // verify the required parameter 'abstractUserControllerPasswordRequest' is set
    if (abstractUserControllerPasswordRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'abstractUserControllerPasswordRequest' when calling createUserBasicAuth");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}/password"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a basic auth password for a standard user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param abstractUserControllerPasswordRequest The password (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserBasicAuthWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull AbstractUserControllerPasswordRequest abstractUserControllerPasswordRequest) throws ApiException {
    return this.createUserBasicAuthWithResourceTenantasSuperAdmin(id, resourceTenant, abstractUserControllerPasswordRequest, Collections.emptyMap());
  }


  /**
   * Create a basic auth password for a standard user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param abstractUserControllerPasswordRequest The password (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserBasicAuthWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull AbstractUserControllerPasswordRequest abstractUserControllerPasswordRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = abstractUserControllerPasswordRequest;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling createUserBasicAuthWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling createUserBasicAuthWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'abstractUserControllerPasswordRequest' is set
    if (abstractUserControllerPasswordRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'abstractUserControllerPasswordRequest' when calling createUserBasicAuthWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/password"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a basic auth password for a standard user
   * 
   * @param id The user id (required)
   * @param abstractUserControllerPasswordRequest The password (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserBasicAuthasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull AbstractUserControllerPasswordRequest abstractUserControllerPasswordRequest) throws ApiException {
    return this.createUserBasicAuthasSuperAdmin(id, abstractUserControllerPasswordRequest, Collections.emptyMap());
  }


  /**
   * Create a basic auth password for a standard user
   * 
   * @param id The user id (required)
   * @param abstractUserControllerPasswordRequest The password (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserBasicAuthasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull AbstractUserControllerPasswordRequest abstractUserControllerPasswordRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = abstractUserControllerPasswordRequest;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling createUserBasicAuthasSuperAdmin");
    }
    
    // verify the required parameter 'abstractUserControllerPasswordRequest' is set
    if (abstractUserControllerPasswordRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'abstractUserControllerPasswordRequest' when calling createUserBasicAuthasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/password"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a standard user
   * 
   * @param resourceTenant  (required)
   * @param apiUser The user (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiUser apiUser) throws ApiException {
    return this.createUserWithResourceTenantasSuperAdmin(resourceTenant, apiUser, Collections.emptyMap());
  }


  /**
   * Create a standard user
   * 
   * @param resourceTenant  (required)
   * @param apiUser The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiUser apiUser, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiUser;
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling createUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'apiUser' is set
    if (apiUser == null) {
      throw new ApiException(400, "Missing the required parameter 'apiUser' when calling createUserWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a standard user
   * 
   * @param apiUser The user (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserasSuperAdmin(@javax.annotation.Nonnull ApiUser apiUser) throws ApiException {
    return this.createUserasSuperAdmin(apiUser, Collections.emptyMap());
  }


  /**
   * Create a standard user
   * 
   * @param apiUser The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser createUserasSuperAdmin(@javax.annotation.Nonnull ApiUser apiUser, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiUser;
    
    // verify the required parameter 'apiUser' is set
    if (apiUser == null) {
      throw new ApiException(400, "Missing the required parameter 'apiUser' when calling createUserasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an API Token for specific user and token id
   * 
   * @param id The user id (required)
   * @param tokenId The token id (required)
   * @param tenant  (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object deleteApiToken(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tokenId, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.deleteApiToken(id, tokenId, tenant, Collections.emptyMap());
  }


  /**
   * Delete an API Token for specific user and token id
   * 
   * @param id The user id (required)
   * @param tokenId The token id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object deleteApiToken(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tokenId, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteApiToken");
    }
    
    // verify the required parameter 'tokenId' is set
    if (tokenId == null) {
      throw new ApiException(400, "Missing the required parameter 'tokenId' when calling deleteApiToken");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteApiToken");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}/api-tokens/{tokenId}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tokenId" + "\\}", apiClient.escapeString(apiClient.parameterToString(tokenId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an API Token for specific user and token id
   * 
   * @param id The user id (required)
   * @param tokenId The token id (required)
   * @param resourceTenant  (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object deleteApiTokenWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tokenId, @javax.annotation.Nonnull String resourceTenant) throws ApiException {
    return this.deleteApiTokenWithResourceTenantasSuperAdmin(id, tokenId, resourceTenant, Collections.emptyMap());
  }


  /**
   * Delete an API Token for specific user and token id
   * 
   * @param id The user id (required)
   * @param tokenId The token id (required)
   * @param resourceTenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object deleteApiTokenWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tokenId, @javax.annotation.Nonnull String resourceTenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteApiTokenWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'tokenId' is set
    if (tokenId == null) {
      throw new ApiException(400, "Missing the required parameter 'tokenId' when calling deleteApiTokenWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling deleteApiTokenWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/api-tokens/{tokenId}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tokenId" + "\\}", apiClient.escapeString(apiClient.parameterToString(tokenId)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an API Token for specific user and token id
   * 
   * @param id The user id (required)
   * @param tokenId The token id (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object deleteApiTokenasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tokenId) throws ApiException {
    return this.deleteApiTokenasSuperAdmin(id, tokenId, Collections.emptyMap());
  }


  /**
   * Delete an API Token for specific user and token id
   * 
   * @param id The user id (required)
   * @param tokenId The token id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object deleteApiTokenasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tokenId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteApiTokenasSuperAdmin");
    }
    
    // verify the required parameter 'tokenId' is set
    if (tokenId == null) {
      throw new ApiException(400, "Missing the required parameter 'tokenId' when calling deleteApiTokenasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/api-tokens/{tokenId}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tokenId" + "\\}", apiClient.escapeString(apiClient.parameterToString(tokenId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an Auth for a user
   * 
   * @param id The user id (required)
   * @param uid The auth id (required)
   * @param tenant  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteAuth(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String uid, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.deleteAuth(id, uid, tenant, Collections.emptyMap());
  }


  /**
   * Delete an Auth for a user
   * 
   * @param id The user id (required)
   * @param uid The auth id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteAuth(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String uid, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteAuth");
    }
    
    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(400, "Missing the required parameter 'uid' when calling deleteAuth");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteAuth");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}/auths/{uid}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "uid" + "\\}", apiClient.escapeString(apiClient.parameterToString(uid)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an Auth for a user
   * 
   * @param id The user id (required)
   * @param uid The auth id (required)
   * @param resourceTenant  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteAuthWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String uid, @javax.annotation.Nonnull String resourceTenant) throws ApiException {
    return this.deleteAuthWithResourceTenantasSuperAdmin(id, uid, resourceTenant, Collections.emptyMap());
  }


  /**
   * Delete an Auth for a user
   * 
   * @param id The user id (required)
   * @param uid The auth id (required)
   * @param resourceTenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteAuthWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String uid, @javax.annotation.Nonnull String resourceTenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteAuthWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(400, "Missing the required parameter 'uid' when calling deleteAuthWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling deleteAuthWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/auths/{uid}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "uid" + "\\}", apiClient.escapeString(apiClient.parameterToString(uid)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an Auth for a user
   * 
   * @param id The user id (required)
   * @param uid The auth id (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteAuthasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String uid) throws ApiException {
    return this.deleteAuthasSuperAdmin(id, uid, Collections.emptyMap());
  }


  /**
   * Delete an Auth for a user
   * 
   * @param id The user id (required)
   * @param uid The auth id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteAuthasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String uid, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteAuthasSuperAdmin");
    }
    
    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(400, "Missing the required parameter 'uid' when calling deleteAuthasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/auths/{uid}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "uid" + "\\}", apiClient.escapeString(apiClient.parameterToString(uid)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a user refresh token
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteRefreshToken(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.deleteRefreshToken(id, tenant, Collections.emptyMap());
  }


  /**
   * Delete a user refresh token
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteRefreshToken(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteRefreshToken");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteRefreshToken");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}/refresh-token"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a user refresh token
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteRefreshTokenWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant) throws ApiException {
    return this.deleteRefreshTokenWithResourceTenantasSuperAdmin(id, resourceTenant, Collections.emptyMap());
  }


  /**
   * Delete a user refresh token
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteRefreshTokenWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteRefreshTokenWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling deleteRefreshTokenWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/refresh-token"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a user refresh token
   * 
   * @param id The user id (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteRefreshTokenasSuperAdmin(@javax.annotation.Nonnull String id) throws ApiException {
    return this.deleteRefreshTokenasSuperAdmin(id, Collections.emptyMap());
  }


  /**
   * Delete a user refresh token
   * 
   * @param id The user id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser deleteRefreshTokenasSuperAdmin(@javax.annotation.Nonnull String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteRefreshTokenasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/refresh-token"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant) throws ApiException {
    this.deleteUser(id, tenant, Collections.emptyMap());
  }


  /**
   * Delete a user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void deleteUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteUser");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteUser");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }

  /**
   * Delete a user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant) throws ApiException {
    this.deleteUserWithResourceTenantasSuperAdmin(id, resourceTenant, Collections.emptyMap());
  }


  /**
   * Delete a user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void deleteUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling deleteUserWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }

  /**
   * Delete a user
   * 
   * @param id The user id (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteUserasSuperAdmin(@javax.annotation.Nonnull String id) throws ApiException {
    this.deleteUserasSuperAdmin(id, Collections.emptyMap());
  }


  /**
   * Delete a user
   * 
   * @param id The user id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void deleteUserasSuperAdmin(@javax.annotation.Nonnull String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteUserasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }

  /**
   * Get all users in the instance across all tenantd
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param q A string filter (optional)
   * @param type The type of user (optional)
   * @param sort The sort of current page (optional)
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser findAllForAllTenants(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nullable String q, @javax.annotation.Nullable UserType type, @javax.annotation.Nullable List<String> sort) throws ApiException {
    return this.findAllForAllTenants(page, size, q, type, sort, Collections.emptyMap());
  }


  /**
   * Get all users in the instance across all tenantd
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param q A string filter (optional)
   * @param type The type of user (optional)
   * @param sort The sort of current page (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser findAllForAllTenants(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nullable String q, @javax.annotation.Nullable UserType type, @javax.annotation.Nullable List<String> sort, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling findAllForAllTenants");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling findAllForAllTenants");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/instance";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsApiUser> localVarReturnType = new TypeReference<PagedResultsApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get all users in the instance across all tenantd
   * 
   * @param page The current page (required)
   * @param resourceTenant  (required)
   * @param size The current page size (required)
   * @param q A string filter (optional)
   * @param type The type of user (optional)
   * @param sort The sort of current page (optional)
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser findAllForAllTenantsWithResourceTenant(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull Integer size, @javax.annotation.Nullable String q, @javax.annotation.Nullable UserType type, @javax.annotation.Nullable List<String> sort) throws ApiException {
    return this.findAllForAllTenantsWithResourceTenant(page, resourceTenant, size, q, type, sort, Collections.emptyMap());
  }


  /**
   * Get all users in the instance across all tenantd
   * 
   * @param page The current page (required)
   * @param resourceTenant  (required)
   * @param size The current page size (required)
   * @param q A string filter (optional)
   * @param type The type of user (optional)
   * @param sort The sort of current page (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser findAllForAllTenantsWithResourceTenant(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull Integer size, @javax.annotation.Nullable String q, @javax.annotation.Nullable UserType type, @javax.annotation.Nullable List<String> sort, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling findAllForAllTenantsWithResourceTenant");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling findAllForAllTenantsWithResourceTenant");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling findAllForAllTenantsWithResourceTenant");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/instance"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsApiUser> localVarReturnType = new TypeReference<PagedResultsApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser getUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.getUser(id, tenant, Collections.emptyMap());
  }


  /**
   * Get a user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser getUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getUser");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling getUser");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser getUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant) throws ApiException {
    return this.getUserWithResourceTenantasSuperAdmin(id, resourceTenant, Collections.emptyMap());
  }


  /**
   * Get a user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser getUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling getUserWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a user
   * 
   * @param id The user id (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser getUserasSuperAdmin(@javax.annotation.Nonnull String id) throws ApiException {
    return this.getUserasSuperAdmin(id, Collections.emptyMap());
  }


  /**
   * Get a user
   * 
   * @param id The user id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser getUserasSuperAdmin(@javax.annotation.Nonnull String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getUserasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Impersonate a user
   * 
   * @param id The user id (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object impersonate(@javax.annotation.Nonnull String id) throws ApiException {
    return this.impersonate(id, Collections.emptyMap());
  }


  /**
   * Impersonate a user
   * 
   * @param id The user id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object impersonate(@javax.annotation.Nonnull String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling impersonate");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/impersonate"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Impersonate a user
   * 
   * @param resourceTenant  (required)
   * @param id The user id (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object impersonateWithResourceTenant(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull String id) throws ApiException {
    return this.impersonateWithResourceTenant(resourceTenant, id, Collections.emptyMap());
  }


  /**
   * Impersonate a user
   * 
   * @param resourceTenant  (required)
   * @param id The user id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object impersonateWithResourceTenant(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling impersonateWithResourceTenant");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling impersonateWithResourceTenant");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/impersonate"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all API Tokens for specific user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object listApiTokens(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.listApiTokens(id, tenant, Collections.emptyMap());
  }


  /**
   * List all API Tokens for specific user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object listApiTokens(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling listApiTokens");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listApiTokens");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}/api-tokens"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all API Tokens for specific user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object listApiTokensWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant) throws ApiException {
    return this.listApiTokensWithResourceTenantasSuperAdmin(id, resourceTenant, Collections.emptyMap());
  }


  /**
   * List all API Tokens for specific user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object listApiTokensWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling listApiTokensWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling listApiTokensWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/api-tokens"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all API Tokens for specific user
   * 
   * @param id The user id (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object listApiTokensasSuperAdmin(@javax.annotation.Nonnull String id) throws ApiException {
    return this.listApiTokensasSuperAdmin(id, Collections.emptyMap());
  }


  /**
   * List all API Tokens for specific user
   * 
   * @param id The user id (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object listApiTokensasSuperAdmin(@javax.annotation.Nonnull String id, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling listApiTokensasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/api-tokens"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for users
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param sort The sort of current page (optional)
   * @param type The type of user (optional)
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser searchUsers(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable UserType type) throws ApiException {
    return this.searchUsers(page, size, tenant, q, sort, type, Collections.emptyMap());
  }


  /**
   * Search for users
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param sort The sort of current page (optional)
   * @param type The type of user (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser searchUsers(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable UserType type, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchUsers");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchUsers");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling searchUsers");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/search"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsApiUser> localVarReturnType = new TypeReference<PagedResultsApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for users
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param resourceTenant  (required)
   * @param q A string filter (optional)
   * @param sort The sort of current page (optional)
   * @param type The type of user (optional)
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser searchUsersWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable UserType type) throws ApiException {
    return this.searchUsersWithResourceTenantasSuperAdmin(page, size, resourceTenant, q, sort, type, Collections.emptyMap());
  }


  /**
   * Search for users
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param resourceTenant  (required)
   * @param q A string filter (optional)
   * @param sort The sort of current page (optional)
   * @param type The type of user (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser searchUsersWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable UserType type, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchUsersWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchUsersWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling searchUsersWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/search"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsApiUser> localVarReturnType = new TypeReference<PagedResultsApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for users
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param q A string filter (optional)
   * @param sort The sort of current page (optional)
   * @param type The type of user (optional)
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser searchUsersasSuperAdmin(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable UserType type) throws ApiException {
    return this.searchUsersasSuperAdmin(page, size, q, sort, type, Collections.emptyMap());
  }


  /**
   * Search for users
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param q A string filter (optional)
   * @param sort The sort of current page (optional)
   * @param type The type of user (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsApiUser
   * @throws ApiException if fails to make API call
   */
  public PagedResultsApiUser searchUsersasSuperAdmin(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable UserType type, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchUsersasSuperAdmin");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchUsersasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/search";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsApiUser> localVarReturnType = new TypeReference<PagedResultsApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param body  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser setSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean body) throws ApiException {
    return this.setSuperAdmin(id, body, Collections.emptyMap());
  }


  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser setSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling setSuperAdmin");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling setSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}/set-superadmin"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a user service account
   * 
   * @param resourceTenant  (required)
   * @param id The user id (required)
   * @param body  (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser setSuperAdminWithResourceTenant(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean body) throws ApiException {
    return this.setSuperAdminWithResourceTenant(resourceTenant, id, body, Collections.emptyMap());
  }


  /**
   * Update a user service account
   * 
   * @param resourceTenant  (required)
   * @param id The user id (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser setSuperAdminWithResourceTenant(@javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling setSuperAdminWithResourceTenant");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling setSuperAdminWithResourceTenant");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling setSuperAdminWithResourceTenant");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}/set-superadmin"
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update login password for the current user.
   * 
   * @param tenant  (required)
   * @param meControllerUpdatePasswordRequest  (required)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object updateCurrentUserPassword(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull MeControllerUpdatePasswordRequest meControllerUpdatePasswordRequest) throws ApiException {
    return this.updateCurrentUserPassword(tenant, meControllerUpdatePasswordRequest, Collections.emptyMap());
  }


  /**
   * Update login password for the current user.
   * 
   * @param tenant  (required)
   * @param meControllerUpdatePasswordRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object updateCurrentUserPassword(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull MeControllerUpdatePasswordRequest meControllerUpdatePasswordRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = meControllerUpdatePasswordRequest;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateCurrentUserPassword");
    }
    
    // verify the required parameter 'meControllerUpdatePasswordRequest' is set
    if (meControllerUpdatePasswordRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'meControllerUpdatePasswordRequest' when calling updateCurrentUserPassword");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/me/password"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param apiServiceAccount The user (required)
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount updateServiceAccount(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount) throws ApiException {
    return this.updateServiceAccount(id, tenant, apiServiceAccount, Collections.emptyMap());
  }


  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param apiServiceAccount The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount updateServiceAccount(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiServiceAccount;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateServiceAccount");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateServiceAccount");
    }
    
    // verify the required parameter 'apiServiceAccount' is set
    if (apiServiceAccount == null) {
      throw new ApiException(400, "Missing the required parameter 'apiServiceAccount' when calling updateServiceAccount");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/service-accounts/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiServiceAccount> localVarReturnType = new TypeReference<ApiServiceAccount>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param apiServiceAccount The user (required)
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount updateServiceAccountWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount) throws ApiException {
    return this.updateServiceAccountWithResourceTenantasSuperAdmin(id, resourceTenant, apiServiceAccount, Collections.emptyMap());
  }


  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param apiServiceAccount The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount updateServiceAccountWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiServiceAccount;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateServiceAccountWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling updateServiceAccountWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'apiServiceAccount' is set
    if (apiServiceAccount == null) {
      throw new ApiException(400, "Missing the required parameter 'apiServiceAccount' when calling updateServiceAccountWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/service-accounts/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiServiceAccount> localVarReturnType = new TypeReference<ApiServiceAccount>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param apiServiceAccount The user (required)
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount updateServiceAccountasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount) throws ApiException {
    return this.updateServiceAccountasSuperAdmin(id, apiServiceAccount, Collections.emptyMap());
  }


  /**
   * Update a user service account
   * 
   * @param id The user id (required)
   * @param apiServiceAccount The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiServiceAccount
   * @throws ApiException if fails to make API call
   */
  public ApiServiceAccount updateServiceAccountasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull ApiServiceAccount apiServiceAccount, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiServiceAccount;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateServiceAccountasSuperAdmin");
    }
    
    // verify the required parameter 'apiServiceAccount' is set
    if (apiServiceAccount == null) {
      throw new ApiException(400, "Missing the required parameter 'apiServiceAccount' when calling updateServiceAccountasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/service-accounts/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiServiceAccount> localVarReturnType = new TypeReference<ApiServiceAccount>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a standard user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param apiUser The user (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser updateUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiUser apiUser) throws ApiException {
    return this.updateUser(id, tenant, apiUser, Collections.emptyMap());
  }


  /**
   * Update a standard user
   * 
   * @param id The user id (required)
   * @param tenant  (required)
   * @param apiUser The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser updateUser(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull ApiUser apiUser, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiUser;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateUser");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateUser");
    }
    
    // verify the required parameter 'apiUser' is set
    if (apiUser == null) {
      throw new ApiException(400, "Missing the required parameter 'apiUser' when calling updateUser");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a standard user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param apiUser The user (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser updateUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiUser apiUser) throws ApiException {
    return this.updateUserWithResourceTenantasSuperAdmin(id, resourceTenant, apiUser, Collections.emptyMap());
  }


  /**
   * Update a standard user
   * 
   * @param id The user id (required)
   * @param resourceTenant  (required)
   * @param apiUser The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser updateUserWithResourceTenantasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String resourceTenant, @javax.annotation.Nonnull ApiUser apiUser, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiUser;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'resourceTenant' is set
    if (resourceTenant == null) {
      throw new ApiException(400, "Missing the required parameter 'resourceTenant' when calling updateUserWithResourceTenantasSuperAdmin");
    }
    
    // verify the required parameter 'apiUser' is set
    if (apiUser == null) {
      throw new ApiException(400, "Missing the required parameter 'apiUser' when calling updateUserWithResourceTenantasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/{resourceTenant}/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "resourceTenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(resourceTenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a standard user
   * 
   * @param id The user id (required)
   * @param apiUser The user (required)
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser updateUserasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull ApiUser apiUser) throws ApiException {
    return this.updateUserasSuperAdmin(id, apiUser, Collections.emptyMap());
  }


  /**
   * Update a standard user
   * 
   * @param id The user id (required)
   * @param apiUser The user (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ApiUser
   * @throws ApiException if fails to make API call
   */
  public ApiUser updateUserasSuperAdmin(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull ApiUser apiUser, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = apiUser;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateUserasSuperAdmin");
    }
    
    // verify the required parameter 'apiUser' is set
    if (apiUser == null) {
      throw new ApiException(400, "Missing the required parameter 'apiUser' when calling updateUserasSuperAdmin");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/tenants/users/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ApiUser> localVarReturnType = new TypeReference<ApiUser>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }
}
