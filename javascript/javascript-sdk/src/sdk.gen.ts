// This file is auto-generated by @hey-api/openapi-ts

import { buildClientParams, type Client, formDataBodySerializer, type Options as Options2, type TDataShape } from './client';
import { client } from './client.gen';
import type { AcceptInvitationResponses, ActiveServicesResponses, AddUserToGroupErrors, AddUserToGroupResponses, AggregateMetricsFromFlowResponses, AggregateMetricsFromTaskResponses, AllInputTypesResponses, AllResourceTypesResponses, AllSchemasResponses, ApiAutocomplete, ApiIds, ApiPatchSuperAdminRequest, ApiSecretMetaEe, ApiSecretValue, AppResponses, AppsCatalogConfigResponses, AppsControllerApiBulkOperationRequest, AuditLogControllerFindRequest, AuthControllerInvitationUserRequest, AuthControllerResetPasswordRequest, AutocompleteGroupsResponses, AutocompleteNamespacesResponses, AutocompleteRolesResponses, AutocompleteUsersResponses, Banner, BasicAuthConfigErrorsResponses, BasicAuthCredentials, BindingResponses, BindingType, BlueprintControllerApiBlueprintItemWithSource, BlueprintControllerKind, BlueprintGraphResponses, BlueprintResponses, BlueprintSourceResponses, BulkCreateBindingResponses, BulkDeleteAppsResponses, BulkDisableAppsResponses, BulkEnableAppsResponses, BulkExportAppsResponses, BulkImportAppsResponses, BulkUpdateFlowsResponses, ChartFiltersOverrides, ConcurrencyLimit, ConfigurationResponses, CreateApiTokenForCurrentUserResponses, CreateApiTokenRequest, CreateApiTokensForServiceAccountResponses, CreateApiTokensForServiceAccountWithTenantResponses, CreateApiTokensForUserErrors, CreateApiTokensForUserResponses, CreateAppResponses, CreateBannerResponses, CreateBasicAuthResponses, CreateBindingResponses, CreateDashboardResponses, CreateExecutionErrors, CreateExecutionResponses, CreateFlowResponses, CreateFromInvitationResponses, CreateGroupErrors, CreateGroupResponses, CreateInternalBlueprintsResponses, CreateInvitationErrors, CreateInvitationResponses, CreateNamespaceDirectoryResponses, CreateNamespaceFileResponses, CreateNamespaceResponses, CreateResponses, CreateRoleErrors, CreateRoleResponses, CreateScimResourceByIdGroupsErrors, CreateScimResourceByIdGroupsResponses, CreateScimResourceByIdUsersErrors, CreateScimResourceByIdUsersResponses, CreateSecurityIntegrationRequest, CreateSecurityIntegrationResponses, CreateServiceAccountForTenantErrors, CreateServiceAccountForTenantResponses, CreateServiceAccountResponses, CreateTenantAccess1Errors, CreateTenantAccess1Responses, CreateTenantAccessErrors, CreateTenantAccessResponses, CreateTestSuiteResponses, CreateUserErrors, CreateUserResponses, CreateWorkerGroupResponses, CrudEventType, CurrentUserResponses, DashboardChartDataResponses, DashboardControllerPreviewRequest, DashboardResponses, DeleteApiTokenForCurrentUserResponses, DeleteApiTokenForServiceAccountResponses, DeleteApiTokenForServiceAccountWithTenantResponses, DeleteApiTokenForUserErrors, DeleteApiTokenForUserResponses, DeleteAppResponses, DeleteAppsCatalogLogoResponses, DeleteBackfillByIdsResponses, DeleteBackfillByQueryResponses, DeleteBackfillResponses, DeleteBannerResponses, DeleteBindingResponses, DeleteDashboardResponses, DeleteExecutionResponses, DeleteExecutionsByIdsErrors, DeleteExecutionsByIdsResponses, DeleteExecutionsByQueryResponses, DeleteFileDirectoryResponses, DeleteFlowResponses, DeleteFlowsByIdsResponses, DeleteFlowsByQueryResponses, DeleteGroupErrors, DeleteGroupResponses, DeleteGroupsErrors, DeleteGroupsResponses, DeleteInternalBlueprintsResponses, DeleteInvitationErrors, DeleteInvitationResponses, DeleteKeyValueResponses, DeleteKeyValuesResponses, DeleteLogsFromExecutionResponses, DeleteLogsFromFlowResponses, DeleteNamespaceResponses, DeleteRefreshTokenErrors, DeleteRefreshTokenResponses, DeleteResponses, DeleteRoleResponses, DeleteSecretResponses, DeleteSecurityIntegrationResponses, DeleteServiceAccountErrors, DeleteServiceAccountForTenantErrors, DeleteServiceAccountForTenantResponses, DeleteServiceAccountResponses, DeleteTenantAccessErrors, DeleteTenantAccessResponses, DeleteTestSuiteResponses, DeleteTestSuitesByIdsResponses, DeleteUserAuthMethodErrors, DeleteUserAuthMethodResponses, DeleteUserErrors, DeleteUserFromGroupErrors, DeleteUserFromGroupResponses, DeleteUserResponses, DeleteUsersErrors, DeleteUsersResponses, DeleteWorkerGroupByIdResponses, DisableAppResponses, DisabledTriggersByIdsResponses, DisabledTriggersByQueryResponses, DisableFlowsByIdsResponses, DisableFlowsByQueryResponses, DisableSecurityIntegrationResponses, DisableTestSuitesByIdsResponses, DispatchAppResponses, DownloadFileFromAppExecutionResponses, DownloadFileFromExecutionResponses, DownloadLogsFromExecutionResponses, EnableAppResponses, EnableFlowsByIdsResponses, EnableFlowsByQueryResponses, EnableSecurityIntegrationResponses, EnableTestSuitesByIdsResponses, EnterMaintenanceResponses, ExecutionControllerSetLabelsByIdsRequest, ExecutionFlowGraphResponses, ExecutionKind, ExecutionRepositoryInterfaceFlowFilter, ExecutionResponses, ExitMaintenanceResponses, ExportAuditLogsForAllTenantsResponses, ExportAuditLogsResponses, ExportChartToCsvResponses, ExportDashboardChartDataToCsvResponses, ExportFlowsByIdsResponses, ExportFlowsByQueryResponses, ExportNamespaceFilesResponses, FileContentResponses, FileMetadatasFromExecutionResponses, FileMetadatasResponses, FileMetaFromAppExecutionResponses, FilePreviewFromAppExecutionResponses, FindAllInvitationsForCurrentUserResponses, FindAuditLogResponses, FindGroupsErrors, FindGroupsResponses, FindResponses, FindUsersErrors, FindUsersResponses, FlowControllerTaskValidationType, FlowDependenciesFromNamespaceResponses, FlowDependenciesFromTenantResponses, FlowDependenciesResponses, FlowFromExecutionByIdResponses, FlowFromExecutionResponses, FlowGenerationPrompt, FlowResponses, FollowDependenciesExecutionsResponses, FollowExecutionResponses, FollowLogsFromExecutionResponses, ForceRunByIdsErrors, ForceRunByIdsResponses, ForceRunExecutionResponses, ForceRunExecutionsByQueryResponses, ForgottenPasswordResponses, GenerateFlowGraphFromSourceResponses, GenerateFlowGraphResponses, GenerateFlowResponses, GenerateResponses, GetResponses, GlobalResourceDiffFromAuditLogResponses, GroupErrors, GroupIdentifierMembership, GroupResponses, HttpParameters, IamBindingControllerApiCreateBindingRequest, IamGroupControllerApiCreateGroupRequest, IamGroupControllerApiUpdateGroupRequest, IamInvitationControllerApiInvitationCreateRequest, IamRoleControllerApiRoleCreateOrUpdateRequest, IamServiceAccountControllerApiCreateServiceAccountRequest, IamServiceAccountControllerApiPatchServiceAccountRequest, IamServiceAccountControllerApiServiceAccountRequest, IamTenantAccessControllerApiCreateTenantAccessRequest, IamTenantAccessControllerUserApiAutocomplete, IamUserControllerApiCreateOrUpdateUserRequest, IamUserControllerApiPatchRestrictedRequest, IamUserControllerApiPatchUserPasswordRequest, IamUserGroupControllerApiUpdateUserGroupsRequest, IdWithNamespace, ImpersonateErrors, ImpersonateResponses, ImportFlowsResponses, IndexResponses, InheritedPluginDefaultsResponses, InheritedSecretsResponses, InheritedVariablesResponses, InstallVersionedPluginsResponses, InstanceControllerApiCreateOrUpdateWorkerGroupRequest, InstanceControllerApiPluginListRequest, InternalBlueprintFlowResponses, InternalBlueprintResponses, InternalBlueprintTagsResponses, InvitationErrors, InvitationInvitationStatus, InvitationResponses, KeyValueResponses, KillExecutionErrors, KillExecutionResponses, KillExecutionsByIdsErrors, KillExecutionsByIdsResponses, KillExecutionsByQueryResponses, KvControllerApiDeleteBulkRequest, Label, LatestExecutionsResponses, Level, LicenseInfoResponses, ListActionsResponses, ListAllKeysResponses, ListApiTokensForCurrentUserResponses, ListApiTokensForServiceAccountResponses, ListApiTokensForServiceAccountWithTenantResponses, ListApiTokensForUserErrors, ListApiTokensForUserResponses, ListAuditLogFromResourceIdResponses, ListAvailableVersionedPluginsForSecretManagerResponses, ListAvailableVersionedPluginsForStorageResponses, ListAvailableVersionedPluginsResponses, ListBlueprintTagsResponses, ListDistinctNamespacesResponses, ListFlowMetricsResponses, ListFlowRevisionsResponses, ListFlowsByNamespaceResponses, ListGroupIdsResponses, ListInvitationsByEmailResponses, ListKeysResponses, ListKeysWithInheritenceResponses, ListLogsFromExecutionResponses, ListNamespaceDirectoryFilesResponses, ListNamespaceSecretsResponses, ListPermissionsResponses, ListPluginsResponses, ListRolesFromGivenIdsResponses, ListSecretsResponses, ListSecurityIntegrationsResponses, ListServiceAccountsErrors, ListServiceAccountsResponses, ListTagsResponses, ListTaskMetricsResponses, ListTasksWithMetricsResponses, ListTenantAccessResponses, ListUsersResponses, ListVersionedPluginResponses, ListWorkerGroupsResponses, LoginResponses, LogsFromAppExecutionResponses, MainTenantFlowsResponses, MeControllerApiUpdatePasswordRequest, MeControllerApiUserDetailsRequest, MoveFileDirectoryResponses, Namespace, NamespaceResponses, OpenAppResponses, PatchCurrentUserResponses, PatchGroupsErrors, PatchGroupsResponses, PatchRequest, PatchSecretResponses, PatchServiceAccountDetailsResponses, PatchServiceAccountSuperAdminErrors, PatchServiceAccountSuperAdminResponses, PatchUserDemoErrors, PatchUserDemoResponses, PatchUserPasswordErrors, PatchUserPasswordResponses, PatchUserResponses, PatchUsersErrors, PatchUsersResponses, PatchUserSuperAdminErrors, PatchUserSuperAdminResponses, PauseBackfillByIdsResponses, PauseBackfillByQueryResponses, PauseBackfillResponses, PauseExecutionErrors, PauseExecutionResponses, PauseExecutionsByIdsErrors, PauseExecutionsByIdsResponses, PauseExecutionsByQueryResponses, PluginBySubgroupsResponses, PluginDocumentationFromVersionResponses, PluginDocumentationResponses, PluginGroupIconsResponses, PluginIconsResponses, PluginVersionsResponses, PreviewAppResponses, PreviewChartResponses, PropertiesFromTypeResponses, PutSecretsResponses, QueryFilter, QueryGroupsErrors, QueryGroupsResponses, QueryUsersErrors, QueryUsersResponses, ReplayExecutionResponses, ReplayExecutionsByIdsErrors, ReplayExecutionsByIdsResponses, ReplayExecutionsByQueryResponses, ReplayExecutionWithinputsResponses, RequestCodeResponses, ResetPasswordResponses, ResolveVersionedPluginsResponses, ResourceDiffFromAuditLogResponses, ResourceType1, ResourceTypeResponses, RestartExecutionResponses, RestartExecutionsByIdsErrors, RestartExecutionsByIdsResponses, RestartExecutionsByQueryResponses, RestartTriggerResponses, ResumeExecutionErrors, ResumeExecutionResponses, ResumeExecutionsByIdsErrors, ResumeExecutionsByIdsResponses, ResumeExecutionsByQueryResponses, RoleErrors, RoleResponses, RunTestSuiteResponses, RunTestSuitesByQueryResponses, SchemaFromInputTypeResponses, SchemaResponses, SchemasFromTypeResponses, SchemaType, ScimResource, SCimResourceByIdGroupsErrors, SCimResourceByIdGroupsResponses, SCimResourceByIdUsersErrors, SCimResourceByIdUsersResponses, ScimUser, SearchAppsFromCatalogResponses, SearchAppsResponses, SearchAuditLogsForAllTenantsResponses, SearchAuditLogsResponses, SearchBannersResponses, SearchBindingsResponses, SearchBlueprintsResponses, SearchByExecutionResponses, SearchConcurrencyLimitsResponses, SearchDashboardsResponses, SearchExecutionsByFlowIdResponses, SearchExecutionsResponses, SearchFlowsBySourceCodeResponses, SearchFlowsResponses, SearchGroupMembersResponses, SearchGroupsResponses, SearchInternalBlueprintsResponses, SearchInvitationsResponses, SearchLogsResponses, SearchNamespaceFilesResponses, SearchNamespacesResponses, SearchRequest, SearchRolesResponses, SearchServicesResponses, SearchTestSuitesResponses, SearchTestSuitesResultsResponses, SearchTriggersForFlowResponses, SearchTriggersResponses, SecurityIntegrationResponses, ServiceAccountErrors, ServiceAccountForTenantErrors, ServiceAccountForTenantResponses, ServiceAccountResponses, ServiceProviderConfigurationResponses, ServiceResponses, ServiceServiceState, ServiceType, SetAppsCatalogConfigResponses, SetAppsCatalogLogoResponses, SetKeyValueResponses, SetLabelsOnTerminatedExecutionErrors, SetLabelsOnTerminatedExecutionResponses, SetLabelsOnTerminatedExecutionsByIdsErrors, SetLabelsOnTerminatedExecutionsByIdsResponses, SetLabelsOnTerminatedExecutionsByQueryResponses, SetLogoResponses, SetupConfigurationResponses, SetupConfigurationSetupData, SetupKestraResponses, SetUserMembershipForGroupErrors, SetUserMembershipForGroupResponses, SortOrder, StateType, StreamEventsFromAppResponses, Task, TaskFromFlowResponses, Tenant, TenantAccessErrors, TenantAccessResponses, TenantControllerAppsCatalogConfigRequest, TenantUsageResponses, TestResultResponses, TestsLastResultResponses, TestSuiteControllerRunRequest, TestSuiteControllerSearchTestsLastResult, TestSuiteControllerTestSuiteBulkRequest, TestSuiteResponses, TestSuiteServiceRunByQueryRequest, Trigger, TriggerControllerSetDisabledRequest, TriggerExecutionByGetWebhookResponses, Type, UninstallVersionedPluginsResponses, UnlockTriggerResponses, UnlockTriggersByIdsResponses, UnlockTriggersByQueryResponses, UnpauseBackfillByIdsResponses, UnpauseBackfillByQueryResponses, UnpauseBackfillResponses, UnqueueExecutionResponses, UnqueueExecutionsByIdsErrors, UnqueueExecutionsByIdsResponses, UnqueueExecutionsByQueryResponses, UpdateAppResponses, UpdateBannerResponses, UpdateConcurrencyLimitResponses, UpdateCurrentUserPasswordResponses, UpdateDashboardResponses, UpdateExecutionsStatusByIdsErrors, UpdateExecutionsStatusByIdsResponses, UpdateExecutionsStatusByQueryErrors, UpdateExecutionsStatusByQueryResponses, UpdateExecutionStatusResponses, UpdateFlowResponses, UpdateFlowsInNamespaceResponses, UpdateGroupErrors, UpdateGroupResponses, UpdateGroupsErrors, UpdateGroupsResponses, UpdateInternalBlueprintsResponses, UpdateNamespaceResponses, UpdateResponses, UpdateRoleErrors, UpdateRoleResponses, UpdateServiceAccountErrors, UpdateServiceAccountResponses, UpdateTaskResponses, UpdateTestSuiteResponses, UpdateTriggerResponses, UpdateUserErrors, UpdateUserGroupsErrors, UpdateUserGroupsResponses, UpdateUserResponses, UpdateUsersErrors, UpdateUsersResponses, UpdateWorkerGroupByIdResponses, UploadVersionedPluginsResponses, UsagesResponses, UserErrors, UsernamePasswordCredentials, UserResponses, UserType, ValidateChartResponses, ValidateDashboardResponses, ValidateFlowsResponses, ValidateTaskResponses, ValidateTestSuiteResponses, ValidateTriggerResponses, VersionedPluginDetailsFromVersionResponses, VersionedPluginDetailsResponses, WorkerGroupByIdResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

export class AuditLogs {
    /**
     * Export all audit logs as a streamed CSV file
     */
    public static exportAuditLogsForAllTenants<ThrowOnError extends boolean = false>(parameters?: {
        q?: string | null;
        namespace?: string | null;
        flowId?: string | null;
        executionId?: string | null;
        userId?: string | null;
        id?: string | null;
        resources?: Array<ResourceType1> | null;
        startDate?: string | null;
        endDate?: string | null;
        details?: {
            [key: string]: string;
        } | null;
        type?: CrudEventType | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' },
                    { in: 'query', key: 'executionId' },
                    { in: 'query', key: 'userId' },
                    { in: 'query', key: 'id' },
                    { in: 'query', key: 'resources' },
                    { in: 'query', key: 'startDate' },
                    { in: 'query', key: 'endDate' },
                    { in: 'query', key: 'details' },
                    { in: 'query', key: 'type' }
                ] }]);
        return (options?.client ?? client).get<ExportAuditLogsForAllTenantsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/auditlogs/export',
            ...options,
            ...params
        });
    }
    
    /**
     * Search for audit logs across all tenants, required to be SuperAdmin
     */
    public static searchAuditLogsForAllTenants<ThrowOnError extends boolean = false>(parameters: {
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
        namespace?: string | null;
        flowId?: string | null;
        executionId?: string | null;
        userId?: string | null;
        id?: string | null;
        resources?: Array<ResourceType1> | null;
        startDate?: string | null;
        endDate?: string | null;
        details?: {
            [key: string]: string;
        } | null;
        type?: CrudEventType | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' },
                    { in: 'query', key: 'executionId' },
                    { in: 'query', key: 'userId' },
                    { in: 'query', key: 'id' },
                    { in: 'query', key: 'resources' },
                    { in: 'query', key: 'startDate' },
                    { in: 'query', key: 'endDate' },
                    { in: 'query', key: 'details' },
                    { in: 'query', key: 'type' }
                ] }]);
        return (options?.client ?? client).get<SearchAuditLogsForAllTenantsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/auditlogs/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve the diff between audit logs from global resource like users
     *
     * Retrieves the diff between the current version and a selected previous version of a given resource based on audit logs.
     */
    public static globalResourceDiffFromAuditLog<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        previousId?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'query', key: 'previousId' }] }]);
        return (options?.client ?? client).get<GlobalResourceDiffFromAuditLogResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/auditlogs/{id}/diff',
            ...options,
            ...params
        });
    }
    
    /**
     * Export all audit logs as a streamed CSV file
     */
    public static exportAuditLogs<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        namespace?: string | null;
        flowId?: string | null;
        executionId?: string | null;
        userId?: string | null;
        id?: string | null;
        resources?: Array<ResourceType1> | null;
        startDate?: string | null;
        endDate?: string | null;
        details?: {
            [key: string]: string;
        } | null;
        type?: CrudEventType | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' },
                    { in: 'query', key: 'executionId' },
                    { in: 'query', key: 'userId' },
                    { in: 'query', key: 'id' },
                    { in: 'query', key: 'resources' },
                    { in: 'query', key: 'startDate' },
                    { in: 'query', key: 'endDate' },
                    { in: 'query', key: 'details' },
                    { in: 'query', key: 'type' }
                ] }]);
        return (options?.client ?? client).get<ExportAuditLogsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/auditlogs/export',
            ...options,
            ...params
        });
    }
    
    /**
     * Find a specific audit log
     */
    public static findAuditLog<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        auditLogControllerFindRequest: AuditLogControllerFindRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'auditLogControllerFindRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<FindAuditLogResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/auditlogs/find',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Find all audit logs about a specific resource.
     */
    public static listAuditLogFromResourceId<ThrowOnError extends boolean = false>(parameters: {
        detailId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'detailId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListAuditLogFromResourceIdResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/auditlogs/history/{detailId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Search for audit logs
     */
    public static searchAuditLogs<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
        namespace?: string | null;
        flowId?: string | null;
        executionId?: string | null;
        userId?: string | null;
        id?: string | null;
        resources?: Array<ResourceType1> | null;
        startDate?: string | null;
        endDate?: string | null;
        details?: {
            [key: string]: string;
        } | null;
        type?: CrudEventType | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' },
                    { in: 'query', key: 'executionId' },
                    { in: 'query', key: 'userId' },
                    { in: 'query', key: 'id' },
                    { in: 'query', key: 'resources' },
                    { in: 'query', key: 'startDate' },
                    { in: 'query', key: 'endDate' },
                    { in: 'query', key: 'details' },
                    { in: 'query', key: 'type' }
                ] }]);
        return (options?.client ?? client).get<SearchAuditLogsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/auditlogs/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve the diff between audit logs
     *
     * Retrieves the diff between the current version and a selected previous version of a given resource based on audit logs.
     */
    public static resourceDiffFromAuditLog<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        previousId?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'previousId' }
                ] }]);
        return (options?.client ?? client).get<ResourceDiffFromAuditLogResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/auditlogs/{id}/diff',
            ...options,
            ...params
        });
    }
}

export class Auths {
    /**
     * Retrieve list of authentication methods
     */
    public static index<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<IndexResponses, unknown, ThrowOnError>({ url: '/api/v1/auths', ...options });
    }
    
    /**
     * Sends an email to reset a password.
     *
     * Sends an email to reset a password. Note that whatever the username is found or not, the response will always be 200 to avoid leaking information.
     */
    public static forgottenPassword<ThrowOnError extends boolean = false>(parameters: {
        username: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'username' }] }]);
        return (options?.client ?? client).get<ForgottenPasswordResponses, unknown, ThrowOnError>({
            url: '/api/v1/forgotten-password',
            ...options,
            ...params
        });
    }
    
    public static acceptInvitation<ThrowOnError extends boolean = false>(parameters: {
        invitationId: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'invitationId' }] }]);
        return (options?.client ?? client).post<AcceptInvitationResponses, unknown, ThrowOnError>({
            url: '/api/v1/invitation/accept/{invitationId}',
            ...options,
            ...params
        });
    }
    
    public static createFromInvitation<ThrowOnError extends boolean = false>(parameters: {
        invitationId: string;
        authControllerInvitationUserRequest: AuthControllerInvitationUserRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'invitationId' }, { key: 'authControllerInvitationUserRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateFromInvitationResponses, unknown, ThrowOnError>({
            url: '/api/v1/invitation/create/{invitationId}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get details about the authenticated user
     *
     * Requires the ME permission.
     */
    public static currentUser<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<CurrentUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me',
            ...options
        });
    }
    
    /**
     * Update authenticated user details
     *
     * Updates the authenticated user's profile information and returns the updated user.
     */
    public static patchCurrentUser<ThrowOnError extends boolean = false>(parameters: {
        meControllerApiUserDetailsRequest: MeControllerApiUserDetailsRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'meControllerApiUserDetailsRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchCurrentUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List API tokens for authenticated user
     *
     * Returns all API tokens belonging to the authenticated user.
     */
    public static listApiTokensForCurrentUser<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ListApiTokensForCurrentUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me/api-tokens',
            ...options
        });
    }
    
    /**
     * Create API token for the authenticated user
     */
    public static createApiTokenForCurrentUser<ThrowOnError extends boolean = false>(parameters: {
        createApiTokenRequest: CreateApiTokenRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'createApiTokenRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateApiTokenForCurrentUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me/api-tokens',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete API token for the authenticated user
     */
    public static deleteApiTokenForCurrentUser<ThrowOnError extends boolean = false>(parameters: {
        tokenId: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tokenId' }] }]);
        return (options?.client ?? client).delete<DeleteApiTokenForCurrentUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me/api-tokens/{tokenId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Request an authentication code for login verification
     */
    public static requestCode<ThrowOnError extends boolean = false>(parameters: {
        email: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'email' }] }]);
        return (options?.client ?? client).get<RequestCodeResponses, unknown, ThrowOnError>({
            url: '/api/v1/request-code/{email}',
            ...options,
            ...params
        });
    }
    
    /**
     * Change a password for given token.
     *
     * Change a password for given token. If password does not match password policy, use can still retry.
     */
    public static resetPassword<ThrowOnError extends boolean = false>(parameters: {
        authControllerResetPasswordRequest: AuthControllerResetPasswordRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'authControllerResetPasswordRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<ResetPasswordResponses, unknown, ThrowOnError>({
            url: '/api/v1/reset-password',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Banners {
    /**
     * Create an announcement banner
     *
     * Superadmin-only. Creates a global announcement banner visible to all tenants.
     */
    public static createBanner<ThrowOnError extends boolean = false>(parameters: {
        banner: Banner;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'banner', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateBannerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/banners',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve all announcement banners
     *
     * Superadmin-only. Returns all global announcement banners.
     */
    public static searchBanners<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<SearchBannersResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/banners/search',
            ...options
        });
    }
    
    /**
     * Delete an announcement banner
     *
     * Superadmin-only. Deletes a global announcement banner by its ID.
     */
    public static deleteBanner<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteBannerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/banners/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update an announcement banner
     *
     * Superadmin-only. Updates a global announcement banner by its ID.
     */
    public static updateBanner<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        banner: Banner;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'banner', map: 'body' }] }]);
        return (options?.client ?? client).put<UpdateBannerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/banners/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Misc {
    /**
     * Retrieve the instance configuration.
     *
     * Global endpoint available to all users.
     */
    public static basicAuthConfigErrors<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<BasicAuthConfigErrorsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/basicAuthValidationErrors',
            ...options
        });
    }
    
    /**
     * Retrieve the instance configuration.
     *
     * Global endpoint available to all users.
     */
    public static configuration<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ConfigurationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/configs',
            ...options
        });
    }
    
    /**
     * Retrieve license information
     *
     * Global endpoint, available to any authenticated user.
     */
    public static licenseInfo<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<LicenseInfoResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/license-info',
            ...options
        });
    }
    
    /**
     * Check if flows are present on the main tenant.
     */
    public static mainTenantFlows<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<MainTenantFlowsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/main-tenant-flows',
            ...options
        });
    }
    
    /**
     * Retrieve current setup configuration
     */
    public static setupConfiguration<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<SetupConfigurationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/setup',
            ...options
        });
    }
    
    /**
     * Create the first Superadmin user
     *
     * Only used during initial instance setup.
     */
    public static setupKestra<ThrowOnError extends boolean = false>(parameters: {
        setupConfigurationSetupData: SetupConfigurationSetupData;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'setupConfigurationSetupData', map: 'body' }] }]);
        return (options?.client ?? client).post<SetupKestraResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/setup',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve list of actions
     *
     * Actions are used to restrict possible operations for each permission. Each action must be one of the following: CREATE, READ, UPDATE, DELETE. Using permissions and actions together, you can control access to resources e.g. only allow a user to read a flow, but not update or delete it.
     */
    public static listActions<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListActionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/acls/actions',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve list of permissions
     *
     * Permissions are used to control access to resources within the Kestra platform. Example of permissions are: FLOW, EXECUTION, NAMESPACE, APP, TEST, etc.
     */
    public static listPermissions<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListPermissionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/acls/permissions',
            ...options,
            ...params
        });
    }
    
    /**
     * Configure basic authentication for the instance.
     *
     * Sets up basic authentication credentials.
     */
    public static createBasicAuth<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        basicAuthCredentials: BasicAuthCredentials;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'basicAuthCredentials', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateBasicAuthResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/basicAuth',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    public static generate<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        from?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'from' }] }]);
        return (options?.client ?? client).get<GenerateResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/stats/generate-reports',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve usage information for the current tenant
     */
    public static tenantUsage<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<TenantUsageResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/usages',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve instance usage information
     */
    public static usages<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<UsagesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/usages/all',
            ...options,
            ...params
        });
    }
}

export class Cluster {
    /**
     * Enter cluster maintenance mode
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static enterMaintenance<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).post<EnterMaintenanceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/maintenance/enter',
            ...options
        });
    }
    
    /**
     * Exit cluster maintenance mode
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static exitMaintenance<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).post<ExitMaintenanceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/maintenance/exit',
            ...options
        });
    }
}

export class Maintenance {
    /**
     * Enter cluster maintenance mode
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static enterMaintenance<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).post<EnterMaintenanceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/maintenance/enter',
            ...options
        });
    }
    
    /**
     * Exit cluster maintenance mode
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static exitMaintenance<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).post<ExitMaintenanceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/maintenance/exit',
            ...options
        });
    }
}

export class Services {
    /**
     * List all active services
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static activeServices<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ActiveServicesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/services/active',
            ...options
        });
    }
    
    /**
     * Search for a service (e.g. Worker, Executor, etc)
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static searchServices<ThrowOnError extends boolean = false>(parameters: {
        page: number;
        size: number;
        sort?: Array<string> | null;
        state?: Array<ServiceServiceState> | null;
        type?: Array<ServiceType> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'state' },
                    { in: 'query', key: 'type' }
                ] }]);
        return (options?.client ?? client).get<SearchServicesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/services/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve details of a specific service
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static service<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<ServiceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/services/{id}',
            ...options,
            ...params
        });
    }
}

export class Plugins {
    /**
     * List installed plugin artifacts
     *
     * Superadmin-only. Lists all currently installed plugin artifacts. Requires INFRASTRUCTURE permission.
     */
    public static listVersionedPlugin<ThrowOnError extends boolean = false>(parameters: {
        page: number;
        size: number;
        sort?: Array<string> | null;
        q?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'q' }
                ] }]);
        return (options?.client ?? client).get<ListVersionedPluginResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins',
            ...options,
            ...params
        });
    }
    
    /**
     * List available plugin artifacts
     *
     * Superadmin-only. Lists all plugin artifacts available for installation. Requires INFRASTRUCTURE permission.
     */
    public static listAvailableVersionedPlugins<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ListAvailableVersionedPluginsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/available',
            ...options
        });
    }
    
    /**
     * List available plugin artifacts for Kestra Secret Manager
     *
     * Superadmin-only. Lists all secret managers available for installation. Requires INFRASTRUCTURE permission.
     */
    public static listAvailableVersionedPluginsForSecretManager<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ListAvailableVersionedPluginsForSecretManagerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/available/secrets-managers',
            ...options
        });
    }
    
    /**
     * List available plugin artifacts for Kestra Internal Storage
     *
     * Superadmin-only. Lists all internal storages available for installation. Requires INFRASTRUCTURE permission.
     */
    public static listAvailableVersionedPluginsForStorage<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ListAvailableVersionedPluginsForStorageResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/available/storages',
            ...options
        });
    }
    
    /**
     * Install specified plugin artifacts
     *
     * Superadmin-only. Installs one or more plugin artifacts. Requires INFRASTRUCTURE permission.
     */
    public static installVersionedPlugins<ThrowOnError extends boolean = false>(parameters: {
        instanceControllerApiPluginListRequest: InstanceControllerApiPluginListRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'instanceControllerApiPluginListRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<InstallVersionedPluginsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/install',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Resolve versions for specified plugin artifacts
     *
     * Superadmin-only. Resolves compatible versions for a list of plugin artifacts. Requires INFRASTRUCTURE permission.
     */
    public static resolveVersionedPlugins<ThrowOnError extends boolean = false>(parameters: {
        instanceControllerApiPluginListRequest: InstanceControllerApiPluginListRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'instanceControllerApiPluginListRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<ResolveVersionedPluginsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/resolve',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Uninstall plugin artifacts
     *
     * Superadmin-only. Uninstalls one or more plugin artifacts. Requires INFRASTRUCTURE permission.
     */
    public static uninstallVersionedPlugins<ThrowOnError extends boolean = false>(parameters: {
        instanceControllerApiPluginListRequest: InstanceControllerApiPluginListRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'instanceControllerApiPluginListRequest', map: 'body' }] }]);
        return (options?.client ?? client).delete<UninstallVersionedPluginsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/uninstall',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Upload a plugin artifact JAR file
     *
     * Superadmin-only. Uploads a plugin JAR file for installation. Requires INFRASTRUCTURE permission.
     */
    public static uploadVersionedPlugins<ThrowOnError extends boolean = false>(parameters?: {
        file?: Blob | File;
        forceInstallOnExistingVersions?: boolean | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'body', key: 'file' }, { in: 'body', key: 'forceInstallOnExistingVersions' }] }]);
        return (options?.client ?? client).post<UploadVersionedPluginsResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/upload',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve details of a plugin artifact
     *
     * Superadmin-only. Retrieves metadata and available versions for a given plugin artifact. Requires INFRASTRUCTURE permission.
     */
    public static versionedPluginDetails<ThrowOnError extends boolean = false>(parameters: {
        groupId: string;
        artifactId: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'groupId' }, { in: 'path', key: 'artifactId' }] }]);
        return (options?.client ?? client).get<VersionedPluginDetailsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/{groupId}/{artifactId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve details of a specific plugin artifact version
     *
     * Superadmin-only. Retrieves metadata for a specific version of a plugin artifact. Requires INFRASTRUCTURE permission.
     */
    public static versionedPluginDetailsFromVersion<ThrowOnError extends boolean = false>(parameters: {
        groupId: string;
        artifactId: string;
        version: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'groupId' },
                    { in: 'path', key: 'artifactId' },
                    { in: 'path', key: 'version' }
                ] }]);
        return (options?.client ?? client).get<VersionedPluginDetailsFromVersionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/versioned-plugins/{groupId}/{artifactId}/{version}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get list of plugins
     */
    public static listPlugins<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ListPluginsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins',
            ...options
        });
    }
    
    /**
     * Get plugins group by subgroups
     */
    public static pluginBySubgroups<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<PluginBySubgroupsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/groups/subgroups',
            ...options
        });
    }
    
    /**
     * Get plugins icons
     */
    public static pluginIcons<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<PluginIconsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/icons',
            ...options
        });
    }
    
    /**
     * Get plugins icons
     */
    public static pluginGroupIcons<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<PluginGroupIconsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/icons/groups',
            ...options
        });
    }
    
    /**
     * Get all types for an inputs
     */
    public static allInputTypes<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<AllInputTypesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/inputs',
            ...options
        });
    }
    
    /**
     * Get the JSON schema for an input type
     *
     * The schema will be a [JSON Schema Draft 7](http://json-schema.org/draft-07/schema)
     */
    public static schemaFromInputType<ThrowOnError extends boolean = false>(parameters: {
        type: Type;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'type' }] }]);
        return (options?.client ?? client).get<SchemaFromInputTypeResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/inputs/{type}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get the properties part of the JSON schema for a type
     *
     * The schema will be a [JSON Schema Draft 7](http://json-schema.org/draft-07/schema)
     */
    public static propertiesFromType<ThrowOnError extends boolean = false>(parameters: {
        type: SchemaType;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'type' }] }]);
        return (options?.client ?? client).get<PropertiesFromTypeResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/properties/{type}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get the JSON schema for a type
     *
     * The schema will be a [JSON Schema Draft 7](http://json-schema.org/draft-07/schema)
     */
    public static schemasFromType<ThrowOnError extends boolean = false>(parameters: {
        type: SchemaType;
        arrayOf: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'type' }, { in: 'query', key: 'arrayOf' }] }]);
        return (options?.client ?? client).get<SchemasFromTypeResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/schemas/{type}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get plugin documentation
     */
    public static pluginDocumentation<ThrowOnError extends boolean = false>(parameters: {
        cls: string;
        all: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'cls' }, { in: 'query', key: 'all' }] }]);
        return (options?.client ?? client).get<PluginDocumentationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/{cls}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get all versions for a plugin
     */
    public static pluginVersions<ThrowOnError extends boolean = false>(parameters: {
        cls: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'cls' }] }]);
        return (options?.client ?? client).get<PluginVersionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/{cls}/versions',
            ...options,
            ...params
        });
    }
    
    /**
     * Get plugin documentation
     */
    public static pluginDocumentationFromVersion<ThrowOnError extends boolean = false>(parameters: {
        cls: string;
        version: string;
        all: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'cls' },
                    { in: 'path', key: 'version' },
                    { in: 'query', key: 'all' }
                ] }]);
        return (options?.client ?? client).get<PluginDocumentationFromVersionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/plugins/{cls}/versions/{version}',
            ...options,
            ...params
        });
    }
}

export class WorkerGroups {
    /**
     * List all worker groups
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static listWorkerGroups<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<ListWorkerGroupsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/workergroups',
            ...options
        });
    }
    
    /**
     * Create a worker group
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static createWorkerGroup<ThrowOnError extends boolean = false>(parameters: {
        instanceControllerApiCreateOrUpdateWorkerGroupRequest: InstanceControllerApiCreateOrUpdateWorkerGroupRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'instanceControllerApiCreateOrUpdateWorkerGroupRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateWorkerGroupResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/workergroups',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a worker group
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static deleteWorkerGroupById<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteWorkerGroupByIdResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/workergroups/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve details of a specific worker group
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static workerGroupById<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<WorkerGroupByIdResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/workergroups/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a worker group
     *
     * Requires a role with the INFRASTRUCTURE permission (Superadmin-only).
     */
    public static updateWorkerGroupById<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        instanceControllerApiCreateOrUpdateWorkerGroupRequest: InstanceControllerApiCreateOrUpdateWorkerGroupRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'instanceControllerApiCreateOrUpdateWorkerGroupRequest', map: 'body' }] }]);
        return (options?.client ?? client).put<UpdateWorkerGroupByIdResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/instance/workergroups/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Invitations {
    /**
     * List invitations for the authenticated user
     *
     * Returns all invitations for the authenticated user's email across all tenants.
     */
    public static findAllInvitationsForCurrentUser<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
        return (options?.client ?? client).get<FindAllInvitationsForCurrentUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me/invitations',
            ...options
        });
    }
    
    /**
     * Create an invitation
     *
     * Creates a new invitation and sends an email if the mail server is enabled.
     */
    public static createInvitation<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamInvitationControllerApiInvitationCreateRequest: IamInvitationControllerApiInvitationCreateRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamInvitationControllerApiInvitationCreateRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateInvitationResponses, CreateInvitationErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/invitations',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve all invitations for a given email
     *
     * Returns all invitations created for a given email address in the current tenant.
     */
    public static listInvitationsByEmail<ThrowOnError extends boolean = false>(parameters: {
        email: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'email' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListInvitationsByEmailResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/invitations/email/{email}',
            ...options,
            ...params
        });
    }
    
    /**
     * Search for invitations
     *
     * Search and filter invitations by email, status, and pagination.
     */
    public static searchInvitations<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        email?: string | null;
        status?: InvitationInvitationStatus | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'email' },
                    { in: 'query', key: 'status' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<SearchInvitationsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/invitations/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete an invitation
     *
     * Deletes the invitation by its ID.
     */
    public static deleteInvitation<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteInvitationResponses, DeleteInvitationErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/invitations/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve an invitation
     *
     * Retrieves the invitation by its ID, including the invitation link.
     */
    public static invitation<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<InvitationResponses, InvitationErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/invitations/{id}',
            ...options,
            ...params
        });
    }
}

export class Users {
    /**
     * Update authenticated user password
     *
     * Changes the login password for the authenticated user.
     */
    public static updateCurrentUserPassword<ThrowOnError extends boolean = false>(parameters: {
        meControllerApiUpdatePasswordRequest: MeControllerApiUpdatePasswordRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'meControllerApiUpdatePasswordRequest', map: 'body' }] }]);
        return (options?.client ?? client).put<UpdateCurrentUserPasswordResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/me/password',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve users
     */
    public static listUsers<ThrowOnError extends boolean = false>(parameters: {
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<ListUsersResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a new user account
     *
     * Superadmin-only. Create a new user account with an optional password based authentication method.
     */
    public static createUser<ThrowOnError extends boolean = false>(parameters: {
        iamUserControllerApiCreateOrUpdateUserRequest: IamUserControllerApiCreateOrUpdateUserRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'iamUserControllerApiCreateOrUpdateUserRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateUserResponses, CreateUserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a user
     *
     * Superadmin-only. Delete a user including all its access.
     */
    public static deleteUser<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteUserResponses, DeleteUserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get a user
     *
     * Superadmin-only. Get user account details.
     */
    public static user<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<UserResponses, UserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update user details
     *
     * Superadmin-only. Updates the the details of a user.
     */
    public static patchUser<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        meControllerApiUserDetailsRequest: MeControllerApiUserDetailsRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'meControllerApiUserDetailsRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchUserResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Update a user account
     *
     * Superadmin-only. Update an existing user account with an optional password based authentication method.
     */
    public static updateUser<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        iamUserControllerApiCreateOrUpdateUserRequest: IamUserControllerApiCreateOrUpdateUserRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'iamUserControllerApiCreateOrUpdateUserRequest', map: 'body' }] }]);
        return (options?.client ?? client).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List API tokens for a specific user
     *
     * Superadmin-only. Get all API token existing for a user.
     */
    public static listApiTokensForUser<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<ListApiTokensForUserResponses, ListApiTokensForUserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/api-tokens',
            ...options,
            ...params
        });
    }
    
    /**
     * Create new API Token for a specific user
     *
     * Superadmin-only. Create a new API token for a user.
     */
    public static createApiTokensForUser<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        createApiTokenRequest: CreateApiTokenRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'createApiTokenRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateApiTokensForUserResponses, CreateApiTokensForUserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/api-tokens',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete an API Token for specific user and token id
     *
     * Superadmin-only. Delete an API token for a user.
     */
    public static deleteApiTokenForUser<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tokenId: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tokenId' }] }]);
        return (options?.client ?? client).delete<DeleteApiTokenForUserResponses, DeleteApiTokenForUserErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/api-tokens/{tokenId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update user password
     *
     * Superadmin-only. Updates whether a user is a superadmin.
     */
    public static deleteUserAuthMethod<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        auth: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'auth' }] }]);
        return (options?.client ?? client).delete<DeleteUserAuthMethodResponses, DeleteUserAuthMethodErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/auths/{auth}',
            ...options,
            ...params
        });
    }
    
    /**
     * Impersonate a user
     *
     * Superadmin-only. Allows an admin to impersonate another user.
     */
    public static impersonate<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).post<ImpersonateResponses, ImpersonateErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/impersonate',
            ...options,
            ...params
        });
    }
    
    /**
     * Update user password
     *
     * Superadmin-only. Updates whether a user is a superadmin.
     */
    public static patchUserPassword<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        iamUserControllerApiPatchUserPasswordRequest: IamUserControllerApiPatchUserPasswordRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'iamUserControllerApiPatchUserPasswordRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchUserPasswordResponses, PatchUserPasswordErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/password',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a user refresh token
     */
    public static deleteRefreshToken<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteRefreshTokenResponses, DeleteRefreshTokenErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/refresh-token',
            ...options,
            ...params
        });
    }
    
    /**
     * Update user demo
     *
     * Superadmin-only. Updates whether a user is for demo.
     */
    public static patchUserDemo<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        iamUserControllerApiPatchRestrictedRequest: IamUserControllerApiPatchRestrictedRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'iamUserControllerApiPatchRestrictedRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchUserDemoResponses, PatchUserDemoErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/restricted',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Update user superadmin privileges
     *
     * Superadmin-only. Updates whether a user is a superadmin.
     */
    public static patchUserSuperAdmin<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        apiPatchSuperAdminRequest: ApiPatchSuperAdminRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'apiPatchSuperAdminRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchUserSuperAdminResponses, PatchUserSuperAdminErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/users/{id}/superadmin',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List users for autocomplete
     */
    public static autocompleteUsers<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamTenantAccessControllerUserApiAutocomplete: IamTenantAccessControllerUserApiAutocomplete;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamTenantAccessControllerUserApiAutocomplete', map: 'body' }] }]);
        return (options?.client ?? client).post<AutocompleteUsersResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/tenant-access/autocomplete',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Update the list of groups a user belongs to for the given tenant
     */
    public static updateUserGroups<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        iamUserGroupControllerApiUpdateUserGroupsRequest: IamUserGroupControllerApiUpdateUserGroupsRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'iamUserGroupControllerApiUpdateUserGroupsRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateUserGroupsResponses, UpdateUserGroupsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/users/{id}/groups',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class ServiceAccount {
    /**
     * List service accounts. Superadmin-only.
     */
    public static listServiceAccounts<ThrowOnError extends boolean = false>(parameters: {
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<ListServiceAccountsResponses, ListServiceAccountsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a service account
     *
     * Superadmin-only. CReate service account with access to multiple tenants.
     */
    public static createServiceAccount<ThrowOnError extends boolean = false>(parameters: {
        iamServiceAccountControllerApiCreateServiceAccountRequest: IamServiceAccountControllerApiCreateServiceAccountRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'iamServiceAccountControllerApiCreateServiceAccountRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateServiceAccountResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a service account
     *
     * Superadmin-only. Delete a service account including all its access.
     */
    public static deleteServiceAccount<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteServiceAccountResponses, DeleteServiceAccountErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get a service account
     *
     * Superadmin-only. Get user account details.
     */
    public static serviceAccount<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<ServiceAccountResponses, ServiceAccountErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update service account details
     *
     * Superadmin-only. Updates the details of a service account.
     */
    public static patchServiceAccountDetails<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        iamServiceAccountControllerApiPatchServiceAccountRequest: IamServiceAccountControllerApiPatchServiceAccountRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'iamServiceAccountControllerApiPatchServiceAccountRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchServiceAccountDetailsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List API tokens for a specific service account
     */
    public static listApiTokensForServiceAccount<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<ListApiTokensForServiceAccountResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}/api-tokens',
            ...options,
            ...params
        });
    }
    
    /**
     * Create new API Token for a specific service account
     */
    public static createApiTokensForServiceAccount<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        createApiTokenRequest: CreateApiTokenRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'createApiTokenRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateApiTokensForServiceAccountResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}/api-tokens',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete an API Token for specific service account and token id
     */
    public static deleteApiTokenForServiceAccount<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tokenId: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tokenId' }] }]);
        return (options?.client ?? client).delete<DeleteApiTokenForServiceAccountResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}/api-tokens/{tokenId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update service account superadmin privileges
     *
     * Superadmin-only. Updates whether a service account is a superadmin.
     */
    public static patchServiceAccountSuperAdmin<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        apiPatchSuperAdminRequest: ApiPatchSuperAdminRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'apiPatchSuperAdminRequest', map: 'body' }] }]);
        return (options?.client ?? client).patch<PatchServiceAccountSuperAdminResponses, PatchServiceAccountSuperAdminErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/service-accounts/{id}/superadmin',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Create a service account for the given tenant
     */
    public static createServiceAccountForTenant<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamServiceAccountControllerApiServiceAccountRequest: IamServiceAccountControllerApiServiceAccountRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamServiceAccountControllerApiServiceAccountRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateServiceAccountForTenantResponses, CreateServiceAccountForTenantErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a service account
     */
    public static deleteServiceAccountForTenant<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteServiceAccountForTenantResponses, DeleteServiceAccountForTenantErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a service account
     */
    public static serviceAccountForTenant<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ServiceAccountForTenantResponses, ServiceAccountForTenantErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a user service account
     */
    public static updateServiceAccount<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        iamServiceAccountControllerApiServiceAccountRequest: IamServiceAccountControllerApiServiceAccountRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'iamServiceAccountControllerApiServiceAccountRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateServiceAccountResponses, UpdateServiceAccountErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List API tokens for a specific service account
     */
    public static listApiTokensForServiceAccountWithTenant<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListApiTokensForServiceAccountWithTenantResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts/{id}/api-tokens',
            ...options,
            ...params
        });
    }
    
    /**
     * Create new API Token for a specific service account
     */
    public static createApiTokensForServiceAccountWithTenant<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        createApiTokenRequest: CreateApiTokenRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'createApiTokenRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<CreateApiTokensForServiceAccountWithTenantResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts/{id}/api-tokens',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete an API Token for specific service account and token id
     */
    public static deleteApiTokenForServiceAccountWithTenant<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tokenId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tokenId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteApiTokenForServiceAccountWithTenantResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/service-accounts/{id}/api-tokens/{tokenId}',
            ...options,
            ...params
        });
    }
}

export class Tenants {
    /**
     * Create a tenant
     *
     * Superadmin-only.
     */
    public static create<ThrowOnError extends boolean = false>(parameters: {
        tenant: Tenant;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'tenant', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for tenants
     *
     * Superadmin-only.
     */
    public static find<ThrowOnError extends boolean = false>(parameters: {
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<FindResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a tenant and all its resources
     *
     * Superadmin-only. Deletes all resources linked to the tenant, including flows, namespaces, apps, etc.
     */
    public static delete<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a tenant
     *
     * Superadmin-only.
     */
    public static get<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<GetResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a tenant
     *
     * Superadmin-only.
     */
    public static update<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: Tenant;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'tenant', map: 'body' }] }]);
        return (options?.client ?? client).put<UpdateResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get the apps catalog config for the specified tenant.
     *
     * Superadmin-only.
     */
    public static appsCatalogConfig<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).get<AppsCatalogConfigResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/{id}/apps-catalog',
            ...options,
            ...params
        });
    }
    
    /**
     * Set the apps catalog config for the specified tenant.
     *
     * Superadmin-only.
     */
    public static setAppsCatalogConfig<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenantControllerAppsCatalogConfigRequest: TenantControllerAppsCatalogConfigRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { key: 'tenantControllerAppsCatalogConfigRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<SetAppsCatalogConfigResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/{id}/apps-catalog',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Remove the apps catalog logo for the specified tenant.
     *
     * Superadmin-only.
     */
    public static deleteAppsCatalogLogo<ThrowOnError extends boolean = false>(parameters: {
        id: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }] }]);
        return (options?.client ?? client).delete<DeleteAppsCatalogLogoResponses, unknown, ThrowOnError>({
            url: '/api/v1/tenants/{id}/apps-catalog/logo',
            ...options,
            ...params
        });
    }
    
    /**
     * Set the apps catalog logo for the specified tenant.
     *
     * Superadmin-only.
     */
    public static setAppsCatalogLogo<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        logo?: Blob | File;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'body', key: 'logo' }] }]);
        return (options?.client ?? client).post<SetAppsCatalogLogoResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            url: '/api/v1/tenants/{id}/apps-catalog/logo',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Set a tenant logo
     *
     * Superadmin-only.
     */
    public static setLogo<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        logo?: Blob | File;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'body', key: 'logo' }] }]);
        return (options?.client ?? client).post<SetLogoResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            url: '/api/v1/tenants/{id}/logo',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get tenant dependencies
     */
    public static flowDependenciesFromTenant<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        destinationOnly: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'destinationOnly' }] }]);
        return (options?.client ?? client).get<FlowDependenciesFromTenantResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dependencies',
            ...options,
            ...params
        });
    }
}

export class Ai {
    /**
     * Generate or regenerate a flow based on a prompt
     */
    public static generateFlow<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        flowGenerationPrompt: FlowGenerationPrompt;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'flowGenerationPrompt', map: 'body' }] }]);
        return (options?.client ?? client).post<GenerateFlowResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/ai/generate/flow',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Apps {
    /**
     * Delete existing apps
     */
    public static bulkDeleteApps<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        appsControllerApiBulkOperationRequest: AppsControllerApiBulkOperationRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'appsControllerApiBulkOperationRequest', map: 'body' }] }]);
        return (options?.client ?? client).delete<BulkDeleteAppsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Create a new app
     */
    public static createApp<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<CreateAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for apps from catalog
     */
    public static searchAppsFromCatalog<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        tags?: Array<string> | null;
        q?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'tags' },
                    { in: 'query', key: 'q' }
                ] }]);
        return (options?.client ?? client).get<SearchAppsFromCatalogResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/catalog',
            ...options,
            ...params
        });
    }
    
    /**
     * Disable existing apps
     */
    public static bulkDisableApps<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        appsControllerApiBulkOperationRequest: AppsControllerApiBulkOperationRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'appsControllerApiBulkOperationRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<BulkDisableAppsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/disable',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Enable existing apps
     */
    public static bulkEnableApps<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        appsControllerApiBulkOperationRequest: AppsControllerApiBulkOperationRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'appsControllerApiBulkOperationRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<BulkEnableAppsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/enable',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Export apps as a ZIP archive of YAML sources.
     */
    public static bulkExportApps<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        appsControllerApiBulkOperationRequest: AppsControllerApiBulkOperationRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'appsControllerApiBulkOperationRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<BulkExportAppsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/export',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     *     Import apps as a ZIP archive of yaml sources or a multi-objects YAML file.
     * When sending a Yaml that contains one or more apps, a list of index is returned.
     * When sending a ZIP archive, a list of files that couldn't be imported is returned.
     *
     */
    public static bulkImportApps<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        fileUpload?: Blob | File;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body', key: 'fileUpload' }] }]);
        return (options?.client ?? client).post<BulkImportAppsResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/import',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Open the app for the given source
     */
    public static previewApp<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        parameters?: HttpParameters;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body', key: 'parameters' }] }]);
        return (options?.client ?? client).post<PreviewAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/preview',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for apps
     */
    public static searchApps<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        tags?: Array<string> | null;
        q?: string | null;
        namespace?: string | null;
        flowId?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'tags' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' }
                ] }]);
        return (options?.client ?? client).get<SearchAppsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Get all the app tags
     */
    public static listTags<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListTagsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/tags',
            ...options,
            ...params
        });
    }
    
    /**
     * Dispatch for a given app.
     */
    public static dispatchApp<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        dispatch: string;
        tenant: string;
        body?: Array<Blob | File>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'dispatch' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<DispatchAppResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{id}/dispatch/{dispatch}',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Download file from an app execution
     */
    public static downloadFileFromAppExecution<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        path: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<DownloadFileFromAppExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{id}/file/download',
            ...options,
            ...params
        });
    }
    
    /**
     * Get file meta information from an app execution
     */
    public static fileMetaFromAppExecution<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        path: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<FileMetaFromAppExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{id}/file/meta',
            ...options,
            ...params
        });
    }
    
    /**
     * Get file preview from an app execution
     */
    public static filePreviewFromAppExecution<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        path: string;
        maxRows?: number | null;
        encoding: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' },
                    { in: 'query', key: 'maxRows' },
                    { in: 'query', key: 'encoding' }
                ] }]);
        return (options?.client ?? client).get<FilePreviewFromAppExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{id}/file/preview',
            ...options,
            ...params
        });
    }
    
    /**
     * Get an event stream from a given app.
     */
    public static streamEventsFromApp<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        stream: string;
        tenant: string;
        parameters: HttpParameters;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'stream' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'parameters' }
                ] }]);
        return (options?.client ?? client).sse.get<StreamEventsFromAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{id}/streams/{stream}',
            ...options,
            ...params
        });
    }
    
    /**
     * Open an app
     */
    public static openApp<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
        parameters: HttpParameters;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'uid' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'parameters' }
                ] }]);
        return (options?.client ?? client).get<OpenAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{uid}',
            ...options,
            ...params
        });
    }
    
    /**
     * Download logs for an app execution
     */
    public static logsFromAppExecution<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
        executionId: string;
        minLevel?: Level | null;
        taskIds?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'uid' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'executionId' },
                    { in: 'query', key: 'minLevel' },
                    { in: 'query', key: 'taskIds' }
                ] }]);
        return (options?.client ?? client).get<LogsFromAppExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/view/{uid}/logs/download',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete an existing app
     */
    public static deleteApp<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/{uid}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve an app
     */
    public static app<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<AppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/{uid}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update an existing app
     */
    public static updateApp<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'uid' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/{uid}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Disable the app.
     */
    public static disableApp<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).post<DisableAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/{uid}/disable',
            ...options,
            ...params
        });
    }
    
    /**
     * Enable the app.
     */
    public static enableApp<ThrowOnError extends boolean = false>(parameters: {
        uid: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).post<EnableAppResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/apps/{uid}/enable',
            ...options,
            ...params
        });
    }
}

export class Bindings {
    /**
     * Create a binding
     */
    public static createBinding<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamBindingControllerApiCreateBindingRequest: IamBindingControllerApiCreateBindingRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamBindingControllerApiCreateBindingRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateBindingResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/bindings',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Create multiple bindings
     */
    public static bulkCreateBinding<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<IamBindingControllerApiCreateBindingRequest>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<BulkCreateBindingResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/bindings/bulk',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for bindings
     */
    public static searchBindings<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
        type?: BindingType | null;
        id?: string | null;
        namespace?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'type' },
                    { in: 'query', key: 'id' },
                    { in: 'query', key: 'namespace' }
                ] }]);
        return (options?.client ?? client).get<SearchBindingsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/bindings/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a binding
     */
    public static deleteBinding<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteBindingResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/bindings/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a binding
     */
    public static binding<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<BindingResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/bindings/{id}',
            ...options,
            ...params
        });
    }
}

export class Blueprints {
    /**
     * List all blueprints
     *
     * Lists all community blueprints of the specified kind. Community blueprints are shared and versioned.
     */
    public static searchBlueprints<ThrowOnError extends boolean = false>(parameters: {
        kind: BlueprintControllerKind;
        tenant: string;
        q?: string | null;
        sort?: string | null;
        tags?: Array<string> | null;
        page: number;
        size: number;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'kind' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'tags' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' }
                ] }]);
        return (options?.client ?? client).get<SearchBlueprintsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/community/{kind}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a blueprint
     *
     * Retrieves details of a specific community blueprint.
     */
    public static blueprint<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        kind: BlueprintControllerKind;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'kind' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<BlueprintResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/community/{kind}/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a blueprint graph
     *
     * Retrieves the topology graph representation of a specific community blueprint.
     */
    public static blueprintGraph<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        kind: BlueprintControllerKind;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'kind' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<BlueprintGraphResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/community/{kind}/{id}/graph',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a blueprint source code
     *
     * Retrieves the YAML source code for a specific community blueprint.
     */
    public static blueprintSource<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        kind: BlueprintControllerKind;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'kind' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<BlueprintSourceResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/community/{kind}/{id}/source',
            ...options,
            ...params
        });
    }
    
    /**
     * List all internal blueprints
     *
     * Lists all internal (custom) blueprints for the current tenant. Requires BLUEPRINT permission.
     */
    public static searchInternalBlueprints<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        sort?: string | null;
        tags?: Array<string> | null;
        page: number;
        size: number;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'tags' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' }
                ] }]);
        return (options?.client ?? client).get<SearchInternalBlueprintsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a new internal blueprint
     *
     * Creates a new internal (custom) blueprint for the current tenant. Requires BLUEPRINT permission.
     */
    public static createInternalBlueprints<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        blueprintControllerApiBlueprintItemWithSource: BlueprintControllerApiBlueprintItemWithSource;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'blueprintControllerApiBlueprintItemWithSource', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateInternalBlueprintsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete an internal blueprint
     *
     * Deletes an internal (custom) blueprint for the current tenant. Requires BLUEPRINT permission.
     */
    public static deleteInternalBlueprints<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteInternalBlueprintsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve an internal blueprint
     *
     * Retrieves details of a specific internal (custom) blueprint. Requires BLUEPRINT permission.
     */
    public static internalBlueprint<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<InternalBlueprintResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update an internal blueprint
     *
     * Updates an existing internal (custom) blueprint for the current tenant. Requires BLUEPRINT permission.
     */
    public static updateInternalBlueprints<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        blueprintControllerApiBlueprintItemWithSource: BlueprintControllerApiBlueprintItemWithSource;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'blueprintControllerApiBlueprintItemWithSource', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateInternalBlueprintsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve an internal blueprint source code
     *
     * Retrieves the YAML source code for a specific internal (custom) blueprint. Requires BLUEPRINT permission.
     */
    public static internalBlueprintFlow<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<InternalBlueprintFlowResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom/{id}/source',
            ...options,
            ...params
        });
    }
}

export class BlueprintTags {
    /**
     * List blueprint tags matching the filter
     *
     * Lists tags for community blueprints of the specified kind, optionally filtered by query.
     */
    public static listBlueprintTags<ThrowOnError extends boolean = false>(parameters: {
        kind: BlueprintControllerKind;
        tenant: string;
        q?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'kind' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' }
                ] }]);
        return (options?.client ?? client).get<ListBlueprintTagsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/community/{kind}/tags',
            ...options,
            ...params
        });
    }
    
    /**
     * List all internal blueprint tags
     *
     * Lists all tags used by internal (custom) blueprints for the current tenant.
     */
    public static internalBlueprintTags<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'q' }] }]);
        return (options?.client ?? client).get<InternalBlueprintTagsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/blueprints/custom/tags',
            ...options,
            ...params
        });
    }
}

export class Executions {
    /**
     * Search for flow concurrency limits
     */
    public static searchConcurrencyLimits<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<SearchConcurrencyLimitsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/concurrency-limit/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a flow concurrency limit
     */
    public static updateConcurrencyLimit<ThrowOnError extends boolean = false>(parameters: {
        flowId: string;
        namespace: string;
        tenant: string;
        concurrencyLimit: ConcurrencyLimit;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { key: 'concurrencyLimit', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateConcurrencyLimitResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/concurrency-limit/{namespace}/{flowId}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for executions for a flow
     */
    public static searchExecutionsByFlowId<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        namespace: string;
        flowId: string;
        page: number;
        size: number;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' }
                ] }]);
        return (options?.client ?? client).get<SearchExecutionsByFlowIdResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a list of executions
     */
    public static deleteExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        includeNonTerminated?: boolean | null;
        deleteLogs?: boolean;
        deleteMetrics?: boolean;
        deleteStorage?: boolean;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'includeNonTerminated' },
                    { in: 'query', key: 'deleteLogs' },
                    { in: 'query', key: 'deleteMetrics' },
                    { in: 'query', key: 'deleteStorage' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).delete<DeleteExecutionsByIdsResponses, DeleteExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete executions filter by query parameters
     */
    public static deleteExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
        includeNonTerminated?: boolean | null;
        deleteLogs?: boolean;
        deleteMetrics?: boolean;
        deleteStorage?: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'filters' },
                    { in: 'query', key: 'includeNonTerminated' },
                    { in: 'query', key: 'deleteLogs' },
                    { in: 'query', key: 'deleteMetrics' },
                    { in: 'query', key: 'deleteStorage' }
                ] }]);
        return (options?.client ?? client).delete<DeleteExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Change executions state by id
     */
    public static updateExecutionsStatusByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        newStatus: StateType;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'newStatus' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<UpdateExecutionsStatusByIdsResponses, UpdateExecutionsStatusByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/change-status/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Change executions state by query parameters
     */
    public static updateExecutionsStatusByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
        newStatus: StateType;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'filters' },
                    { in: 'query', key: 'newStatus' }
                ] }]);
        return (options?.client ?? client).post<UpdateExecutionsStatusByQueryResponses, UpdateExecutionsStatusByQueryErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/change-status/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Get flow information's for an execution
     */
    public static flowFromExecution<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        tenant: string;
        revision?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'revision' }
                ] }]);
        return (options?.client ?? client).get<FlowFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/flows/{namespace}/{flowId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Force run a list of executions
     */
    public static forceRunByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ForceRunByIdsResponses, ForceRunByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/force-run/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Force run executions filter by query parameters
     */
    public static forceRunExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<ForceRunExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/force-run/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Kill a list of executions
     */
    public static killExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).delete<KillExecutionsByIdsResponses, KillExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/kill/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Kill executions filter by query parameters
     */
    public static killExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).delete<KillExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/kill/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Set labels on a list of executions
     */
    public static setLabelsOnTerminatedExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        executionControllerSetLabelsByIdsRequest: ExecutionControllerSetLabelsByIdsRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'executionControllerSetLabelsByIdsRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<SetLabelsOnTerminatedExecutionsByIdsResponses, SetLabelsOnTerminatedExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/labels/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Set label on executions filter by query parameters
     */
    public static setLabelsOnTerminatedExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
        body: Array<Label>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'filters' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<SetLabelsOnTerminatedExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/labels/by-query',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get the latest execution for given flows
     */
    public static latestExecutions<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<ExecutionRepositoryInterfaceFlowFilter>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<LatestExecutionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/latest',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Pause a list of running executions
     */
    public static pauseExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<PauseExecutionsByIdsResponses, PauseExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/pause/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Pause executions filter by query parameters
     */
    public static pauseExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<PauseExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/pause/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Create new executions from old ones. Keep the flow revision
     */
    public static replayExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        latestRevision?: boolean | null;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'latestRevision' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<ReplayExecutionsByIdsResponses, ReplayExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/replay/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Create new executions from old ones filter by query parameters. Keep the flow revision
     */
    public static replayExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
        latestRevision?: boolean | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'filters' },
                    { in: 'query', key: 'latestRevision' }
                ] }]);
        return (options?.client ?? client).post<ReplayExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/replay/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Restart a list of executions
     */
    public static restartExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<RestartExecutionsByIdsResponses, RestartExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/restart/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Restart executions filter by query parameters
     */
    public static restartExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<RestartExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/restart/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Resume a list of paused executions
     */
    public static resumeExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ResumeExecutionsByIdsResponses, ResumeExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/resume/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Resume executions filter by query parameters
     */
    public static resumeExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<ResumeExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/resume/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Search for executions
     */
    public static searchExecutions<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<SearchExecutionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Unqueue a list of executions
     */
    public static unqueueExecutionsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        state: StateType;
        body: Array<string>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'state' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<UnqueueExecutionsByIdsResponses, UnqueueExecutionsByIdsErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/unqueue/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Unqueue executions filter by query parameters
     */
    public static unqueueExecutionsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
        newState?: StateType | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'filters' },
                    { in: 'query', key: 'newState' }
                ] }]);
        return (options?.client ?? client).post<UnqueueExecutionsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/unqueue/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Trigger a new execution by GET webhook trigger
     */
    public static triggerExecutionByGetWebhook<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        key: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'key' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<TriggerExecutionByGetWebhookResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete an execution
     */
    public static deleteExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        deleteLogs?: boolean;
        deleteMetrics?: boolean;
        deleteStorage?: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'deleteLogs' },
                    { in: 'query', key: 'deleteMetrics' },
                    { in: 'query', key: 'deleteStorage' }
                ] }]);
        return (options?.client ?? client).delete<DeleteExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get an execution
     */
    public static execution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'executionId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Change the state of an execution
     */
    public static updateExecutionStatus<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        status: StateType;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'status' }
                ] }]);
        return (options?.client ?? client).post<UpdateExecutionStatusResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/change-status',
            ...options,
            ...params
        });
    }
    
    /**
     * Download file for an execution
     */
    public static downloadFileFromExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        path: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<DownloadFileFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/file',
            ...options,
            ...params
        });
    }
    
    /**
     * Get file meta information for an execution
     */
    public static fileMetadatasFromExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        path: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<FileMetadatasFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/file/metas',
            ...options,
            ...params
        });
    }
    
    /**
     * Get flow information's for an execution
     */
    public static flowFromExecutionById<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'executionId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<FlowFromExecutionByIdResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/flow',
            ...options,
            ...params
        });
    }
    
    /**
     * Follow an execution
     */
    public static followExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'executionId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).sse.get<FollowExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/follow',
            ...options,
            ...params
        });
    }
    
    /**
     * Follow all execution dependencies executions
     */
    public static followDependenciesExecutions<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        destinationOnly: boolean;
        expandAll: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'destinationOnly' },
                    { in: 'query', key: 'expandAll' }
                ] }]);
        return (options?.client ?? client).sse.get<FollowDependenciesExecutionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/follow-dependencies',
            ...options,
            ...params
        });
    }
    
    /**
     * Force run an execution
     */
    public static forceRunExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'executionId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).post<ForceRunExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/force-run',
            ...options,
            ...params
        });
    }
    
    /**
     * Generate a graph for an execution
     */
    public static executionFlowGraph<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        subflows?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'subflows' }
                ] }]);
        return (options?.client ?? client).get<ExecutionFlowGraphResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/graph',
            ...options,
            ...params
        });
    }
    
    /**
     * Kill an execution
     */
    public static killExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        isOnKillCascade: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'isOnKillCascade' }
                ] }]);
        return (options?.client ?? client).delete<KillExecutionResponses, KillExecutionErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/kill',
            ...options,
            ...params
        });
    }
    
    /**
     * Add or update labels of a terminated execution
     */
    public static setLabelsOnTerminatedExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        body: Array<Label>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<SetLabelsOnTerminatedExecutionResponses, SetLabelsOnTerminatedExecutionErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/labels',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Pause a running execution.
     */
    public static pauseExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'executionId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).post<PauseExecutionResponses, PauseExecutionErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/pause',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a new execution from an old one and start it from a specified task run id
     */
    public static replayExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        taskRunId?: string | null;
        revision?: number | null;
        breakpoints?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'taskRunId' },
                    { in: 'query', key: 'revision' },
                    { in: 'query', key: 'breakpoints' }
                ] }]);
        return (options?.client ?? client).post<ReplayExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/replay',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a new execution from an old one and start it from a specified task run id
     */
    public static replayExecutionWithinputs<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        taskRunId?: string | null;
        revision?: number | null;
        breakpoints?: string | null;
        body: Array<Blob | File>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'taskRunId' },
                    { in: 'query', key: 'revision' },
                    { in: 'query', key: 'breakpoints' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<ReplayExecutionWithinputsResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/replay-with-inputs',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Restart a new execution from an old one
     */
    public static restartExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        revision?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'revision' }
                ] }]);
        return (options?.client ?? client).post<RestartExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/restart',
            ...options,
            ...params
        });
    }
    
    /**
     * Resume a paused execution.
     */
    public static resumeExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        body: Array<Blob | File>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<ResumeExecutionResponses, ResumeExecutionErrors, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/resume',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Unqueue an execution
     */
    public static unqueueExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        state: StateType;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'state' }
                ] }]);
        return (options?.client ?? client).post<UnqueueExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{executionId}/unqueue',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a new execution for a flow
     */
    public static createExecution<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        labels?: Array<string> | null;
        wait: boolean;
        revision?: number | null;
        scheduleDate?: string | null;
        breakpoints?: string | null;
        kind?: ExecutionKind | null;
        body?: Array<Blob | File>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'labels' },
                    { in: 'query', key: 'wait' },
                    { in: 'query', key: 'revision' },
                    { in: 'query', key: 'scheduleDate' },
                    { in: 'query', key: 'breakpoints' },
                    { in: 'query', key: 'kind' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<CreateExecutionResponses, CreateExecutionErrors, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/executions/{namespace}/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Flows {
    /**
     * Search for flow concurrency limits
     */
    public static searchConcurrencyLimits<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<SearchConcurrencyLimitsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/concurrency-limit/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a flow concurrency limit
     */
    public static updateConcurrencyLimit<ThrowOnError extends boolean = false>(parameters: {
        flowId: string;
        namespace: string;
        tenant: string;
        concurrencyLimit: ConcurrencyLimit;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { key: 'concurrencyLimit', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateConcurrencyLimitResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/concurrency-limit/{namespace}/{flowId}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Create a flow from yaml source
     */
    public static createFlow<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<CreateFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Update from multiples yaml sources
     *
     * All flow will be created / updated for this namespace.
     * Flow that already created but not in `flows` will be deleted if the query delete is `true`
     */
    public static bulkUpdateFlows<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        delete: boolean;
        namespace?: string | null;
        allowNamespaceChild: boolean;
        body?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'delete' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'allowNamespaceChild' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<BulkUpdateFlowsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/bulk',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete flows by their IDs.
     */
    public static deleteFlowsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<IdWithNamespace>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).delete<DeleteFlowsByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/delete/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete flows returned by the query parameters.
     */
    public static deleteFlowsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).delete<DeleteFlowsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/delete/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Disable flows by their IDs.
     */
    public static disableFlowsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<IdWithNamespace>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<DisableFlowsByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/disable/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Disable flows returned by the query parameters.
     */
    public static disableFlowsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<DisableFlowsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/disable/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * List all distinct namespaces
     */
    public static listDistinctNamespaces<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'q' }] }]);
        return (options?.client ?? client).get<ListDistinctNamespacesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/distinct-namespaces',
            ...options,
            ...params
        });
    }
    
    /**
     * Enable flows by their IDs.
     */
    public static enableFlowsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<IdWithNamespace>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<EnableFlowsByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/enable/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Enable flows returned by the query parameters.
     */
    public static enableFlowsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<EnableFlowsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/enable/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Export flows as a ZIP archive of yaml sources.
     */
    public static exportFlowsByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<IdWithNamespace>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ExportFlowsByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/export/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Export flows as a ZIP archive of yaml sources.
     */
    public static exportFlowsByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).get<ExportFlowsByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/export/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Generate a graph for a flow source
     */
    public static generateFlowGraphFromSource<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        subflows?: Array<string> | null;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'subflows' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<GenerateFlowGraphFromSourceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/graph',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.
     * When sending a Yaml that contains one or more flows, a list of index is returned.
     * When sending a ZIP archive, a list of files that couldn't be imported is returned.
     *
     */
    public static importFlows<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        failOnError: boolean;
        fileUpload?: Blob | File;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'failOnError' },
                    { in: 'body', key: 'fileUpload' }
                ] }]);
        return (options?.client ?? client).post<ImportFlowsResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/import',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for flows
     */
    public static searchFlows<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<SearchFlowsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Search for flows source code
     */
    public static searchFlowsBySourceCode<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        q?: string | null;
        namespace?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'namespace' }
                ] }]);
        return (options?.client ?? client).get<SearchFlowsBySourceCodeResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/source',
            ...options,
            ...params
        });
    }
    
    /**
     * Validate a list of flows
     */
    public static validateFlows<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ValidateFlowsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/validate',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Validate a task
     */
    public static validateTask<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        section: FlowControllerTaskValidationType;
        body: {
            [key: string]: unknown;
        };
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'section' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<ValidateTaskResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/validate/task',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Validate trigger
     */
    public static validateTrigger<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: {
            [key: string]: unknown;
        };
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ValidateTriggerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/validate/trigger',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve all flows from a given namespace
     */
    public static listFlowsByNamespace<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListFlowsByNamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a complete namespace from yaml source
     *
     * All flow will be created / updated for this namespace.
     * Flow that already created but not in `flows` will be deleted if the query delete is `true`
     */
    public static updateFlowsInNamespace<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        delete: boolean;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'delete' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).post<UpdateFlowsInNamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a flow
     */
    public static deleteFlow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get a flow
     */
    public static flow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        source: boolean;
        revision?: number | null;
        allowDeleted: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'source' },
                    { in: 'query', key: 'revision' },
                    { in: 'query', key: 'allowDeleted' }
                ] }]);
        return (options?.client ?? client).get<FlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a flow
     */
    public static updateFlow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get flow dependencies
     */
    public static flowDependencies<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        destinationOnly: boolean;
        expandAll: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'destinationOnly' },
                    { in: 'query', key: 'expandAll' }
                ] }]);
        return (options?.client ?? client).get<FlowDependenciesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}/dependencies',
            ...options,
            ...params
        });
    }
    
    /**
     * Generate a graph for a flow
     */
    public static generateFlowGraph<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        revision?: number | null;
        subflows?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'revision' },
                    { in: 'query', key: 'subflows' }
                ] }]);
        return (options?.client ?? client).get<GenerateFlowGraphResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}/graph',
            ...options,
            ...params
        });
    }
    
    /**
     * Get revisions for a flow
     */
    public static listFlowRevisions<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<ListFlowRevisionsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}/revisions',
            ...options,
            ...params
        });
    }
    
    /**
     * Get a flow task
     */
    public static taskFromFlow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        taskId: string;
        tenant: string;
        revision?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'taskId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'revision' }
                ] }]);
        return (options?.client ?? client).get<TaskFromFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a single task on a flow
     *
     * @deprecated
     */
    public static updateTask<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        taskId: string;
        tenant: string;
        task: Task;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'taskId' },
                    { in: 'path', key: 'tenant' },
                    { key: 'task', map: 'body' }
                ] }]);
        return (options?.client ?? client).patch<UpdateTaskResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Retrieve flow dependencies
     */
    public static flowDependenciesFromNamespace<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        destinationOnly: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'destinationOnly' }
                ] }]);
        return (options?.client ?? client).get<FlowDependenciesFromNamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/dependencies',
            ...options,
            ...params
        });
    }
}

export class Dashboards {
    /**
     * Search for dashboards
     */
    public static searchDashboards<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        q?: string | null;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<SearchDashboardsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a dashboard from yaml source
     */
    public static createDashboard<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<CreateDashboardResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Export a table chart data to CSV
     */
    public static exportChartToCsv<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        dashboardControllerPreviewRequest: DashboardControllerPreviewRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'dashboardControllerPreviewRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<ExportChartToCsvResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/charts/export/to-csv',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Preview a chart data
     */
    public static previewChart<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        dashboardControllerPreviewRequest: DashboardControllerPreviewRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'dashboardControllerPreviewRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<PreviewChartResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/charts/preview',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Validate dashboard from yaml source
     */
    public static validateDashboard<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ValidateDashboardResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/validate',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Validate a chart from yaml source
     */
    public static validateChart<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ValidateChartResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/validate/chart',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a dashboard
     */
    public static deleteDashboard<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteDashboardResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get a dashboard
     */
    public static dashboard<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<DashboardResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a dashboard
     */
    public static updateDashboard<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateDashboardResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Generate a dashboard chart data
     */
    public static dashboardChartData<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        chartId: string;
        tenant: string;
        chartFiltersOverrides: ChartFiltersOverrides;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'chartId' },
                    { in: 'path', key: 'tenant' },
                    { key: 'chartFiltersOverrides', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<DashboardChartDataResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/{id}/charts/{chartId}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Export a dashboard chart data to CSV
     */
    public static exportDashboardChartDataToCsv<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        chartId: string;
        tenant: string;
        chartFiltersOverrides: ChartFiltersOverrides;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'chartId' },
                    { in: 'path', key: 'tenant' },
                    { key: 'chartFiltersOverrides', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<ExportDashboardChartDataToCsvResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/dashboards/{id}/charts/{chartId}/export/to-csv',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Groups {
    /**
     * Create a group
     */
    public static createGroup<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamGroupControllerApiCreateGroupRequest: IamGroupControllerApiCreateGroupRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamGroupControllerApiCreateGroupRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateGroupResponses, CreateGroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List groups for autocomplete
     */
    public static autocompleteGroups<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        apiAutocomplete: ApiAutocomplete;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'apiAutocomplete', map: 'body' }] }]);
        return (options?.client ?? client).post<AutocompleteGroupsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/autocomplete',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List groups by ids
     */
    public static listGroupIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        apiIds: ApiIds;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'apiIds', map: 'body' }] }]);
        return (options?.client ?? client).post<ListGroupIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for groups
     */
    public static searchGroups<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<SearchGroupsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a group
     */
    public static deleteGroup<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteGroupResponses, DeleteGroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a group
     *
     * Retrieves details of a specific group by its ID within the current tenant.
     */
    public static group<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<GroupResponses, GroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a group
     */
    public static updateGroup<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        iamGroupControllerApiUpdateGroupRequest: IamGroupControllerApiUpdateGroupRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'iamGroupControllerApiUpdateGroupRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateGroupResponses, UpdateGroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for users in a group
     */
    public static searchGroupMembers<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<SearchGroupMembersResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}/members',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a user's membership type in a group
     *
     * Allows a group owner or an authorized user to change the role of a user within a group to OWNER or MEMBER.
     */
    public static setUserMembershipForGroup<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        userId: string;
        tenant: string;
        membership: GroupIdentifierMembership;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'userId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'membership' }
                ] }]);
        return (options?.client ?? client).put<SetUserMembershipForGroupResponses, SetUserMembershipForGroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}/members/membership/{userId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Remove a user from a group
     *
     * Removes the specified user from the given group. If the user has no other group bindings within the tenant, their access to the tenant will also be revoked.
     */
    public static deleteUserFromGroup<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        userId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'userId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteUserFromGroupResponses, DeleteUserFromGroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}/members/{userId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Add a user to a group
     *
     * Adds the specified user to the given group. If the user does not already have access to the tenant, tenant access will be created automatically.
     */
    public static addUserToGroup<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        userId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'userId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).put<AddUserToGroupResponses, AddUserToGroupErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/groups/{id}/members/{userId}',
            ...options,
            ...params
        });
    }
}

export class ScimGroups {
    /**
     * Find by a combination of query parameters
     */
    public static queryGroups<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        filter?: string | null;
        sortBy?: string | null;
        sortOrder?: SortOrder | null;
        startIndex?: number | null;
        count?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { in: 'query', key: 'filter' },
                    { in: 'query', key: 'sortBy' },
                    { in: 'query', key: 'sortOrder' },
                    { in: 'query', key: 'startIndex' },
                    { in: 'query', key: 'count' }
                ] }]);
        return (options?.client ?? client).get<QueryGroupsResponses, QueryGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups',
            ...options,
            ...params
        });
    }
    
    /**
     * Create
     */
    public static createScimResourceByIdGroups<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        scimUser: ScimUser;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { key: 'scimUser', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<CreateScimResourceByIdGroupsResponses, CreateScimResourceByIdGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search
     */
    public static findGroups<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
        searchRequest: SearchRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { key: 'searchRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<FindGroupsResponses, FindGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups/.search',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete from the backing store
     */
    public static deleteGroups<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteGroupsResponses, DeleteGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Find by id
     */
    public static sCimResourceByIdGroups<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' }
                ] }]);
        return (options?.client ?? client).get<SCimResourceByIdGroupsResponses, SCimResourceByIdGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Patch a portion of the backing store
     */
    public static patchGroups<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        patchRequest: PatchRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { key: 'patchRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).patch<PatchGroupsResponses, PatchGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Update
     */
    public static updateGroups<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        scimResource: ScimResource;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { key: 'scimResource', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateGroupsResponses, UpdateGroupsErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Groups/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class ScimConfiguration {
    /**
     * Get All Resource Types
     */
    public static allResourceTypes<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'integration' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<AllResourceTypesResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/ResourceTypes',
            ...options,
            ...params
        });
    }
    
    /**
     * Get Resource Type by URN
     */
    public static resourceType<ThrowOnError extends boolean = false>(parameters: {
        name: string;
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'name' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<ResourceTypeResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/ResourceTypes/{name}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get All Schemas
     */
    public static allSchemas<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'integration' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<AllSchemasResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Schemas',
            ...options,
            ...params
        });
    }
    
    /**
     * Get Schemas by URN
     */
    public static schema<ThrowOnError extends boolean = false>(parameters: {
        uri: string;
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'uri' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<SchemaResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Schemas/{uri}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get Service Provider Configuration
     */
    public static serviceProviderConfiguration<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'integration' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ServiceProviderConfigurationResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/ServiceProviderConfig',
            ...options,
            ...params
        });
    }
}

export class ScimUsers {
    /**
     * Find by a combination of query parameters
     */
    public static queryUsers<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        filter?: string | null;
        sortBy?: string | null;
        sortOrder?: SortOrder | null;
        startIndex?: number | null;
        count?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { in: 'query', key: 'filter' },
                    { in: 'query', key: 'sortBy' },
                    { in: 'query', key: 'sortOrder' },
                    { in: 'query', key: 'startIndex' },
                    { in: 'query', key: 'count' }
                ] }]);
        return (options?.client ?? client).get<QueryUsersResponses, QueryUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users',
            ...options,
            ...params
        });
    }
    
    /**
     * Create
     */
    public static createScimResourceByIdUsers<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        scimUser: ScimUser;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { key: 'scimUser', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<CreateScimResourceByIdUsersResponses, CreateScimResourceByIdUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search
     */
    public static findUsers<ThrowOnError extends boolean = false>(parameters: {
        integration: string;
        tenant: string;
        searchRequest: SearchRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { key: 'searchRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<FindUsersResponses, FindUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users/.search',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete from the backing store
     */
    public static deleteUsers<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteUsersResponses, DeleteUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Find by id
     */
    public static sCimResourceByIdUsers<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' }
                ] }]);
        return (options?.client ?? client).get<SCimResourceByIdUsersResponses, SCimResourceByIdUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Patch a portion of the backing store
     */
    public static patchUsers<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        patchRequest: PatchRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { key: 'patchRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).patch<PatchUsersResponses, PatchUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Update
     */
    public static updateUsers<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        integration: string;
        tenant: string;
        attributes?: string | null;
        excludedAttributes?: string | null;
        scimResource: ScimResource;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'integration' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'attributes' },
                    { in: 'query', key: 'excludedAttributes' },
                    { key: 'scimResource', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateUsersResponses, UpdateUsersErrors, ThrowOnError>({
            url: '/api/v1/{tenant}/integrations/{integration}/scim/v2/Users/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/scim+json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Kv {
    /**
     * List all keys
     */
    public static listAllKeys<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<ListAllKeysResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/kv',
            ...options,
            ...params
        });
    }
    
    /**
     * Bulk-delete multiple key/value pairs from the given namespace.
     */
    public static deleteKeyValues<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        kvControllerApiDeleteBulkRequest: KvControllerApiDeleteBulkRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { key: 'kvControllerApiDeleteBulkRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).delete<DeleteKeyValuesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/kv',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List all keys for a namespace
     *
     * @deprecated
     */
    public static listKeys<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListKeysResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/kv',
            ...options,
            ...params
        });
    }
    
    /**
     * List all keys for inherited namespaces
     */
    public static listKeysWithInheritence<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListKeysWithInheritenceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/kv/inheritance',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a key-value pair
     */
    public static deleteKeyValue<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        key: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'key' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteKeyValueResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/kv/{key}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get value for a key
     */
    public static keyValue<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        key: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'key' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<KeyValueResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/kv/{key}',
            ...options,
            ...params
        });
    }
    
    /**
     * Puts a key-value pair in store
     */
    public static setKeyValue<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        key: string;
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'key' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).put<SetKeyValueResponses, unknown, ThrowOnError>({
            bodySerializer: null,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/kv/{key}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'text/plain',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Logs {
    /**
     * Search for logs
     */
    public static searchLogs<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<SearchLogsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/logs/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete logs for a specific execution, taskrun or task
     */
    public static deleteLogsFromExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        minLevel?: Level | null;
        taskRunId?: string | null;
        taskId?: string | null;
        attempt?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'minLevel' },
                    { in: 'query', key: 'taskRunId' },
                    { in: 'query', key: 'taskId' },
                    { in: 'query', key: 'attempt' }
                ] }]);
        return (options?.client ?? client).delete<DeleteLogsFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/logs/{executionId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get logs for a specific execution, taskrun or task
     */
    public static listLogsFromExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        minLevel?: Level | null;
        taskRunId?: string | null;
        taskId?: string | null;
        attempt?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'minLevel' },
                    { in: 'query', key: 'taskRunId' },
                    { in: 'query', key: 'taskId' },
                    { in: 'query', key: 'attempt' }
                ] }]);
        return (options?.client ?? client).get<ListLogsFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/logs/{executionId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Download logs for a specific execution, taskrun or task
     */
    public static downloadLogsFromExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        minLevel?: Level | null;
        taskRunId?: string | null;
        taskId?: string | null;
        attempt?: number | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'minLevel' },
                    { in: 'query', key: 'taskRunId' },
                    { in: 'query', key: 'taskId' },
                    { in: 'query', key: 'attempt' }
                ] }]);
        return (options?.client ?? client).get<DownloadLogsFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/logs/{executionId}/download',
            ...options,
            ...params
        });
    }
    
    /**
     * Follow logs for a specific execution
     */
    public static followLogsFromExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        minLevel?: Level | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'minLevel' }
                ] }]);
        return (options?.client ?? client).sse.get<FollowLogsFromExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/logs/{executionId}/follow',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete logs for a specific execution, taskrun or task
     */
    public static deleteLogsFromFlow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        tenant: string;
        triggerId: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'triggerId' }
                ] }]);
        return (options?.client ?? client).delete<DeleteLogsFromFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/logs/{namespace}/{flowId}',
            ...options,
            ...params
        });
    }
}

export class Metrics {
    /**
     * Get metrics aggregations for a specific flow
     */
    public static aggregateMetricsFromFlow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        metric: string;
        tenant: string;
        startDate?: string | null;
        endDate?: string | null;
        aggregation: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'metric' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'startDate' },
                    { in: 'query', key: 'endDate' },
                    { in: 'query', key: 'aggregation' }
                ] }]);
        return (options?.client ?? client).get<AggregateMetricsFromFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/metrics/aggregates/{namespace}/{flowId}/{metric}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get metrics aggregations for a specific flow
     */
    public static aggregateMetricsFromTask<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        taskId: string;
        metric: string;
        tenant: string;
        startDate?: string | null;
        endDate?: string | null;
        aggregation: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'taskId' },
                    { in: 'path', key: 'metric' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'startDate' },
                    { in: 'query', key: 'endDate' },
                    { in: 'query', key: 'aggregation' }
                ] }]);
        return (options?.client ?? client).get<AggregateMetricsFromTaskResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/metrics/aggregates/{namespace}/{flowId}/{taskId}/{metric}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get metrics names for a specific flow
     */
    public static listFlowMetrics<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<ListFlowMetricsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/metrics/names/{namespace}/{flowId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get metrics names for a specific task in a flow
     */
    public static listTaskMetrics<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        taskId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'taskId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<ListTaskMetricsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/metrics/names/{namespace}/{flowId}/{taskId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get tasks id that have metrics for a specific flow, include deleted or renamed tasks
     */
    public static listTasksWithMetrics<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<ListTasksWithMetricsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/metrics/tasks/{namespace}/{flowId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get metrics for a specific execution
     */
    public static searchByExecution<ThrowOnError extends boolean = false>(parameters: {
        executionId: string;
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        taskRunId?: string | null;
        taskId?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'executionId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'taskRunId' },
                    { in: 'query', key: 'taskId' }
                ] }]);
        return (options?.client ?? client).get<SearchByExecutionResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/metrics/{executionId}',
            ...options,
            ...params
        });
    }
}

export class Namespaces {
    /**
     * Create a namespace
     */
    public static createNamespace<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        namespace: Namespace;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'namespace', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateNamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List namespaces for autocomplete
     *
     * Returns a list of namespaces for use in autocomplete fields, optionally allowing to filter by query and ids. Used especially for binding creation.
     */
    public static autocompleteNamespaces<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        apiAutocomplete: ApiAutocomplete;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'apiAutocomplete', map: 'body' }] }]);
        return (options?.client ?? client).post<AutocompleteNamespacesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/autocomplete',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for namespaces
     */
    public static searchNamespaces<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
        existing: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'existing' }
                ] }]);
        return (options?.client ?? client).get<SearchNamespacesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a namespace
     */
    public static deleteNamespace<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteNamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Get a namespace
     */
    public static namespace<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<NamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a namespace
     */
    public static updateNamespace<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        namespace: Namespace;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'namespace', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateNamespaceResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List inherited plugin defaults
     */
    public static inheritedPluginDefaults<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<InheritedPluginDefaultsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{id}/inherited-plugindefaults',
            ...options,
            ...params
        });
    }
    
    /**
     * List inherited variables
     */
    public static inheritedVariables<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<InheritedVariablesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{id}/inherited-variables',
            ...options,
            ...params
        });
    }
    
    /**
     * List inherited secrets
     */
    public static inheritedSecrets<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<InheritedSecretsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/inherited-secrets',
            ...options,
            ...params
        });
    }
    
    /**
     * Get secrets for a namespace
     *
     * @deprecated
     */
    public static listNamespaceSecrets<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters: Array<QueryFilter>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<ListNamespaceSecretsResponses, unknown, ThrowOnError>({
            querySerializer: { parameters: { filters: { array: { explode: false } } } },
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/secrets',
            ...options,
            ...params
        });
    }
    
    /**
     * Update secrets for a namespace
     */
    public static putSecrets<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        apiSecretValue: ApiSecretValue;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { key: 'apiSecretValue', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<PutSecretsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/secrets',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a secret for a namespace
     */
    public static deleteSecret<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        key: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'key' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteSecretResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/secrets/{key}',
            ...options,
            ...params
        });
    }
    
    /**
     * Patch a secret metadata for a namespace
     */
    public static patchSecret<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        key: string;
        tenant: string;
        apiSecretMetaEe: ApiSecretMetaEe;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'key' },
                    { in: 'path', key: 'tenant' },
                    { key: 'apiSecretMetaEe', map: 'body' }
                ] }]);
        return (options?.client ?? client).patch<PatchSecretResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/secrets/{key}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Files {
    /**
     * Delete a file or directory
     */
    public static deleteFileDirectory<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        path: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).delete<DeleteFileDirectoryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files',
            ...options,
            ...params
        });
    }
    
    /**
     * Get namespace file content
     */
    public static fileContent<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        path: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<FileContentResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a file
     */
    public static createNamespaceFile<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        path: string;
        fileContent?: Blob | File;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' },
                    { in: 'body', key: 'fileContent' }
                ] }]);
        return (options?.client ?? client).post<CreateNamespaceFileResponses, unknown, ThrowOnError>({
            ...formDataBodySerializer,
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files',
            ...options,
            ...params,
            headers: {
                'Content-Type': null,
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Move a file or directory
     */
    public static moveFileDirectory<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        from: string;
        to: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'from' },
                    { in: 'query', key: 'to' }
                ] }]);
        return (options?.client ?? client).put<MoveFileDirectoryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files',
            ...options,
            ...params
        });
    }
    
    /**
     * List directory content
     */
    public static listNamespaceDirectoryFiles<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        path?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<ListNamespaceDirectoryFilesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files/directory',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a directory
     */
    public static createNamespaceDirectory<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        path?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).post<CreateNamespaceDirectoryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files/directory',
            ...options,
            ...params
        });
    }
    
    /**
     * Export namespace files as a ZIP
     */
    public static exportNamespaceFiles<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ExportNamespaceFilesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files/export',
            ...options,
            ...params
        });
    }
    
    /**
     * Find files which path contain the given string in their URI
     */
    public static searchNamespaceFiles<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        q: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' }
                ] }]);
        return (options?.client ?? client).get<SearchNamespaceFilesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Get namespace file stats such as size, creation & modification dates and type
     */
    public static fileMetadatas<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        tenant: string;
        path?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'path' }
                ] }]);
        return (options?.client ?? client).get<FileMetadatasResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/namespaces/{namespace}/files/stats',
            ...options,
            ...params
        });
    }
}

export class Roles {
    /**
     * Create a role
     */
    public static createRole<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamRoleControllerApiRoleCreateOrUpdateRequest: IamRoleControllerApiRoleCreateOrUpdateRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamRoleControllerApiRoleCreateOrUpdateRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateRoleResponses, CreateRoleErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List roles for autocomplete
     */
    public static autocompleteRoles<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        apiAutocomplete: ApiAutocomplete;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'apiAutocomplete', map: 'body' }] }]);
        return (options?.client ?? client).post<AutocompleteRolesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles/autocomplete',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * List roles by ids
     */
    public static listRolesFromGivenIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        apiIds: ApiIds;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'apiIds', map: 'body' }] }]);
        return (options?.client ?? client).post<ListRolesFromGivenIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles/ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for roles
     */
    public static searchRoles<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' }
                ] }]);
        return (options?.client ?? client).get<SearchRolesResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete a role
     */
    public static deleteRole<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteRoleResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a role
     */
    public static role<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<RoleResponses, RoleErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a role
     */
    public static updateRole<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
        iamRoleControllerApiRoleCreateOrUpdateRequest: IamRoleControllerApiRoleCreateOrUpdateRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'iamRoleControllerApiRoleCreateOrUpdateRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateRoleResponses, UpdateRoleErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/roles/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Secrets {
    /**
     * Search secrets of all namespaces
     */
    public static listSecrets<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters: Array<QueryFilter>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<ListSecretsResponses, unknown, ThrowOnError>({
            querySerializer: { parameters: { filters: { array: { explode: false } } } },
            url: '/api/v1/{tenant}/secrets',
            ...options,
            ...params
        });
    }
}

export class SecurityIntegrations {
    /**
     * List all security integrations
     *
     * Superadmin-only.
     */
    public static listSecurityIntegrations<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<ListSecurityIntegrationsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/security-integrations',
            ...options,
            ...params
        });
    }
    
    /**
     * Create a security integration
     *
     * Superadmin-only.
     */
    public static createSecurityIntegration<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        createSecurityIntegrationRequest: CreateSecurityIntegrationRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'createSecurityIntegrationRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateSecurityIntegrationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/security-integrations',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a security integration
     *
     * Superadmin-only.
     */
    public static deleteSecurityIntegration<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteSecurityIntegrationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/security-integrations/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a security integration
     *
     * Superadmin-only.
     */
    public static securityIntegration<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<SecurityIntegrationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/security-integrations/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Disable a security integration
     *
     * Superadmin-only. Disables the specified integration.
     */
    public static disableSecurityIntegration<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).post<DisableSecurityIntegrationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/security-integrations/{id}/disable',
            ...options,
            ...params
        });
    }
    
    /**
     * Enable a security integration
     *
     * Superadmin-only. Enables the specified integration.
     */
    public static enableSecurityIntegration<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).post<EnableSecurityIntegrationResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/security-integrations/{id}/enable',
            ...options,
            ...params
        });
    }
}

export class TenantAccess {
    /**
     * Retrieve users belonging to the tenant
     */
    public static listTenantAccess<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        q?: string | null;
        page: number;
        size: number;
        sort?: Array<string> | null;
        type?: UserType | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'q' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'type' }
                ] }]);
        return (options?.client ?? client).get<ListTenantAccessResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/tenant-access',
            ...options,
            ...params
        });
    }
    
    /**
     * Create tenant access for a user
     *
     * Grants tenant access permissions to a user identified by email
     */
    public static createTenantAccess<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        iamTenantAccessControllerApiCreateTenantAccessRequest: IamTenantAccessControllerApiCreateTenantAccessRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'iamTenantAccessControllerApiCreateTenantAccessRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<CreateTenantAccessResponses, CreateTenantAccessErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/tenant-access',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete tenant access for a user
     *
     * Removes tenant access permissions for the specified user
     */
    public static deleteTenantAccess<ThrowOnError extends boolean = false>(parameters: {
        userId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'userId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).delete<DeleteTenantAccessResponses, DeleteTenantAccessErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/tenant-access/{userId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve tenant access for a user
     *
     * Fetches the tenant access configuration for a given user
     */
    public static tenantAccess<ThrowOnError extends boolean = false>(parameters: {
        userId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'userId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<TenantAccessResponses, TenantAccessErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/tenant-access/{userId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Create tenant access for a user
     *
     * Grants tenant access permissions to a user identified by userId
     */
    public static createTenantAccess1<ThrowOnError extends boolean = false>(parameters: {
        userId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'userId' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).put<CreateTenantAccess1Responses, CreateTenantAccess1Errors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/tenant-access/{userId}',
            ...options,
            ...params
        });
    }
}

export class TestSuites {
    /**
     * Create a test from YAML source
     *
     * Creates a new test from a YAML definition. Requires TEST permission with the CREATE action.
     */
    public static createTestSuite<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<CreateTestSuiteResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete multiple tests by id
     *
     * Deletes a test by namespace and ID. Requires TEST permission with the DELETE action.
     */
    public static deleteTestSuitesByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        testSuiteControllerTestSuiteBulkRequest: TestSuiteControllerTestSuiteBulkRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'testSuiteControllerTestSuiteBulkRequest', map: 'body' }] }]);
        return (options?.client ?? client).delete<DeleteTestSuitesByIdsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Disable multiple tests by id
     *
     * Disable a test by namespace and ID. Requires TEST permission with the UPDATE action.
     */
    public static disableTestSuitesByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        testSuiteControllerTestSuiteBulkRequest: TestSuiteControllerTestSuiteBulkRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'testSuiteControllerTestSuiteBulkRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<DisableTestSuitesByIdsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/disable/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Enable multiple tests by id
     *
     * Enable a test by namespace and ID. Requires TEST permission with the UPDATE action.
     */
    public static enableTestSuitesByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        testSuiteControllerTestSuiteBulkRequest: TestSuiteControllerTestSuiteBulkRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'testSuiteControllerTestSuiteBulkRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<EnableTestSuitesByIdsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/enable/by-ids',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for tests results
     *
     * with optional filtering by namespace, test suite ID and flow ID. Requires TEST permission with the READ action.
     */
    public static searchTestSuitesResults<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        testSuiteId?: string | null;
        namespace?: string | null;
        flowId?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'testSuiteId' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' }
                ] }]);
        return (options?.client ?? client).get<SearchTestSuitesResultsResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/results/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Get tests last result
     *
     * Get multiple tests last result for a query.
     */
    public static testsLastResult<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        testSuiteControllerSearchTestsLastResult: TestSuiteControllerSearchTestsLastResult;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'testSuiteControllerSearchTestsLastResult', map: 'body' }] }]);
        return (options?.client ?? client).post<TestsLastResultResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/results/search/last',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get a test result
     *
     * Get a test result once it was run.
     */
    public static testResult<ThrowOnError extends boolean = false>(parameters: {
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'id' }, { in: 'path', key: 'tenant' }] }]);
        return (options?.client ?? client).get<TestResultResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/results/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Run multiple TestSuites by query
     *
     * Executes all TestSuites impacted by the specified filter. Requires TEST permission with the CREATE action.
     */
    public static runTestSuitesByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        testSuiteServiceRunByQueryRequest: TestSuiteServiceRunByQueryRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'testSuiteServiceRunByQueryRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<RunTestSuitesByQueryResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/run',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for tests
     *
     * Searches for tests with optional filtering by namespace and flow ID. Requires TEST permission with the READ action.
     */
    public static searchTestSuites<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        namespace?: string | null;
        flowId?: string | null;
        includeChildNamespaces: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'namespace' },
                    { in: 'query', key: 'flowId' },
                    { in: 'query', key: 'includeChildNamespaces' }
                ] }]);
        return (options?.client ?? client).get<SearchTestSuitesResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Validate a test
     *
     * Validates a test YAML definition without persisting it. Returns constraint violations if any. Requires TEST permission with the READ action.
     */
    public static validateTestSuite<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<ValidateTestSuiteResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/validate',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a test
     *
     * Deletes a test by namespace and ID. Requires TEST permission with the DELETE action.
     */
    public static deleteTestSuite<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).delete<DeleteTestSuiteResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/{namespace}/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Retrieve a test
     *
     * Retrieves a test by namespace and ID. Requires TEST permission with the READ action.
     */
    public static testSuite<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).get<TestSuiteResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/{namespace}/{id}',
            ...options,
            ...params
        });
    }
    
    /**
     * Update a test from YAML source
     *
     * Updates an existing test with a new YAML definition. Requires TEST permission with the UPDATE action.
     */
    public static updateTestSuite<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        body: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { in: 'body' }
                ] }]);
        return (options?.client ?? client).put<UpdateTestSuiteResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/{namespace}/{id}',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/x-yaml',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Run a full test
     *
     * Executes all test cases in the specified test. Requires TEST permission with the CREATE action.
     */
    public static runTestSuite<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        id: string;
        tenant: string;
        testSuiteControllerRunRequest?: TestSuiteControllerRunRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'id' },
                    { in: 'path', key: 'tenant' },
                    { key: 'testSuiteControllerRunRequest', map: 'body' }
                ] }]);
        return (options?.client ?? client).post<RunTestSuiteResponses, unknown, ThrowOnError>({
            url: '/api/v1/{tenant}/tests/{namespace}/{id}/run',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}

export class Triggers {
    /**
     * Update a trigger
     */
    public static updateTrigger<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        trigger: Trigger;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'trigger', map: 'body' }] }]);
        return (options?.client ?? client).put<UpdateTriggerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete a backfill
     */
    public static deleteBackfill<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        trigger: Trigger;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'trigger', map: 'body' }] }]);
        return (options?.client ?? client).post<DeleteBackfillResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/delete',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Delete backfill for given triggers
     */
    public static deleteBackfillByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<DeleteBackfillByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/delete/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Delete backfill for given triggers
     */
    public static deleteBackfillByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<Trigger>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<DeleteBackfillByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/delete/by-triggers',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Pause a backfill
     */
    public static pauseBackfill<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        trigger: Trigger;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'trigger', map: 'body' }] }]);
        return (options?.client ?? client).put<PauseBackfillResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/pause',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Pause backfill for given triggers
     */
    public static pauseBackfillByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<PauseBackfillByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/pause/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Pause backfill for given triggers
     */
    public static pauseBackfillByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<Trigger>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<PauseBackfillByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/pause/by-triggers',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Unpause a backfill
     */
    public static unpauseBackfill<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        trigger: Trigger;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'trigger', map: 'body' }] }]);
        return (options?.client ?? client).put<UnpauseBackfillResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/unpause',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Unpause backfill for given triggers
     */
    public static unpauseBackfillByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<UnpauseBackfillByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/unpause/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Unpause backfill for given triggers
     */
    public static unpauseBackfillByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<Trigger>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<UnpauseBackfillByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/backfill/unpause/by-triggers',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Search for triggers
     */
    public static searchTriggers<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'filters' }
                ] }]);
        return (options?.client ?? client).get<SearchTriggersResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/search',
            ...options,
            ...params
        });
    }
    
    /**
     * Disable/enable triggers by query parameters
     */
    public static disabledTriggersByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
        disabled: boolean;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'filters' },
                    { in: 'query', key: 'disabled' }
                ] }]);
        return (options?.client ?? client).post<DisabledTriggersByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/set-disabled/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Disable/enable given triggers
     */
    public static disabledTriggersByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        triggerControllerSetDisabledRequest: TriggerControllerSetDisabledRequest;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { key: 'triggerControllerSetDisabledRequest', map: 'body' }] }]);
        return (options?.client ?? client).post<DisabledTriggersByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/set-disabled/by-triggers',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Unlock triggers by query parameters
     */
    public static unlockTriggersByQuery<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        filters?: Array<QueryFilter> | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'query', key: 'filters' }] }]);
        return (options?.client ?? client).post<UnlockTriggersByQueryResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/unlock/by-query',
            ...options,
            ...params
        });
    }
    
    /**
     * Unlock given triggers
     */
    public static unlockTriggersByIds<ThrowOnError extends boolean = false>(parameters: {
        tenant: string;
        body: Array<Trigger>;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'tenant' }, { in: 'body' }] }]);
        return (options?.client ?? client).post<UnlockTriggersByIdsResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/unlock/by-triggers',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
    
    /**
     * Get all triggers for a flow
     */
    public static searchTriggersForFlow<ThrowOnError extends boolean = false>(parameters: {
        namespace: string | null;
        flowId: string | null;
        tenant: string;
        page: number;
        size: number;
        sort?: Array<string> | null;
        q?: string | null;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'tenant' },
                    { in: 'query', key: 'page' },
                    { in: 'query', key: 'size' },
                    { in: 'query', key: 'sort' },
                    { in: 'query', key: 'q' }
                ] }]);
        return (options?.client ?? client).get<SearchTriggersForFlowResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/{namespace}/{flowId}',
            ...options,
            ...params
        });
    }
    
    /**
     * Restart a trigger
     */
    public static restartTrigger<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        triggerId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'triggerId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).post<RestartTriggerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/{namespace}/{flowId}/{triggerId}/restart',
            ...options,
            ...params
        });
    }
    
    /**
     * Unlock a trigger
     */
    public static unlockTrigger<ThrowOnError extends boolean = false>(parameters: {
        namespace: string;
        flowId: string;
        triggerId: string;
        tenant: string;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [
                    { in: 'path', key: 'namespace' },
                    { in: 'path', key: 'flowId' },
                    { in: 'path', key: 'triggerId' },
                    { in: 'path', key: 'tenant' }
                ] }]);
        return (options?.client ?? client).post<UnlockTriggerResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'basic', type: 'http' }],
            url: '/api/v1/{tenant}/triggers/{namespace}/{flowId}/{triggerId}/unlock',
            ...options,
            ...params
        });
    }
}

export class Login {
    public static login<ThrowOnError extends boolean = false>(parameters: {
        usernamePasswordCredentials: UsernamePasswordCredentials;
    }, options?: Options<never, ThrowOnError>) {
        const params = buildClientParams([parameters], [{ args: [{ key: 'usernamePasswordCredentials', map: 'body' }] }]);
        return (options?.client ?? client).post<LoginResponses, unknown, ThrowOnError>({
            url: '/login',
            ...options,
            ...params,
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
                ...params.headers
            }
        });
    }
}
