/**
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import BulkResponse from '../model/BulkResponse';
import ConcurrencyLimit from '../model/ConcurrencyLimit';
import Flow from '../model/Flow';
import FlowControllerTaskValidationType from '../model/FlowControllerTaskValidationType';
import FlowGraph from '../model/FlowGraph';
import FlowInterface from '../model/FlowInterface';
import FlowTopologyGraph from '../model/FlowTopologyGraph';
import FlowWithSource from '../model/FlowWithSource';
import IdWithNamespace from '../model/IdWithNamespace';
import PagedResultsConcurrencyLimit from '../model/PagedResultsConcurrencyLimit';
import PagedResultsFlow from '../model/PagedResultsFlow';
import PagedResultsSearchResultFlow from '../model/PagedResultsSearchResultFlow';
import QueryFilter from '../model/QueryFilter';
import Task from '../model/Task';
import ValidateConstraintViolation from '../model/ValidateConstraintViolation';

/**
* Flows service.
* @module api/FlowsApi
* @version 1.0.2
*/
export default class FlowsApi {

    /**
    * Constructs a new FlowsApi. 
    * @alias module:api/FlowsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }




            

    /**
    * Update from multiples yaml sources
    * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
    * @param {Boolean} _delete If missing flow should be deleted
    * @param {Boolean} allowNamespaceChild If namespace child should are allowed to be updated
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {String} [namespace] The namespace where to update flows
    * @param {String} [body] A list of flows source code splitted with \"---\"

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowInterface>} and HTTP response
    */
    bulkUpdateFlowsWithHttpInfo(_delete, allowNamespaceChild, tenant, opts) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter '_delete' is set
      if (_delete === undefined || _delete === null) {
        throw new Error("Missing the required parameter '_delete' when calling bulkUpdateFlows");
      }
      // verify the required parameter 'allowNamespaceChild' is set
      if (allowNamespaceChild === undefined || allowNamespaceChild === null) {
        throw new Error("Missing the required parameter 'allowNamespaceChild' when calling bulkUpdateFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling bulkUpdateFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'delete': _delete,
        'namespace': opts['namespace'],
        'allowNamespaceChild': allowNamespaceChild
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [FlowInterface];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/bulk', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Update from multiples yaml sources
    * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
    * @param {Boolean} _delete If missing flow should be deleted
    * @param {Boolean} allowNamespaceChild If namespace child should are allowed to be updated
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {String} opts.namespace The namespace where to update flows
    * @param {String} opts.body A list of flows source code splitted with \"---\"

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowInterface>}
    */
    bulkUpdateFlows(_delete, allowNamespaceChild, tenant, opts) {
      return this.bulkUpdateFlowsWithHttpInfo(_delete, allowNamespaceChild, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Create a flow from yaml source
    * @param {String} tenant 
    * @param {String} body The flow source code

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowWithSource} and HTTP response
    */
    createFlowWithHttpInfo(tenant, body) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling createFlow");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createFlow");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowWithSource;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Create a flow from yaml source
    * @param {String} tenant 
    * @param {String} body The flow source code

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowWithSource}
    */
    createFlow(tenant, body) {
      return this.createFlowWithHttpInfo(tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Delete a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
    */
    deleteFlowWithHttpInfo(namespace, id, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Delete a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}
    */
    deleteFlow(namespace, id, tenant) {
      return this.deleteFlowWithHttpInfo(namespace, id, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Delete flows by their IDs.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
    */
    deleteFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling deleteFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/delete/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Delete flows by their IDs.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
    */
    deleteFlowsByIds(tenant, idWithNamespace) {
      return this.deleteFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Delete flows returned by the query parameters.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} [filters] Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
    */
    deleteFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/delete/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Delete flows returned by the query parameters.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} opts.filters Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
    */
    deleteFlowsByQuery(tenant, opts) {
      return this.deleteFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Disable flows by their IDs.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
    */
    disableFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling disableFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling disableFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/disable/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Disable flows by their IDs.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
    */
    disableFlowsByIds(tenant, idWithNamespace) {
      return this.disableFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Disable flows returned by the query parameters.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} [filters] Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
    */
    disableFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling disableFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/disable/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Disable flows returned by the query parameters.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} opts.filters Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
    */
    disableFlowsByQuery(tenant, opts) {
      return this.disableFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Enable flows by their IDs.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
    */
    enableFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling enableFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling enableFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/enable/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Enable flows by their IDs.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
    */
    enableFlowsByIds(tenant, idWithNamespace) {
      return this.enableFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Enable flows returned by the query parameters.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} [filters] Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
    */
    enableFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling enableFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/enable/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Enable flows returned by the query parameters.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} opts.filters Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
    */
    enableFlowsByQuery(tenant, opts) {
      return this.enableFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Export flows as a ZIP archive of yaml sources.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Blob} and HTTP response
    */
    exportFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling exportFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/export/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Export flows as a ZIP archive of yaml sources.
    * @param {String} tenant 
    * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Blob}
    */
    exportFlowsByIds(tenant, idWithNamespace) {
      return this.exportFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Export flows as a ZIP archive of yaml sources.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} [filters] Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Blob} and HTTP response
    */
    exportFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/export/by-query', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Export flows as a ZIP archive of yaml sources.
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<module:model/QueryFilter>} opts.filters Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Blob}
    */
    exportFlowsByQuery(tenant, opts) {
      return this.exportFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {Boolean} source Include the source code
    * @param {Boolean} allowDeleted Get flow even if deleted
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} [revision] Get latest revision by default

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowWithSource} and HTTP response
    */
    flowWithHttpInfo(namespace, id, source, allowDeleted, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling flow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling flow");
      }
      // verify the required parameter 'source' is set
      if (source === undefined || source === null) {
        throw new Error("Missing the required parameter 'source' when calling flow");
      }
      // verify the required parameter 'allowDeleted' is set
      if (allowDeleted === undefined || allowDeleted === null) {
        throw new Error("Missing the required parameter 'allowDeleted' when calling flow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling flow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'source': source,
        'revision': opts['revision'],
        'allowDeleted': allowDeleted
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowWithSource;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {Boolean} source Include the source code
    * @param {Boolean} allowDeleted Get flow even if deleted
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} opts.revision Get latest revision by default

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowWithSource}
    */
    flow(namespace, id, source, allowDeleted, tenant, opts) {
      return this.flowWithHttpInfo(namespace, id, source, allowDeleted, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get flow dependencies
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {Boolean} destinationOnly If true, list only destination dependencies, otherwise list also source dependencies
    * @param {Boolean} expandAll If true, expand all dependencies recursively
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowTopologyGraph} and HTTP response
    */
    flowDependenciesWithHttpInfo(namespace, id, destinationOnly, expandAll, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling flowDependencies");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling flowDependencies");
      }
      // verify the required parameter 'destinationOnly' is set
      if (destinationOnly === undefined || destinationOnly === null) {
        throw new Error("Missing the required parameter 'destinationOnly' when calling flowDependencies");
      }
      // verify the required parameter 'expandAll' is set
      if (expandAll === undefined || expandAll === null) {
        throw new Error("Missing the required parameter 'expandAll' when calling flowDependencies");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling flowDependencies");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'destinationOnly': destinationOnly,
        'expandAll': expandAll
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowTopologyGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/dependencies', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get flow dependencies
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {Boolean} destinationOnly If true, list only destination dependencies, otherwise list also source dependencies
    * @param {Boolean} expandAll If true, expand all dependencies recursively
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowTopologyGraph}
    */
    flowDependencies(namespace, id, destinationOnly, expandAll, tenant) {
      return this.flowDependenciesWithHttpInfo(namespace, id, destinationOnly, expandAll, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Retrieve flow dependencies
    * @param {String} namespace The flow namespace
    * @param {Boolean} destinationOnly if true, list only destination dependencies, otherwise list also source dependencies
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowTopologyGraph} and HTTP response
    */
    flowDependenciesFromNamespaceWithHttpInfo(namespace, destinationOnly, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling flowDependenciesFromNamespace");
      }
      // verify the required parameter 'destinationOnly' is set
      if (destinationOnly === undefined || destinationOnly === null) {
        throw new Error("Missing the required parameter 'destinationOnly' when calling flowDependenciesFromNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling flowDependenciesFromNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
        'destinationOnly': destinationOnly
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowTopologyGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/namespaces/{namespace}/dependencies', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Retrieve flow dependencies
    * @param {String} namespace The flow namespace
    * @param {Boolean} destinationOnly if true, list only destination dependencies, otherwise list also source dependencies
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowTopologyGraph}
    */
    flowDependenciesFromNamespace(namespace, destinationOnly, tenant) {
      return this.flowDependenciesFromNamespaceWithHttpInfo(namespace, destinationOnly, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Generate a graph for a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} [revision] The flow revision
    * @param {Array.<String>} [subflows] The subflow tasks to display

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowGraph} and HTTP response
    */
    generateFlowGraphWithHttpInfo(namespace, id, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling generateFlowGraph");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling generateFlowGraph");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateFlowGraph");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision'],
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/graph', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Generate a graph for a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} opts.revision The flow revision
    * @param {Array.<String>} opts.subflows The subflow tasks to display

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowGraph}
    */
    generateFlowGraph(namespace, id, tenant, opts) {
      return this.generateFlowGraphWithHttpInfo(namespace, id, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Generate a graph for a flow source
    * @param {String} tenant 
    * @param {String} body The flow source code
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} [subflows] The subflow tasks to display

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowGraph} and HTTP response
    */
    generateFlowGraphFromSourceWithHttpInfo(tenant, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateFlowGraphFromSource");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling generateFlowGraphFromSource");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/graph', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Generate a graph for a flow source
    * @param {String} tenant 
    * @param {String} body The flow source code
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} opts.subflows The subflow tasks to display

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowGraph}
    */
    generateFlowGraphFromSource(tenant, body, opts) {
      return this.generateFlowGraphFromSourceWithHttpInfo(tenant, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 
    * @param {Boolean} failOnError If should fail on invalid flows
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {File} [fileUpload] The file to import, can be a ZIP archive or a multi-objects YAML file

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
    */
    importFlowsWithHttpInfo(failOnError, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'failOnError' is set
      if (failOnError === undefined || failOnError === null) {
        throw new Error("Missing the required parameter 'failOnError' when calling importFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling importFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'failOnError': failOnError
      };
      let headerParams = {
      };
      let formParams = {
        'fileUpload': opts['fileUpload']
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/import', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 
    * @param {Boolean} failOnError If should fail on invalid flows
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {File} opts.fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
    */
    importFlows(failOnError, tenant, opts) {
      return this.importFlowsWithHttpInfo(failOnError, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * List all distinct namespaces
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {String} [q] A string filter

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
    */
    listDistinctNamespacesWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listDistinctNamespaces");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'q': opts['q']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/distinct-namespaces', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * List all distinct namespaces
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {String} opts.q A string filter

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
    */
    listDistinctNamespaces(tenant, opts) {
      return this.listDistinctNamespacesWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get revisions for a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowWithSource>} and HTTP response
    */
    listFlowRevisionsWithHttpInfo(namespace, id, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listFlowRevisions");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling listFlowRevisions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listFlowRevisions");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [FlowWithSource];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/revisions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get revisions for a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowWithSource>}
    */
    listFlowRevisions(namespace, id, tenant) {
      return this.listFlowRevisionsWithHttpInfo(namespace, id, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Retrieve all flows from a given namespace
    * @param {String} namespace Namespace to filter flows
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Flow>} and HTTP response
    */
    listFlowsByNamespaceWithHttpInfo(namespace, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listFlowsByNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listFlowsByNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Flow];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Retrieve all flows from a given namespace
    * @param {String} namespace Namespace to filter flows
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Flow>}
    */
    listFlowsByNamespace(namespace, tenant) {
      return this.listFlowsByNamespaceWithHttpInfo(namespace, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Search for flow concurrency limits
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsConcurrencyLimit} and HTTP response
    */
    searchConcurrencyLimitsWithHttpInfo(tenant) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchConcurrencyLimits");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsConcurrencyLimit;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/concurrency-limit/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Search for flow concurrency limits
    * @param {String} tenant 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsConcurrencyLimit}
    */
    searchConcurrencyLimits(tenant) {
      return this.searchConcurrencyLimitsWithHttpInfo(tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Search for flows
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} [sort] The sort of current page
    * @param {Array.<module:model/QueryFilter>} [filters] Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsFlow} and HTTP response
    */
    searchFlowsWithHttpInfo(page, size, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchFlows");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsFlow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Search for flows
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} opts.sort The sort of current page
    * @param {Array.<module:model/QueryFilter>} opts.filters Filters

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsFlow}
    */
    searchFlows(page, size, tenant, opts) {
      return this.searchFlowsWithHttpInfo(page, size, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Search for flows source code
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} [sort] The sort of current page
    * @param {String} [q] A string filter
    * @param {String} [namespace] A namespace filter prefix

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsSearchResultFlow} and HTTP response
    */
    searchFlowsBySourceCodeWithHttpInfo(page, size, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchFlowsBySourceCode");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchFlowsBySourceCode");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchFlowsBySourceCode");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'q': opts['q'],
        'namespace': opts['namespace']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsSearchResultFlow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/source', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Search for flows source code
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} opts.sort The sort of current page
    * @param {String} opts.q A string filter
    * @param {String} opts.namespace A namespace filter prefix

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsSearchResultFlow}
    */
    searchFlowsBySourceCode(page, size, tenant, opts) {
      return this.searchFlowsBySourceCodeWithHttpInfo(page, size, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get a flow task
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} taskId The task id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} [revision] The flow revision

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Task} and HTTP response
    */
    taskFromFlowWithHttpInfo(namespace, id, taskId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling taskFromFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling taskFromFlow");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling taskFromFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling taskFromFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'taskId': taskId,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Task;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get a flow task
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} taskId The task id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} opts.revision The flow revision

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Task}
    */
    taskFromFlow(namespace, id, taskId, tenant, opts) {
      return this.taskFromFlowWithHttpInfo(namespace, id, taskId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Update a flow concurrency limit
    * @param {String} flowId 
    * @param {String} namespace 
    * @param {String} tenant 
    * @param {module:model/ConcurrencyLimit} concurrencyLimit 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ConcurrencyLimit} and HTTP response
    */
    updateConcurrencyLimitWithHttpInfo(flowId, namespace, tenant, concurrencyLimit) {
      let postBody = concurrencyLimit;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling updateConcurrencyLimit");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateConcurrencyLimit");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateConcurrencyLimit");
      }
      // verify the required parameter 'concurrencyLimit' is set
      if (concurrencyLimit === undefined || concurrencyLimit === null) {
        throw new Error("Missing the required parameter 'concurrencyLimit' when calling updateConcurrencyLimit");
      }

      let pathParams = {
        'flowId': flowId,
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ConcurrencyLimit;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/concurrency-limit/{namespace}/{flowId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Update a flow concurrency limit
    * @param {String} flowId 
    * @param {String} namespace 
    * @param {String} tenant 
    * @param {module:model/ConcurrencyLimit} concurrencyLimit 

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ConcurrencyLimit}
    */
    updateConcurrencyLimit(flowId, namespace, tenant, concurrencyLimit) {
      return this.updateConcurrencyLimitWithHttpInfo(flowId, namespace, tenant, concurrencyLimit)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Update a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 
    * @param {String} body The flow source code

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowWithSource} and HTTP response
    */
    updateFlowWithHttpInfo(namespace, id, tenant, body) {
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateFlow");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowWithSource;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Update a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} tenant 
    * @param {String} body The flow source code

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowWithSource}
    */
    updateFlow(namespace, id, tenant, body) {
      return this.updateFlowWithHttpInfo(namespace, id, tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Update a complete namespace from yaml source
    * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
    * @param {String} namespace The flow namespace
    * @param {Boolean} _delete If missing flow should be deleted
    * @param {String} tenant 
    * @param {String} body A list of flows source code

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowInterface>} and HTTP response
    */
    updateFlowsInNamespaceWithHttpInfo(namespace, _delete, tenant, body) {
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateFlowsInNamespace");
      }
      // verify the required parameter '_delete' is set
      if (_delete === undefined || _delete === null) {
        throw new Error("Missing the required parameter '_delete' when calling updateFlowsInNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateFlowsInNamespace");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateFlowsInNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
        'delete': _delete
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [FlowInterface];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Update a complete namespace from yaml source
    * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
    * @param {String} namespace The flow namespace
    * @param {Boolean} _delete If missing flow should be deleted
    * @param {String} tenant 
    * @param {String} body A list of flows source code

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowInterface>}
    */
    updateFlowsInNamespace(namespace, _delete, tenant, body) {
      return this.updateFlowsInNamespaceWithHttpInfo(namespace, _delete, tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Update a single task on a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} taskId The task id
    * @param {String} tenant 
    * @param {module:model/Task} task The task

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Flow} and HTTP response
    */
    updateTaskWithHttpInfo(namespace, id, taskId, tenant, task) {
      let postBody = task;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateTask");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateTask");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling updateTask");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateTask");
      }
      // verify the required parameter 'task' is set
      if (task === undefined || task === null) {
        throw new Error("Missing the required parameter 'task' when calling updateTask");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'taskId': taskId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Flow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Update a single task on a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} taskId The task id
    * @param {String} tenant 
    * @param {module:model/Task} task The task

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Flow}
    */
    updateTask(namespace, id, taskId, tenant, task) {
      return this.updateTaskWithHttpInfo(namespace, id, taskId, tenant, task)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Validate a list of flows
    * @param {String} tenant 
    * @param {String} body A list of flows source code in a single string

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/ValidateConstraintViolation>} and HTTP response
    */
    validateFlowsWithHttpInfo(tenant, body) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateFlows");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [ValidateConstraintViolation];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Validate a list of flows
    * @param {String} tenant 
    * @param {String} body A list of flows source code in a single string

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/ValidateConstraintViolation>}
    */
    validateFlows(tenant, body) {
      return this.validateFlowsWithHttpInfo(tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Validate a task
    * @param {module:model/FlowControllerTaskValidationType} section The type of task
    * @param {String} tenant 
    * @param {Object.<String, Object>} body A task definition that can be from tasks or triggers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ValidateConstraintViolation} and HTTP response
    */
    validateTaskWithHttpInfo(section, tenant, body) {
      let postBody = body;
      // verify the required parameter 'section' is set
      if (section === undefined || section === null) {
        throw new Error("Missing the required parameter 'section' when calling validateTask");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateTask");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateTask");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'section': section
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml', 'application/json'];
      let accepts = ['application/json'];
      let returnType = ValidateConstraintViolation;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate/task', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Validate a task
    * @param {module:model/FlowControllerTaskValidationType} section The type of task
    * @param {String} tenant 
    * @param {Object.<String, Object>} body A task definition that can be from tasks or triggers

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ValidateConstraintViolation}
    */
    validateTask(section, tenant, body) {
      return this.validateTaskWithHttpInfo(section, tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Validate trigger
    * @param {String} tenant 
    * @param {Object.<String, Object>} body The trigger

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ValidateConstraintViolation} and HTTP response
    */
    validateTriggerWithHttpInfo(tenant, body) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateTrigger");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateTrigger");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ValidateConstraintViolation;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate/trigger', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Validate trigger
    * @param {String} tenant 
    * @param {Object.<String, Object>} body The trigger

    * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ValidateConstraintViolation}
    */
    validateTrigger(tenant, body) {
      return this.validateTriggerWithHttpInfo(tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }








}
