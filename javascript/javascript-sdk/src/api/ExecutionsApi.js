/**
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import polyfilledEventSource from "@sanity/eventsource"
import BulkErrorResponse from '../model/BulkErrorResponse';
import BulkResponse from '../model/BulkResponse';
import EventExecution from '../model/EventExecution';
import EventExecutionStatusEvent from '../model/EventExecutionStatusEvent';
import Execution from '../model/Execution';
import ExecutionControllerExecutionResponse from '../model/ExecutionControllerExecutionResponse';
import ExecutionControllerLastExecutionResponse from '../model/ExecutionControllerLastExecutionResponse';
import ExecutionControllerSetLabelsByIdsRequest from '../model/ExecutionControllerSetLabelsByIdsRequest';
import ExecutionControllerStateRequest from '../model/ExecutionControllerStateRequest';
import ExecutionControllerWebhookResponse from '../model/ExecutionControllerWebhookResponse';
import ExecutionKind from '../model/ExecutionKind';
import ExecutionRepositoryInterfaceFlowFilter from '../model/ExecutionRepositoryInterfaceFlowFilter';
import FileMetas from '../model/FileMetas';
import FlowForExecution from '../model/FlowForExecution';
import FlowGraph from '../model/FlowGraph';
import Label from '../model/Label';
import PagedResultsExecution from '../model/PagedResultsExecution';
import QueryFilter from '../model/QueryFilter';
import StateType from '../model/StateType';

/**
* Executions service.
* @module api/ExecutionsApi
*/
export default class ExecutionsApi {

    /**
    * Constructs a new ExecutionsApi. 
    * @alias module:api/ExecutionsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }




            

    /**
    * Create a new execution for a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {Boolean} wait If the server will wait the end of the execution
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} [labels] The labels as a list of 'key:value'
    * @param {Number} [revision] The flow revision or latest if null
    * @param {Date} [scheduleDate] Schedule the flow on a specific date
    * @param {String} [breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
    * @param {module:model/ExecutionKind} [kind] Specific execution kind
    * @param {Object} [formData] Extra multipart fields/files (key → value). Values may be strings, File/Blob (browser) or Buffer/stream (Node).
    
    * @return {Promise<ExecutionControllerExecutionResponse>}
    */
    createExecutionWithHttpInfo(namespace, id, wait, tenant, opts, formData) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createExecution");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createExecution");
      }
      // verify the required parameter 'wait' is set
      if (wait === undefined || wait === null) {
        throw new Error("Missing the required parameter 'wait' when calling createExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling createExecution");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi'),
        'wait': wait,
        'revision': opts['revision'],
        'scheduleDate': opts['scheduleDate'],
        'breakpoints': opts['breakpoints'],
        'kind': opts['kind']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = ExecutionControllerExecutionResponse;
      // Merge explicit formData parameter (only for multipart ops)
      if (formData && typeof formData === 'object') {
        for (const [k, v] of Object.entries(formData)) {
          if (v !== undefined && v !== null) {
            formParams[k] = v;
          }
        }
      }
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{namespace}/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Create a new execution for a flow
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {Boolean} wait If the server will wait the end of the execution
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<String>} [opts.labels] The labels as a list of 'key:value'
    * @param {Number} [opts.revision] The flow revision or latest if null
    * @param {Date} [opts.scheduleDate] Schedule the flow on a specific date
    * @param {String} [opts.breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
    * @param {module:model/ExecutionKind} [opts.kind] Specific execution kind
    * @param {Object} [formData] Extra multipart fields/files (key → value). Values may be strings, File/Blob (browser) or Buffer/stream (Node).
    
    * @return {Promise<ExecutionControllerExecutionResponse>}
    */
    createExecution(namespace, id, wait, tenant, opts, formData) {
      return this.createExecutionWithHttpInfo(namespace, id, wait, tenant, opts, formData)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Delete an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Boolean} [deleteLogs = true)] Whether to delete execution logs
    * @param {Boolean} [deleteMetrics = true)] Whether to delete execution metrics
    * @param {Boolean} [deleteStorage = true)] Whether to delete execution files in the internal storage

    * @return {Promise<  >}
    */
    deleteExecutionWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling deleteExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'deleteLogs': opts['deleteLogs'],
        'deleteMetrics': opts['deleteMetrics'],
        'deleteStorage': opts['deleteStorage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Delete an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Boolean} [opts.deleteLogs (default to true)] Whether to delete execution logs
    * @param {Boolean} [opts.deleteMetrics (default to true)] Whether to delete execution metrics
    * @param {Boolean} [opts.deleteStorage (default to true)] Whether to delete execution files in the internal storage

    * @return {Promise<  >}
    */
    deleteExecution(executionId, tenant, opts) {
      return this.deleteExecutionWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Delete a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The execution id
    * @param {Object} opts Optional parameters
    * @param {Boolean} [includeNonTerminated = false)] Whether to delete non-terminated executions
    * @param {Boolean} [deleteLogs = true)] Whether to delete execution logs
    * @param {Boolean} [deleteMetrics = true)] Whether to delete execution metrics
    * @param {Boolean} [deleteStorage = true)] Whether to delete execution files in the internal storage

    * @return {Promise<BulkResponse>}
    */
    deleteExecutionsByIdsWithHttpInfo(tenant, requestBody, opts) {
      opts = opts || {};
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling deleteExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'includeNonTerminated': opts['includeNonTerminated'],
        'deleteLogs': opts['deleteLogs'],
        'deleteMetrics': opts['deleteMetrics'],
        'deleteStorage': opts['deleteStorage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Delete a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The execution id
    * @param {Object} [opts] Optional parameters
    * @param {Boolean} [opts.includeNonTerminated (default to false)] Whether to delete non-terminated executions
    * @param {Boolean} [opts.deleteLogs (default to true)] Whether to delete execution logs
    * @param {Boolean} [opts.deleteMetrics (default to true)] Whether to delete execution metrics
    * @param {Boolean} [opts.deleteStorage (default to true)] Whether to delete execution files in the internal storage

    * @return {Promise<BulkResponse>}
    */
    deleteExecutionsByIds(tenant, requestBody, opts) {
      return this.deleteExecutionsByIdsWithHttpInfo(tenant, requestBody, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Delete executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters
    * @param {Boolean} [includeNonTerminated = false)] Whether to delete non-terminated executions
    * @param {Boolean} [deleteLogs = true)] Whether to delete execution logs
    * @param {Boolean} [deleteMetrics = true)] Whether to delete execution metrics
    * @param {Boolean} [deleteStorage = true)] Whether to delete execution files in the internal storage

    * @return {Promise< Object >}
    */
    deleteExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'includeNonTerminated': opts['includeNonTerminated'],
        'deleteLogs': opts['deleteLogs'],
        'deleteMetrics': opts['deleteMetrics'],
        'deleteStorage': opts['deleteStorage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Delete executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters
    * @param {Boolean} [opts.includeNonTerminated (default to false)] Whether to delete non-terminated executions
    * @param {Boolean} [opts.deleteLogs (default to true)] Whether to delete execution logs
    * @param {Boolean} [opts.deleteMetrics (default to true)] Whether to delete execution metrics
    * @param {Boolean} [opts.deleteStorage (default to true)] Whether to delete execution files in the internal storage

    * @return {Promise< Object >}
    */
    deleteExecutionsByQuery(tenant, opts) {
      return this.deleteExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Download file for an execution
    * @param {String} executionId The execution id
    * @param {String} path The internal storage uri
    * @param {String} tenant 

    * @return {Promise< File >}
    */
    downloadFileFromExecutionWithHttpInfo(executionId, path, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling downloadFileFromExecution");
      }
      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling downloadFileFromExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling downloadFileFromExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'path': path
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/file', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Download file for an execution
    * @param {String} executionId The execution id
    * @param {String} path The internal storage uri
    * @param {String} tenant 

    * @return {Promise< File >}
    */
    downloadFileFromExecution(executionId, path, tenant) {
      return this.downloadFileFromExecutionWithHttpInfo(executionId, path, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    executionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling execution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling execution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    execution(executionId, tenant) {
      return this.executionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Generate a graph for an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} [subflows] The subflow tasks to display

    * @return {Promise<FlowGraph>}
    */
    executionFlowGraphWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling executionFlowGraph");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling executionFlowGraph");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/graph', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Generate a graph for an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<String>} [opts.subflows] The subflow tasks to display

    * @return {Promise<FlowGraph>}
    */
    executionFlowGraph(executionId, tenant, opts) {
      return this.executionFlowGraphWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Export all executions as a streamed CSV file
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} filters A list of filters
    * @param {String} tenant 

    * @return {Promise< Array.<Object> >}
    */
    exportExecutionsWithHttpInfo(filters, tenant) {
      let postBody = null;
      // verify the required parameter 'filters' is set
      if (filters === undefined || filters === null) {
        throw new Error("Missing the required parameter 'filters' when calling exportExecutions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportExecutions");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(filters, 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['text/csv'];
      let returnType = [Object];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/export/by-query/csv', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Export all executions as a streamed CSV file
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} filters A list of filters
    * @param {String} tenant 

    * @return {Promise< Array.<Object> >}
    */
    exportExecutions(filters, tenant) {
      return this.exportExecutionsWithHttpInfo(filters, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get file meta information for an execution
    * @param {String} executionId The execution id
    * @param {String} path The internal storage uri
    * @param {String} tenant 

    * @return {Promise<FileMetas>}
    */
    fileMetadatasFromExecutionWithHttpInfo(executionId, path, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling fileMetadatasFromExecution");
      }
      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling fileMetadatasFromExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling fileMetadatasFromExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'path': path
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FileMetas;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/file/metas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get file meta information for an execution
    * @param {String} executionId The execution id
    * @param {String} path The internal storage uri
    * @param {String} tenant 

    * @return {Promise<FileMetas>}
    */
    fileMetadatasFromExecution(executionId, path, tenant) {
      return this.fileMetadatasFromExecutionWithHttpInfo(executionId, path, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get flow information's for an execution
    * @param {String} namespace The namespace of the flow
    * @param {String} flowId The flow id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} [revision] The flow revision

    * @return {Promise<FlowForExecution>}
    */
    flowFromExecutionWithHttpInfo(namespace, flowId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling flowFromExecution");
      }
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling flowFromExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling flowFromExecution");
      }

      let pathParams = {
        'namespace': namespace,
        'flowId': flowId,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowForExecution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/flows/{namespace}/{flowId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get flow information's for an execution
    * @param {String} namespace The namespace of the flow
    * @param {String} flowId The flow id
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Number} [opts.revision] The flow revision

    * @return {Promise<FlowForExecution>}
    */
    flowFromExecution(namespace, flowId, tenant, opts) {
      return this.flowFromExecutionWithHttpInfo(namespace, flowId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get flow information's for an execution
    * @param {String} executionId The execution that you want flow informations
    * @param {String} tenant 

    * @return {Promise<FlowForExecution>}
    */
    flowFromExecutionByIdWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling flowFromExecutionById");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling flowFromExecutionById");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowForExecution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/flow', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get flow information's for an execution
    * @param {String} executionId The execution that you want flow informations
    * @param {String} tenant 

    * @return {Promise<FlowForExecution>}
    */
    flowFromExecutionById(executionId, tenant) {
      return this.flowFromExecutionByIdWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }












    /**
     * Custom implementation for following execution via Server-Sent Events (SSE)
     * @param {String} executionId
     * @param {Boolean} destinationOnly
     * @param {Boolean} expandAll
     * @param {String} tenant
     * @param {Object} [options] Optional parameters
     * @param {Function} [options.EventSource] Custom EventSource constructor (for Node.js environment)
     * @return {EventSource} EventSource object to listen to execution events
     */
    followDependenciesExecutions(executionId, destinationOnly, expandAll, tenant, options = {} ) {
      // an EventSource implementation must be provided in Node.js environment
      // in browser environment, the native EventSource cannot be used ieither since it cannot
      // send the right http headers (like Authorization)
      const EventSourceImpl = options.EventSource ?? polyfilledEventSource;
      if (!EventSourceImpl) {
        throw new Error("EventSource implementation must be provided in options.EventSource");
      }
        let url = this.apiClient.buildUrl('/api/v1/{tenant}/executions/{executionId}/follow-dependencies', {
            'executionId': executionId,
            'tenant': tenant
        });

        const headers = this.apiClient.buildAuthHeaders(['basicAuth', 'bearerAuth']);

        // create EventSource
        const eventSource = new EventSourceImpl(url, { headers });
        return eventSource;
    }




    /**
     * Custom implementation for following execution via Server-Sent Events (SSE)
     * @param {String} executionId
     * @param {String} tenant
     * @param {Object} [options] Optional parameters
     * @param {Function} [options.EventSource] Custom EventSource constructor (for Node.js environment)
     * @return {EventSource} EventSource object to listen to execution events
     */
    followExecution(executionId, tenant, options = {} ) {
      // an EventSource implementation must be provided in Node.js environment
      // in browser environment, the native EventSource cannot be used ieither since it cannot
      // send the right http headers (like Authorization)
      const EventSourceImpl = options.EventSource ?? polyfilledEventSource;
      if (!EventSourceImpl) {
        throw new Error("EventSource implementation must be provided in options.EventSource");
      }
        let url = this.apiClient.buildUrl('/api/v1/{tenant}/executions/{executionId}/follow', {
            'executionId': executionId,
            'tenant': tenant
        });

        const headers = this.apiClient.buildAuthHeaders(['basicAuth', 'bearerAuth']);

        // create EventSource
        const eventSource = new EventSourceImpl(url, { headers });
        return eventSource;
    }





            

    /**
    * Force run a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    forceRunByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling forceRunByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling forceRunByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/force-run/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Force run a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    forceRunByIds(tenant, requestBody) {
      return this.forceRunByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Force run an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    forceRunExecutionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling forceRunExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling forceRunExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/force-run', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Force run an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    forceRunExecution(executionId, tenant) {
      return this.forceRunExecutionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Force run executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise< Object >}
    */
    forceRunExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling forceRunExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/force-run/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Force run executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise< Object >}
    */
    forceRunExecutionsByQuery(tenant, opts) {
      return this.forceRunExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Kill an execution
    * @param {String} executionId The execution id
    * @param {Boolean} isOnKillCascade Specifies whether killing the execution also kill all subflow executions.
    * @param {String} tenant 

    * @return {Promise< Object >}
    */
    killExecutionWithHttpInfo(executionId, isOnKillCascade, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling killExecution");
      }
      // verify the required parameter 'isOnKillCascade' is set
      if (isOnKillCascade === undefined || isOnKillCascade === null) {
        throw new Error("Missing the required parameter 'isOnKillCascade' when calling killExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling killExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'isOnKillCascade': isOnKillCascade
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['text/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/kill', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Kill an execution
    * @param {String} executionId The execution id
    * @param {Boolean} isOnKillCascade Specifies whether killing the execution also kill all subflow executions.
    * @param {String} tenant 

    * @return {Promise< Object >}
    */
    killExecution(executionId, isOnKillCascade, tenant) {
      return this.killExecutionWithHttpInfo(executionId, isOnKillCascade, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Kill a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    killExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling killExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling killExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/kill/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Kill a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    killExecutionsByIds(tenant, requestBody) {
      return this.killExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Kill executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise< Object >}
    */
    killExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling killExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/kill/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Kill executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise< Object >}
    */
    killExecutionsByQuery(tenant, opts) {
      return this.killExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Get the latest execution for given flows
    * @param {String} tenant 
    * @param {Array.<module:model/ExecutionRepositoryInterfaceFlowFilter>} executionRepositoryInterfaceFlowFilter 

    * @return {Promise<Array.<ExecutionControllerLastExecutionResponse>>}
    */
    latestExecutionsWithHttpInfo(tenant, executionRepositoryInterfaceFlowFilter) {
      let postBody = executionRepositoryInterfaceFlowFilter;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling latestExecutions");
      }
      // verify the required parameter 'executionRepositoryInterfaceFlowFilter' is set
      if (executionRepositoryInterfaceFlowFilter === undefined || executionRepositoryInterfaceFlowFilter === null) {
        throw new Error("Missing the required parameter 'executionRepositoryInterfaceFlowFilter' when calling latestExecutions");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [ExecutionControllerLastExecutionResponse];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/latest', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Get the latest execution for given flows
    * @param {String} tenant 
    * @param {Array.<module:model/ExecutionRepositoryInterfaceFlowFilter>} executionRepositoryInterfaceFlowFilter 

    * @return {Promise<Array.<ExecutionControllerLastExecutionResponse>>}
    */
    latestExecutions(tenant, executionRepositoryInterfaceFlowFilter) {
      return this.latestExecutionsWithHttpInfo(tenant, executionRepositoryInterfaceFlowFilter)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Pause a running execution.
    * @param {String} executionId The execution id
    * @param {String} tenant 

    * @return {Promise<  >}
    */
    pauseExecutionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling pauseExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling pauseExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/pause', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Pause a running execution.
    * @param {String} executionId The execution id
    * @param {String} tenant 

    * @return {Promise<  >}
    */
    pauseExecution(executionId, tenant) {
      return this.pauseExecutionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Pause a list of running executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    pauseExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling pauseExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling pauseExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/pause/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Pause a list of running executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    pauseExecutionsByIds(tenant, requestBody) {
      return this.pauseExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Pause executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise< Object >}
    */
    pauseExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling pauseExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/pause/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Pause executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise< Object >}
    */
    pauseExecutionsByQuery(tenant, opts) {
      return this.pauseExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Create a new execution from an old one and start it from a specified task run id
    * @param {String} executionId the original execution id to clone
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {String} [taskRunId] The taskrun id
    * @param {Number} [revision] The flow revision to use for new execution
    * @param {String} [breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.

    * @return {Promise<Execution>}
    */
    replayExecutionWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling replayExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'taskRunId': opts['taskRunId'],
        'revision': opts['revision'],
        'breakpoints': opts['breakpoints']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/replay', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Create a new execution from an old one and start it from a specified task run id
    * @param {String} executionId the original execution id to clone
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {String} [opts.taskRunId] The taskrun id
    * @param {Number} [opts.revision] The flow revision to use for new execution
    * @param {String} [opts.breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.

    * @return {Promise<Execution>}
    */
    replayExecution(executionId, tenant, opts) {
      return this.replayExecutionWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Create a new execution from an old one and start it from a specified task run id
    * @param {String} executionId the original execution id to clone
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {String} [taskRunId] The taskrun id
    * @param {Number} [revision] The flow revision to use for new execution
    * @param {String} [breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
    * @param {Object} [formData] Extra multipart fields/files (key → value). Values may be strings, File/Blob (browser) or Buffer/stream (Node).
    
    * @return {Promise<Execution>}
    */
    replayExecutionWithinputsWithHttpInfo(executionId, tenant, opts, formData) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling replayExecutionWithinputs");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecutionWithinputs");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'taskRunId': opts['taskRunId'],
        'revision': opts['revision'],
        'breakpoints': opts['breakpoints']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = Execution;
      // Merge explicit formData parameter (only for multipart ops)
      if (formData && typeof formData === 'object') {
        for (const [k, v] of Object.entries(formData)) {
          if (v !== undefined && v !== null) {
            formParams[k] = v;
          }
        }
      }
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/replay-with-inputs', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Create a new execution from an old one and start it from a specified task run id
    * @param {String} executionId the original execution id to clone
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {String} [opts.taskRunId] The taskrun id
    * @param {Number} [opts.revision] The flow revision to use for new execution
    * @param {String} [opts.breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
    * @param {Object} [formData] Extra multipart fields/files (key → value). Values may be strings, File/Blob (browser) or Buffer/stream (Node).
    
    * @return {Promise<Execution>}
    */
    replayExecutionWithinputs(executionId, tenant, opts, formData) {
      return this.replayExecutionWithinputsWithHttpInfo(executionId, tenant, opts, formData)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Create new executions from old ones. Keep the flow revision
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id
    * @param {Object} opts Optional parameters
    * @param {Boolean} [latestRevision = false)] If latest revision should be used

    * @return {Promise<BulkResponse>}
    */
    replayExecutionsByIdsWithHttpInfo(tenant, requestBody, opts) {
      opts = opts || {};
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling replayExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'latestRevision': opts['latestRevision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/replay/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Create new executions from old ones. Keep the flow revision
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id
    * @param {Object} [opts] Optional parameters
    * @param {Boolean} [opts.latestRevision (default to false)] If latest revision should be used

    * @return {Promise<BulkResponse>}
    */
    replayExecutionsByIds(tenant, requestBody, opts) {
      return this.replayExecutionsByIdsWithHttpInfo(tenant, requestBody, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Create new executions from old ones filter by query parameters. Keep the flow revision
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters
    * @param {Boolean} [latestRevision = false)] If latest revision should be used

    * @return {Promise< Object >}
    */
    replayExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'latestRevision': opts['latestRevision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/replay/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Create new executions from old ones filter by query parameters. Keep the flow revision
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters
    * @param {Boolean} [opts.latestRevision (default to false)] If latest revision should be used

    * @return {Promise< Object >}
    */
    replayExecutionsByQuery(tenant, opts) {
      return this.replayExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Restart a new execution from an old one
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Number} [revision] The flow revision to use for new execution

    * @return {Promise<Execution>}
    */
    restartExecutionWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling restartExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling restartExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/restart', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Restart a new execution from an old one
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Number} [opts.revision] The flow revision to use for new execution

    * @return {Promise<Execution>}
    */
    restartExecution(executionId, tenant, opts) {
      return this.restartExecutionWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Restart a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    restartExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling restartExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling restartExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/restart/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Restart a list of executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    restartExecutionsByIds(tenant, requestBody) {
      return this.restartExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Restart executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise< Object >}
    */
    restartExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling restartExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/restart/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Restart executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise< Object >}
    */
    restartExecutionsByQuery(tenant, opts) {
      return this.restartExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Resume a paused execution.
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} [formData] Extra multipart fields/files (key → value). Values may be strings, File/Blob (browser) or Buffer/stream (Node).
    
    * @return {Promise< Object >}
    */
    resumeExecutionWithHttpInfo(executionId, tenant, formData) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling resumeExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling resumeExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = Object;
      // Merge explicit formData parameter (only for multipart ops)
      if (formData && typeof formData === 'object') {
        for (const [k, v] of Object.entries(formData)) {
          if (v !== undefined && v !== null) {
            formParams[k] = v;
          }
        }
      }
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/resume', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Resume a paused execution.
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Object} [formData] Extra multipart fields/files (key → value). Values may be strings, File/Blob (browser) or Buffer/stream (Node).
    
    * @return {Promise< Object >}
    */
    resumeExecution(executionId, tenant, formData) {
      return this.resumeExecutionWithHttpInfo(executionId, tenant, formData)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Resume a list of paused executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    resumeExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling resumeExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling resumeExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/resume/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Resume a list of paused executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    resumeExecutionsByIds(tenant, requestBody) {
      return this.resumeExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Resume executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise< Object >}
    */
    resumeExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling resumeExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/resume/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Resume executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise< Object >}
    */
    resumeExecutionsByQuery(tenant, opts) {
      return this.resumeExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Search for executions
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<String>} [sort] The sort of current page
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise<PagedResultsExecution>}
    */
    searchExecutionsWithHttpInfo(page, size, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchExecutions");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchExecutions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchExecutions");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsExecution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Search for executions
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<String>} [opts.sort] The sort of current page
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise<PagedResultsExecution>}
    */
    searchExecutions(page, size, tenant, opts) {
      return this.searchExecutionsWithHttpInfo(page, size, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Search for executions for a flow
    * @param {String} namespace The flow namespace
    * @param {String} flowId The flow id
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 

    * @return {Promise<PagedResultsExecution>}
    */
    searchExecutionsByFlowIdWithHttpInfo(namespace, flowId, page, size, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling searchExecutionsByFlowId");
      }
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling searchExecutionsByFlowId");
      }
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchExecutionsByFlowId");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchExecutionsByFlowId");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchExecutionsByFlowId");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'namespace': namespace,
        'flowId': flowId,
        'page': page,
        'size': size
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsExecution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Search for executions for a flow
    * @param {String} namespace The flow namespace
    * @param {String} flowId The flow id
    * @param {Number} page The current page
    * @param {Number} size The current page size
    * @param {String} tenant 

    * @return {Promise<PagedResultsExecution>}
    */
    searchExecutionsByFlowId(namespace, flowId, page, size, tenant) {
      return this.searchExecutionsByFlowIdWithHttpInfo(namespace, flowId, page, size, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Add or update labels of a terminated execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Array.<module:model/Label>} label The labels to add to the execution

    * @return {Promise< Object >}
    */
    setLabelsOnTerminatedExecutionWithHttpInfo(executionId, tenant, label) {
      let postBody = label;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling setLabelsOnTerminatedExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling setLabelsOnTerminatedExecution");
      }
      // verify the required parameter 'label' is set
      if (label === undefined || label === null) {
        throw new Error("Missing the required parameter 'label' when calling setLabelsOnTerminatedExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/labels', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Add or update labels of a terminated execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {Array.<module:model/Label>} label The labels to add to the execution

    * @return {Promise< Object >}
    */
    setLabelsOnTerminatedExecution(executionId, tenant, label) {
      return this.setLabelsOnTerminatedExecutionWithHttpInfo(executionId, tenant, label)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Set labels on a list of executions
    * @param {String} tenant 
    * @param {module:model/ExecutionControllerSetLabelsByIdsRequest} executionControllerSetLabelsByIdsRequest The request containing a list of labels and a list of executions

    * @return {Promise<BulkResponse>}
    */
    setLabelsOnTerminatedExecutionsByIdsWithHttpInfo(tenant, executionControllerSetLabelsByIdsRequest) {
      let postBody = executionControllerSetLabelsByIdsRequest;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling setLabelsOnTerminatedExecutionsByIds");
      }
      // verify the required parameter 'executionControllerSetLabelsByIdsRequest' is set
      if (executionControllerSetLabelsByIdsRequest === undefined || executionControllerSetLabelsByIdsRequest === null) {
        throw new Error("Missing the required parameter 'executionControllerSetLabelsByIdsRequest' when calling setLabelsOnTerminatedExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/labels/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Set labels on a list of executions
    * @param {String} tenant 
    * @param {module:model/ExecutionControllerSetLabelsByIdsRequest} executionControllerSetLabelsByIdsRequest The request containing a list of labels and a list of executions

    * @return {Promise<BulkResponse>}
    */
    setLabelsOnTerminatedExecutionsByIds(tenant, executionControllerSetLabelsByIdsRequest) {
      return this.setLabelsOnTerminatedExecutionsByIdsWithHttpInfo(tenant, executionControllerSetLabelsByIdsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Set label on executions filter by query parameters
    * @param {String} tenant 
    * @param {Array.<module:model/Label>} label The labels to add to the execution
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise< Object >}
    */
    setLabelsOnTerminatedExecutionsByQueryWithHttpInfo(tenant, label, opts) {
      opts = opts || {};
      let postBody = label;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling setLabelsOnTerminatedExecutionsByQuery");
      }
      // verify the required parameter 'label' is set
      if (label === undefined || label === null) {
        throw new Error("Missing the required parameter 'label' when calling setLabelsOnTerminatedExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/labels/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Set label on executions filter by query parameters
    * @param {String} tenant 
    * @param {Array.<module:model/Label>} label The labels to add to the execution
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise< Object >}
    */
    setLabelsOnTerminatedExecutionsByQuery(tenant, label, opts) {
      return this.setLabelsOnTerminatedExecutionsByQueryWithHttpInfo(tenant, label, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Trigger a new execution by GET webhook trigger
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} key The webhook trigger uid
    * @param {String} tenant 

    * @return {Promise<ExecutionControllerWebhookResponse>}
    */
    triggerExecutionByGetWebhookWithHttpInfo(namespace, id, key, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling triggerExecutionByGetWebhook");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling triggerExecutionByGetWebhook");
      }
      // verify the required parameter 'key' is set
      if (key === undefined || key === null) {
        throw new Error("Missing the required parameter 'key' when calling triggerExecutionByGetWebhook");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling triggerExecutionByGetWebhook");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'key': key,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ExecutionControllerWebhookResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Trigger a new execution by GET webhook trigger
    * @param {String} namespace The flow namespace
    * @param {String} id The flow id
    * @param {String} key The webhook trigger uid
    * @param {String} tenant 

    * @return {Promise<ExecutionControllerWebhookResponse>}
    */
    triggerExecutionByGetWebhook(namespace, id, key, tenant) {
      return this.triggerExecutionByGetWebhookWithHttpInfo(namespace, id, key, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Unqueue an execution
    * @param {String} executionId The execution id
    * @param {module:model/StateType} state The new state of the execution
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    unqueueExecutionWithHttpInfo(executionId, state, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling unqueueExecution");
      }
      // verify the required parameter 'state' is set
      if (state === undefined || state === null) {
        throw new Error("Missing the required parameter 'state' when calling unqueueExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling unqueueExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'state': state
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/unqueue', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Unqueue an execution
    * @param {String} executionId The execution id
    * @param {module:model/StateType} state The new state of the execution
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    unqueueExecution(executionId, state, tenant) {
      return this.unqueueExecutionWithHttpInfo(executionId, state, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Unqueue a list of executions
    * @param {module:model/StateType} state The new state of the unqueued executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    unqueueExecutionsByIdsWithHttpInfo(state, tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'state' is set
      if (state === undefined || state === null) {
        throw new Error("Missing the required parameter 'state' when calling unqueueExecutionsByIds");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling unqueueExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling unqueueExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'state': state
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/unqueue/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Unqueue a list of executions
    * @param {module:model/StateType} state The new state of the unqueued executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    unqueueExecutionsByIds(state, tenant, requestBody) {
      return this.unqueueExecutionsByIdsWithHttpInfo(state, tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Unqueue executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters
    * @param {module:model/StateType} [newState] The new state of the unqueued executions

    * @return {Promise< Object >}
    */
    unqueueExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling unqueueExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'newState': opts['newState']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/unqueue/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Unqueue executions filter by query parameters
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters
    * @param {module:model/StateType} [opts.newState] The new state of the unqueued executions

    * @return {Promise< Object >}
    */
    unqueueExecutionsByQuery(tenant, opts) {
      return this.unqueueExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Change the state of an execution
    * @param {String} executionId The execution id
    * @param {module:model/StateType} status The new state of the execution
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    updateExecutionStatusWithHttpInfo(executionId, status, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling updateExecutionStatus");
      }
      // verify the required parameter 'status' is set
      if (status === undefined || status === null) {
        throw new Error("Missing the required parameter 'status' when calling updateExecutionStatus");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateExecutionStatus");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'status': status
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/change-status', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Change the state of an execution
    * @param {String} executionId The execution id
    * @param {module:model/StateType} status The new state of the execution
    * @param {String} tenant 

    * @return {Promise<Execution>}
    */
    updateExecutionStatus(executionId, status, tenant) {
      return this.updateExecutionStatusWithHttpInfo(executionId, status, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Change executions state by id
    * @param {module:model/StateType} newStatus The new state of the executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    updateExecutionsStatusByIdsWithHttpInfo(newStatus, tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'newStatus' is set
      if (newStatus === undefined || newStatus === null) {
        throw new Error("Missing the required parameter 'newStatus' when calling updateExecutionsStatusByIds");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateExecutionsStatusByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling updateExecutionsStatusByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'newStatus': newStatus
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/change-status/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Change executions state by id
    * @param {module:model/StateType} newStatus The new state of the executions
    * @param {String} tenant 
    * @param {Array.<String>} requestBody The list of executions id

    * @return {Promise<BulkResponse>}
    */
    updateExecutionsStatusByIds(newStatus, tenant, requestBody) {
      return this.updateExecutionsStatusByIdsWithHttpInfo(newStatus, tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Change executions state by query parameters
    * @param {module:model/StateType} newStatus The new state of the executions
    * @param {String} tenant 
    * @param {Object} opts Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [filters] Filters

    * @return {Promise<BulkResponse>}
    */
    updateExecutionsStatusByQueryWithHttpInfo(newStatus, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'newStatus' is set
      if (newStatus === undefined || newStatus === null) {
        throw new Error("Missing the required parameter 'newStatus' when calling updateExecutionsStatusByQuery");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateExecutionsStatusByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'newStatus': newStatus
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/change-status/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Change executions state by query parameters
    * @param {module:model/StateType} newStatus The new state of the executions
    * @param {String} tenant 
    * @param {Object} [opts] Optional parameters
    * @param {Array.<import('../model/IQueryFilter').IQueryFilter>} [opts.filters] Filters

    * @return {Promise<BulkResponse>}
    */
    updateExecutionsStatusByQuery(newStatus, tenant, opts) {
      return this.updateExecutionsStatusByQueryWithHttpInfo(newStatus, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
    * Change state for a taskrun in an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {module:model/ExecutionControllerStateRequest} executionControllerStateRequest the taskRun id and state to apply

    * @return {Promise<Execution>}
    */
    updateTaskRunStateWithHttpInfo(executionId, tenant, executionControllerStateRequest) {
      let postBody = executionControllerStateRequest;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling updateTaskRunState");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateTaskRunState");
      }
      // verify the required parameter 'executionControllerStateRequest' is set
      if (executionControllerStateRequest === undefined || executionControllerStateRequest === null) {
        throw new Error("Missing the required parameter 'executionControllerStateRequest' when calling updateTaskRunState");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/state', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
    * Change state for a taskrun in an execution
    * @param {String} executionId The execution id
    * @param {String} tenant 
    * @param {module:model/ExecutionControllerStateRequest} executionControllerStateRequest the taskRun id and state to apply

    * @return {Promise<Execution>}
    */
    updateTaskRunState(executionId, tenant, executionControllerStateRequest) {
      return this.updateTaskRunStateWithHttpInfo(executionId, tenant, executionControllerStateRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }








}
