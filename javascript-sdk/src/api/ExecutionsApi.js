/**
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import BulkErrorResponse from '../model/BulkErrorResponse';
import BulkResponse from '../model/BulkResponse';
import EventExecution from '../model/EventExecution';
import Execution from '../model/Execution';
import ExecutionControllerExecutionResponse from '../model/ExecutionControllerExecutionResponse';
import ExecutionControllerLastExecutionResponse from '../model/ExecutionControllerLastExecutionResponse';
import ExecutionControllerSetLabelsByIdsRequest from '../model/ExecutionControllerSetLabelsByIdsRequest';
import ExecutionControllerStateRequest from '../model/ExecutionControllerStateRequest';
import ExecutionControllerWebhookResponse from '../model/ExecutionControllerWebhookResponse';
import ExecutionKind from '../model/ExecutionKind';
import ExecutionRepositoryInterfaceFlowFilter from '../model/ExecutionRepositoryInterfaceFlowFilter';
import FileMetas from '../model/FileMetas';
import FlowForExecution from '../model/FlowForExecution';
import FlowGraph from '../model/FlowGraph';
import Label from '../model/Label';
import PagedResultsExecution from '../model/PagedResultsExecution';
import QueryFilter from '../model/QueryFilter';
import StateType from '../model/StateType';

/**
* Executions service.
* @module api/ExecutionsApi
* @version v1.0.5
*/
export default class ExecutionsApi {

    /**
    * Constructs a new ExecutionsApi. 
    * @alias module:api/ExecutionsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }




            

    /**
     * Create a new execution for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} wait If the server will wait the end of the execution
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [labels] The labels as a list of 'key:value'
     * @param {Number} [revision] The flow revision or latest if null
     * @param {Date} [scheduleDate] Schedule the flow on a specific date
     * @param {String} [breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
     * @param {module:model/ExecutionKind} [kind] Specific execution kind
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ExecutionControllerExecutionResponse} and HTTP response
     */
    createExecutionWithHttpInfo(namespace, id, wait, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling createExecution");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createExecution");
      }
      // verify the required parameter 'wait' is set
      if (wait === undefined || wait === null) {
        throw new Error("Missing the required parameter 'wait' when calling createExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling createExecution");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi'),
        'wait': wait,
        'revision': opts['revision'],
        'scheduleDate': opts['scheduleDate'],
        'breakpoints': opts['breakpoints'],
        'kind': opts['kind']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = ExecutionControllerExecutionResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{namespace}/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a new execution for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} wait If the server will wait the end of the execution
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.labels The labels as a list of 'key:value'
     * @param {Number} opts.revision The flow revision or latest if null
     * @param {Date} opts.scheduleDate Schedule the flow on a specific date
     * @param {String} opts.breakpoints Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
     * @param {module:model/ExecutionKind} opts.kind Specific execution kind
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ExecutionControllerExecutionResponse}
     */
    createExecution(namespace, id, wait, tenant, opts) {
      return this.createExecutionWithHttpInfo(namespace, id, wait, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Delete an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Boolean} [deleteLogs = true)] Whether to delete execution logs
     * @param {Boolean} [deleteMetrics = true)] Whether to delete execution metrics
     * @param {Boolean} [deleteStorage = true)] Whether to delete execution files in the internal storage
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteExecutionWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling deleteExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'deleteLogs': opts['deleteLogs'],
        'deleteMetrics': opts['deleteMetrics'],
        'deleteStorage': opts['deleteStorage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.deleteLogs Whether to delete execution logs (default to true)
     * @param {Boolean} opts.deleteMetrics Whether to delete execution metrics (default to true)
     * @param {Boolean} opts.deleteStorage Whether to delete execution files in the internal storage (default to true)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteExecution(executionId, tenant, opts) {
      return this.deleteExecutionWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Delete a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The execution id
     * @param {Object} opts Optional parameters
     * @param {Boolean} [includeNonTerminated = false)] Whether to delete non-terminated executions
     * @param {Boolean} [deleteLogs = true)] Whether to delete execution logs
     * @param {Boolean} [deleteMetrics = true)] Whether to delete execution metrics
     * @param {Boolean} [deleteStorage = true)] Whether to delete execution files in the internal storage
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    deleteExecutionsByIdsWithHttpInfo(tenant, requestBody, opts) {
      opts = opts || {};
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling deleteExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'includeNonTerminated': opts['includeNonTerminated'],
        'deleteLogs': opts['deleteLogs'],
        'deleteMetrics': opts['deleteMetrics'],
        'deleteStorage': opts['deleteStorage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The execution id
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.includeNonTerminated Whether to delete non-terminated executions (default to false)
     * @param {Boolean} opts.deleteLogs Whether to delete execution logs (default to true)
     * @param {Boolean} opts.deleteMetrics Whether to delete execution metrics (default to true)
     * @param {Boolean} opts.deleteStorage Whether to delete execution files in the internal storage (default to true)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    deleteExecutionsByIds(tenant, requestBody, opts) {
      return this.deleteExecutionsByIdsWithHttpInfo(tenant, requestBody, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Delete executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @param {Boolean} [includeNonTerminated = false)] Whether to delete non-terminated executions
     * @param {Boolean} [deleteLogs = true)] Whether to delete execution logs
     * @param {Boolean} [deleteMetrics = true)] Whether to delete execution metrics
     * @param {Boolean} [deleteStorage = true)] Whether to delete execution files in the internal storage
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    deleteExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'includeNonTerminated': opts['includeNonTerminated'],
        'deleteLogs': opts['deleteLogs'],
        'deleteMetrics': opts['deleteMetrics'],
        'deleteStorage': opts['deleteStorage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @param {Boolean} opts.includeNonTerminated Whether to delete non-terminated executions (default to false)
     * @param {Boolean} opts.deleteLogs Whether to delete execution logs (default to true)
     * @param {Boolean} opts.deleteMetrics Whether to delete execution metrics (default to true)
     * @param {Boolean} opts.deleteStorage Whether to delete execution files in the internal storage (default to true)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    deleteExecutionsByQuery(tenant, opts) {
      return this.deleteExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Download file for an execution
     * @param {String} executionId The execution id
     * @param {String} path The internal storage uri
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    downloadFileFromExecutionWithHttpInfo(executionId, path, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling downloadFileFromExecution");
      }
      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling downloadFileFromExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling downloadFileFromExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'path': path
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/octet-stream'];
      let returnType = File;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/file', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Download file for an execution
     * @param {String} executionId The execution id
     * @param {String} path The internal storage uri
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    downloadFileFromExecution(executionId, path, tenant) {
      return this.downloadFileFromExecutionWithHttpInfo(executionId, path, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }
















            

    /**
     * Force run a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    forceRunByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling forceRunByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling forceRunByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/force-run/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Force run a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    forceRunByIds(tenant, requestBody) {
      return this.forceRunByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Force run an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    forceRunExecutionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling forceRunExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling forceRunExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/force-run', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Force run an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    forceRunExecution(executionId, tenant) {
      return this.forceRunExecutionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Force run executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    forceRunExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling forceRunExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/force-run/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Force run executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    forceRunExecutionsByQuery(tenant, opts) {
      return this.forceRunExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    getExecutionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling getExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    getExecution(executionId, tenant) {
      return this.getExecutionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Generate a graph for an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [subflows] The subflow tasks to display
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowGraph} and HTTP response
     */
    getExecutionFlowGraphWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling getExecutionFlowGraph");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getExecutionFlowGraph");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/graph', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Generate a graph for an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.subflows The subflow tasks to display
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowGraph}
     */
    getExecutionFlowGraph(executionId, tenant, opts) {
      return this.getExecutionFlowGraphWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get file meta information for an execution
     * @param {String} executionId The execution id
     * @param {String} path The internal storage uri
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FileMetas} and HTTP response
     */
    getFileMetadatasFromExecutionWithHttpInfo(executionId, path, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling getFileMetadatasFromExecution");
      }
      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling getFileMetadatasFromExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFileMetadatasFromExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'path': path
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FileMetas;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/file/metas', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get file meta information for an execution
     * @param {String} executionId The execution id
     * @param {String} path The internal storage uri
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FileMetas}
     */
    getFileMetadatasFromExecution(executionId, path, tenant) {
      return this.getFileMetadatasFromExecutionWithHttpInfo(executionId, path, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get flow information's for an execution
     * @param {String} executionId The execution that you want flow informations
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowForExecution} and HTTP response
     */
    getFlowFromExecutionByIdWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling getFlowFromExecutionById");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlowFromExecutionById");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowForExecution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/flow', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get flow information's for an execution
     * @param {String} executionId The execution that you want flow informations
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowForExecution}
     */
    getFlowFromExecutionById(executionId, tenant) {
      return this.getFlowFromExecutionByIdWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get the latest execution for given flows
     * @param {String} tenant 
     * @param {Array.<module:model/ExecutionRepositoryInterfaceFlowFilter>} executionRepositoryInterfaceFlowFilter 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/ExecutionControllerLastExecutionResponse>} and HTTP response
     */
    getLatestExecutionsWithHttpInfo(tenant, executionRepositoryInterfaceFlowFilter) {
      let postBody = executionRepositoryInterfaceFlowFilter;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getLatestExecutions");
      }
      // verify the required parameter 'executionRepositoryInterfaceFlowFilter' is set
      if (executionRepositoryInterfaceFlowFilter === undefined || executionRepositoryInterfaceFlowFilter === null) {
        throw new Error("Missing the required parameter 'executionRepositoryInterfaceFlowFilter' when calling getLatestExecutions");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [ExecutionControllerLastExecutionResponse];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/latest', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get the latest execution for given flows
     * @param {String} tenant 
     * @param {Array.<module:model/ExecutionRepositoryInterfaceFlowFilter>} executionRepositoryInterfaceFlowFilter 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/ExecutionControllerLastExecutionResponse>}
     */
    getLatestExecutions(tenant, executionRepositoryInterfaceFlowFilter) {
      return this.getLatestExecutionsWithHttpInfo(tenant, executionRepositoryInterfaceFlowFilter)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Kill an execution
     * @param {String} executionId The execution id
     * @param {Boolean} isOnKillCascade Specifies whether killing the execution also kill all subflow executions.
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    killExecutionWithHttpInfo(executionId, isOnKillCascade, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling killExecution");
      }
      // verify the required parameter 'isOnKillCascade' is set
      if (isOnKillCascade === undefined || isOnKillCascade === null) {
        throw new Error("Missing the required parameter 'isOnKillCascade' when calling killExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling killExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'isOnKillCascade': isOnKillCascade
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['text/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/kill', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Kill an execution
     * @param {String} executionId The execution id
     * @param {Boolean} isOnKillCascade Specifies whether killing the execution also kill all subflow executions.
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    killExecution(executionId, isOnKillCascade, tenant) {
      return this.killExecutionWithHttpInfo(executionId, isOnKillCascade, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Kill a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    killExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling killExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling killExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/kill/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Kill a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    killExecutionsByIds(tenant, requestBody) {
      return this.killExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Kill executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    killExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling killExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/kill/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Kill executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    killExecutionsByQuery(tenant, opts) {
      return this.killExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Pause a running execution.
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    pauseExecutionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling pauseExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling pauseExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/pause', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Pause a running execution.
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    pauseExecution(executionId, tenant) {
      return this.pauseExecutionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Pause a list of running executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    pauseExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling pauseExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling pauseExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/pause/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Pause a list of running executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    pauseExecutionsByIds(tenant, requestBody) {
      return this.pauseExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Pause executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    pauseExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling pauseExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/pause/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Pause executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    pauseExecutionsByQuery(tenant, opts) {
      return this.pauseExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Create a new execution from an old one and start it from a specified task run id
     * @param {String} executionId the original execution id to clone
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} [taskRunId] The taskrun id
     * @param {Number} [revision] The flow revision to use for new execution
     * @param {String} [breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    replayExecutionWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling replayExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'taskRunId': opts['taskRunId'],
        'revision': opts['revision'],
        'breakpoints': opts['breakpoints']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/replay', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a new execution from an old one and start it from a specified task run id
     * @param {String} executionId the original execution id to clone
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} opts.taskRunId The taskrun id
     * @param {Number} opts.revision The flow revision to use for new execution
     * @param {String} opts.breakpoints Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    replayExecution(executionId, tenant, opts) {
      return this.replayExecutionWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Create a new execution from an old one and start it from a specified task run id
     * @param {String} executionId the original execution id to clone
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} [taskRunId] The taskrun id
     * @param {Number} [revision] The flow revision to use for new execution
     * @param {String} [breakpoints] Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    replayExecutionWithinputsWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling replayExecutionWithinputs");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecutionWithinputs");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'taskRunId': opts['taskRunId'],
        'revision': opts['revision'],
        'breakpoints': opts['breakpoints']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/replay-with-inputs', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a new execution from an old one and start it from a specified task run id
     * @param {String} executionId the original execution id to clone
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} opts.taskRunId The taskrun id
     * @param {Number} opts.revision The flow revision to use for new execution
     * @param {String} opts.breakpoints Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    replayExecutionWithinputs(executionId, tenant, opts) {
      return this.replayExecutionWithinputsWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Create new executions from old ones. Keep the flow revision
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @param {Object} opts Optional parameters
     * @param {Boolean} [latestRevision = false)] If latest revision should be used
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    replayExecutionsByIdsWithHttpInfo(tenant, requestBody, opts) {
      opts = opts || {};
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling replayExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'latestRevision': opts['latestRevision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/replay/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create new executions from old ones. Keep the flow revision
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.latestRevision If latest revision should be used (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    replayExecutionsByIds(tenant, requestBody, opts) {
      return this.replayExecutionsByIdsWithHttpInfo(tenant, requestBody, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Create new executions from old ones filter by query parameters. Keep the flow revision
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @param {Boolean} [latestRevision = false)] If latest revision should be used
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    replayExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling replayExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'latestRevision': opts['latestRevision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/replay/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create new executions from old ones filter by query parameters. Keep the flow revision
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @param {Boolean} opts.latestRevision If latest revision should be used (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    replayExecutionsByQuery(tenant, opts) {
      return this.replayExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Restart a new execution from an old one
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] The flow revision to use for new execution
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    restartExecutionWithHttpInfo(executionId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling restartExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling restartExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/restart', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Restart a new execution from an old one
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.revision The flow revision to use for new execution
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    restartExecution(executionId, tenant, opts) {
      return this.restartExecutionWithHttpInfo(executionId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Restart a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    restartExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling restartExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling restartExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/restart/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Restart a list of executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    restartExecutionsByIds(tenant, requestBody) {
      return this.restartExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Restart executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    restartExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling restartExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/restart/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Restart executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    restartExecutionsByQuery(tenant, opts) {
      return this.restartExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Resume a paused execution.
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    resumeExecutionWithHttpInfo(executionId, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling resumeExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling resumeExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/resume', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Resume a paused execution.
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    resumeExecution(executionId, tenant) {
      return this.resumeExecutionWithHttpInfo(executionId, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Resume a list of paused executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    resumeExecutionsByIdsWithHttpInfo(tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling resumeExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling resumeExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/resume/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Resume a list of paused executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    resumeExecutionsByIds(tenant, requestBody) {
      return this.resumeExecutionsByIdsWithHttpInfo(tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Resume executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    resumeExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling resumeExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/resume/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Resume executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    resumeExecutionsByQuery(tenant, opts) {
      return this.resumeExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Search for executions
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [sort] The sort of current page
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsExecution} and HTTP response
     */
    searchExecutionsWithHttpInfo(page, size, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchExecutions");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchExecutions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchExecutions");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsExecution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Search for executions
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.sort The sort of current page
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsExecution}
     */
    searchExecutions(page, size, tenant, opts) {
      return this.searchExecutionsWithHttpInfo(page, size, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Add or update labels of a terminated execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Array.<module:model/Label>} label The labels to add to the execution
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    setLabelsOnTerminatedExecutionWithHttpInfo(executionId, tenant, label) {
      let postBody = label;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling setLabelsOnTerminatedExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling setLabelsOnTerminatedExecution");
      }
      // verify the required parameter 'label' is set
      if (label === undefined || label === null) {
        throw new Error("Missing the required parameter 'label' when calling setLabelsOnTerminatedExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/labels', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Add or update labels of a terminated execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {Array.<module:model/Label>} label The labels to add to the execution
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    setLabelsOnTerminatedExecution(executionId, tenant, label) {
      return this.setLabelsOnTerminatedExecutionWithHttpInfo(executionId, tenant, label)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Set labels on a list of executions
     * @param {String} tenant 
     * @param {module:model/ExecutionControllerSetLabelsByIdsRequest} executionControllerSetLabelsByIdsRequest The request containing a list of labels and a list of executions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    setLabelsOnTerminatedExecutionsByIdsWithHttpInfo(tenant, executionControllerSetLabelsByIdsRequest) {
      let postBody = executionControllerSetLabelsByIdsRequest;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling setLabelsOnTerminatedExecutionsByIds");
      }
      // verify the required parameter 'executionControllerSetLabelsByIdsRequest' is set
      if (executionControllerSetLabelsByIdsRequest === undefined || executionControllerSetLabelsByIdsRequest === null) {
        throw new Error("Missing the required parameter 'executionControllerSetLabelsByIdsRequest' when calling setLabelsOnTerminatedExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/labels/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Set labels on a list of executions
     * @param {String} tenant 
     * @param {module:model/ExecutionControllerSetLabelsByIdsRequest} executionControllerSetLabelsByIdsRequest The request containing a list of labels and a list of executions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    setLabelsOnTerminatedExecutionsByIds(tenant, executionControllerSetLabelsByIdsRequest) {
      return this.setLabelsOnTerminatedExecutionsByIdsWithHttpInfo(tenant, executionControllerSetLabelsByIdsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Set label on executions filter by query parameters
     * @param {String} tenant 
     * @param {Array.<module:model/Label>} label The labels to add to the execution
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    setLabelsOnTerminatedExecutionsByQueryWithHttpInfo(tenant, label, opts) {
      opts = opts || {};
      let postBody = label;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling setLabelsOnTerminatedExecutionsByQuery");
      }
      // verify the required parameter 'label' is set
      if (label === undefined || label === null) {
        throw new Error("Missing the required parameter 'label' when calling setLabelsOnTerminatedExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/labels/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Set label on executions filter by query parameters
     * @param {String} tenant 
     * @param {Array.<module:model/Label>} label The labels to add to the execution
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    setLabelsOnTerminatedExecutionsByQuery(tenant, label, opts) {
      return this.setLabelsOnTerminatedExecutionsByQueryWithHttpInfo(tenant, label, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Trigger a new execution by GET webhook trigger
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} key The webhook trigger uid
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ExecutionControllerWebhookResponse} and HTTP response
     */
    triggerExecutionByGetWebhookWithHttpInfo(namespace, id, key, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling triggerExecutionByGetWebhook");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling triggerExecutionByGetWebhook");
      }
      // verify the required parameter 'key' is set
      if (key === undefined || key === null) {
        throw new Error("Missing the required parameter 'key' when calling triggerExecutionByGetWebhook");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling triggerExecutionByGetWebhook");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'key': key,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ExecutionControllerWebhookResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Trigger a new execution by GET webhook trigger
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} key The webhook trigger uid
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ExecutionControllerWebhookResponse}
     */
    triggerExecutionByGetWebhook(namespace, id, key, tenant) {
      return this.triggerExecutionByGetWebhookWithHttpInfo(namespace, id, key, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Unqueue an execution
     * @param {String} executionId The execution id
     * @param {module:model/StateType} state The new state of the execution
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    unqueueExecutionWithHttpInfo(executionId, state, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling unqueueExecution");
      }
      // verify the required parameter 'state' is set
      if (state === undefined || state === null) {
        throw new Error("Missing the required parameter 'state' when calling unqueueExecution");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling unqueueExecution");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'state': state
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/unqueue', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Unqueue an execution
     * @param {String} executionId The execution id
     * @param {module:model/StateType} state The new state of the execution
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    unqueueExecution(executionId, state, tenant) {
      return this.unqueueExecutionWithHttpInfo(executionId, state, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Unqueue a list of executions
     * @param {module:model/StateType} state The new state of the unqueued executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    unqueueExecutionsByIdsWithHttpInfo(state, tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'state' is set
      if (state === undefined || state === null) {
        throw new Error("Missing the required parameter 'state' when calling unqueueExecutionsByIds");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling unqueueExecutionsByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling unqueueExecutionsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'state': state
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/unqueue/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Unqueue a list of executions
     * @param {module:model/StateType} state The new state of the unqueued executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    unqueueExecutionsByIds(state, tenant, requestBody) {
      return this.unqueueExecutionsByIdsWithHttpInfo(state, tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Unqueue executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @param {module:model/StateType} [newState] The new state of the unqueued executions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    unqueueExecutionsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling unqueueExecutionsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'newState': opts['newState']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/unqueue/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Unqueue executions filter by query parameters
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @param {module:model/StateType} opts.newState The new state of the unqueued executions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    unqueueExecutionsByQuery(tenant, opts) {
      return this.unqueueExecutionsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Change the state of an execution
     * @param {String} executionId The execution id
     * @param {module:model/StateType} status The new state of the execution
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    updateExecutionStatusWithHttpInfo(executionId, status, tenant) {
      let postBody = null;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling updateExecutionStatus");
      }
      // verify the required parameter 'status' is set
      if (status === undefined || status === null) {
        throw new Error("Missing the required parameter 'status' when calling updateExecutionStatus");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateExecutionStatus");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
        'status': status
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/change-status', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Change the state of an execution
     * @param {String} executionId The execution id
     * @param {module:model/StateType} status The new state of the execution
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    updateExecutionStatus(executionId, status, tenant) {
      return this.updateExecutionStatusWithHttpInfo(executionId, status, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Change executions state by id
     * @param {module:model/StateType} newStatus The new state of the executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    updateExecutionsStatusByIdsWithHttpInfo(newStatus, tenant, requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'newStatus' is set
      if (newStatus === undefined || newStatus === null) {
        throw new Error("Missing the required parameter 'newStatus' when calling updateExecutionsStatusByIds");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateExecutionsStatusByIds");
      }
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling updateExecutionsStatusByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'newStatus': newStatus
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/change-status/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Change executions state by id
     * @param {module:model/StateType} newStatus The new state of the executions
     * @param {String} tenant 
     * @param {Array.<String>} requestBody The list of executions id
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    updateExecutionsStatusByIds(newStatus, tenant, requestBody) {
      return this.updateExecutionsStatusByIdsWithHttpInfo(newStatus, tenant, requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Change executions state by query parameters
     * @param {module:model/StateType} newStatus The new state of the executions
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    updateExecutionsStatusByQueryWithHttpInfo(newStatus, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'newStatus' is set
      if (newStatus === undefined || newStatus === null) {
        throw new Error("Missing the required parameter 'newStatus' when calling updateExecutionsStatusByQuery");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateExecutionsStatusByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'newStatus': newStatus
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/change-status/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Change executions state by query parameters
     * @param {module:model/StateType} newStatus The new state of the executions
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    updateExecutionsStatusByQuery(newStatus, tenant, opts) {
      return this.updateExecutionsStatusByQueryWithHttpInfo(newStatus, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Change state for a taskrun in an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {module:model/ExecutionControllerStateRequest} executionControllerStateRequest the taskRun id and state to apply
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Execution} and HTTP response
     */
    updateTaskRunStateWithHttpInfo(executionId, tenant, executionControllerStateRequest) {
      let postBody = executionControllerStateRequest;
      // verify the required parameter 'executionId' is set
      if (executionId === undefined || executionId === null) {
        throw new Error("Missing the required parameter 'executionId' when calling updateTaskRunState");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateTaskRunState");
      }
      // verify the required parameter 'executionControllerStateRequest' is set
      if (executionControllerStateRequest === undefined || executionControllerStateRequest === null) {
        throw new Error("Missing the required parameter 'executionControllerStateRequest' when calling updateTaskRunState");
      }

      let pathParams = {
        'executionId': executionId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Execution;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/executions/{executionId}/state', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Change state for a taskrun in an execution
     * @param {String} executionId The execution id
     * @param {String} tenant 
     * @param {module:model/ExecutionControllerStateRequest} executionControllerStateRequest the taskRun id and state to apply
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Execution}
     */
    updateTaskRunState(executionId, tenant, executionControllerStateRequest) {
      return this.updateTaskRunStateWithHttpInfo(executionId, tenant, executionControllerStateRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }








}
