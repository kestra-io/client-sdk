/**
 * Kestra EE
 * All API operations allow an optional tenant identifier in the HTTP path, if you don't use multi-tenancy you must omit the tenant identifier.<br/> This means that, for example, when trying to access the Flows API, instead of using <code>/api/v1/{tenant}/flows</code> you must use <code>/api/v1/flows</code>.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import ClusterControllerApiPluginArtifactListPluginArtifact from '../model/ClusterControllerApiPluginArtifactListPluginArtifact';
import ClusterControllerApiPluginArtifactListPluginResolutionResult from '../model/ClusterControllerApiPluginArtifactListPluginResolutionResult';
import ClusterControllerApiPluginListRequest from '../model/ClusterControllerApiPluginListRequest';
import ClusterControllerApiPluginVersionDetails from '../model/ClusterControllerApiPluginVersionDetails';
import ClusterControllerApiPluginVersions from '../model/ClusterControllerApiPluginVersions';
import DocumentationWithSchema from '../model/DocumentationWithSchema';
import InputType from '../model/InputType';
import PagedResultsClusterControllerApiPluginArtifact from '../model/PagedResultsClusterControllerApiPluginArtifact';
import Plugin from '../model/Plugin';
import PluginArtifact from '../model/PluginArtifact';
import PluginControllerApiPluginVersions from '../model/PluginControllerApiPluginVersions';
import PluginIcon from '../model/PluginIcon';
import SchemaType from '../model/SchemaType';
import Type from '../model/Type';

/**
* Plugins service.
* @module api/PluginsApi
* @version v1
*/
export default class PluginsApi {

    /**
    * Constructs a new PluginsApi. 
    * @alias module:api/PluginsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Get all types for an inputs
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/InputType>} and HTTP response
     */
    getAllInputTypesWithHttpInfo(tenant) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getAllInputTypes");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [InputType];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/inputs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get all types for an inputs
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/InputType>}
     */
    getAllInputTypes(tenant) {
      return this.getAllInputTypesWithHttpInfo(tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get plugins group by subgroups
     * @param {Boolean} includeDeprecated Whether to include deprecated plugins
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Plugin>} and HTTP response
     */
    getPluginBySubgroupsWithHttpInfo(includeDeprecated, tenant) {
      let postBody = null;
      // verify the required parameter 'includeDeprecated' is set
      if (includeDeprecated === undefined || includeDeprecated === null) {
        throw new Error("Missing the required parameter 'includeDeprecated' when calling getPluginBySubgroups");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getPluginBySubgroups");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'includeDeprecated': includeDeprecated
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Plugin];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/groups/subgroups', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get plugins group by subgroups
     * @param {Boolean} includeDeprecated Whether to include deprecated plugins
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Plugin>}
     */
    getPluginBySubgroups(includeDeprecated, tenant) {
      return this.getPluginBySubgroupsWithHttpInfo(includeDeprecated, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get plugin documentation
     * @param {String} cls The plugin full class name
     * @param {Boolean} all Include all the properties
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentationWithSchema} and HTTP response
     */
    getPluginDocumentationWithHttpInfo(cls, all, tenant) {
      let postBody = null;
      // verify the required parameter 'cls' is set
      if (cls === undefined || cls === null) {
        throw new Error("Missing the required parameter 'cls' when calling getPluginDocumentation");
      }
      // verify the required parameter 'all' is set
      if (all === undefined || all === null) {
        throw new Error("Missing the required parameter 'all' when calling getPluginDocumentation");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getPluginDocumentation");
      }

      let pathParams = {
        'cls': cls,
        'tenant': tenant
      };
      let queryParams = {
        'all': all
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = DocumentationWithSchema;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/{cls}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get plugin documentation
     * @param {String} cls The plugin full class name
     * @param {Boolean} all Include all the properties
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentationWithSchema}
     */
    getPluginDocumentation(cls, all, tenant) {
      return this.getPluginDocumentationWithHttpInfo(cls, all, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get plugin documentation
     * @param {String} cls The plugin type
     * @param {String} version The plugin version
     * @param {Boolean} all Include all the properties
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentationWithSchema} and HTTP response
     */
    getPluginDocumentationFromVersionWithHttpInfo(cls, version, all, tenant) {
      let postBody = null;
      // verify the required parameter 'cls' is set
      if (cls === undefined || cls === null) {
        throw new Error("Missing the required parameter 'cls' when calling getPluginDocumentationFromVersion");
      }
      // verify the required parameter 'version' is set
      if (version === undefined || version === null) {
        throw new Error("Missing the required parameter 'version' when calling getPluginDocumentationFromVersion");
      }
      // verify the required parameter 'all' is set
      if (all === undefined || all === null) {
        throw new Error("Missing the required parameter 'all' when calling getPluginDocumentationFromVersion");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getPluginDocumentationFromVersion");
      }

      let pathParams = {
        'cls': cls,
        'version': version,
        'tenant': tenant
      };
      let queryParams = {
        'all': all
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = DocumentationWithSchema;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/{cls}/versions/{version}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get plugin documentation
     * @param {String} cls The plugin type
     * @param {String} version The plugin version
     * @param {Boolean} all Include all the properties
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentationWithSchema}
     */
    getPluginDocumentationFromVersion(cls, version, all, tenant) {
      return this.getPluginDocumentationFromVersionWithHttpInfo(cls, version, all, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get plugins icons
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object.<String, module:model/{String: PluginIcon}>} and HTTP response
     */
    getPluginGroupIconsWithHttpInfo(tenant) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getPluginGroupIcons");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = {'String': PluginIcon};
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/icons/groups', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get plugins icons
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object.<String, module:model/{String: PluginIcon}>}
     */
    getPluginGroupIcons(tenant) {
      return this.getPluginGroupIconsWithHttpInfo(tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get plugins icons
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object.<String, module:model/{String: PluginIcon}>} and HTTP response
     */
    getPluginIconsWithHttpInfo(tenant) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getPluginIcons");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = {'String': PluginIcon};
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/icons', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get plugins icons
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object.<String, module:model/{String: PluginIcon}>}
     */
    getPluginIcons(tenant) {
      return this.getPluginIconsWithHttpInfo(tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get all versions for a plugin
     * @param {String} cls The plugin type
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PluginControllerApiPluginVersions} and HTTP response
     */
    getPluginVersionsWithHttpInfo(cls, tenant) {
      let postBody = null;
      // verify the required parameter 'cls' is set
      if (cls === undefined || cls === null) {
        throw new Error("Missing the required parameter 'cls' when calling getPluginVersions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getPluginVersions");
      }

      let pathParams = {
        'cls': cls,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PluginControllerApiPluginVersions;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/{cls}/versions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get all versions for a plugin
     * @param {String} cls The plugin type
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PluginControllerApiPluginVersions}
     */
    getPluginVersions(cls, tenant) {
      return this.getPluginVersionsWithHttpInfo(cls, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get json schemas for an input type
     * The schema will be output as [http://json-schema.org/draft-07/schema](Json Schema Draft 7)
     * @param {module:model/Type} type The schema needed
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DocumentationWithSchema} and HTTP response
     */
    getSchemaFromInputTypeWithHttpInfo(type, tenant) {
      let postBody = null;
      // verify the required parameter 'type' is set
      if (type === undefined || type === null) {
        throw new Error("Missing the required parameter 'type' when calling getSchemaFromInputType");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getSchemaFromInputType");
      }

      let pathParams = {
        'type': type,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = DocumentationWithSchema;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/inputs/{type}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get json schemas for an input type
     * The schema will be output as [http://json-schema.org/draft-07/schema](Json Schema Draft 7)
     * @param {module:model/Type} type The schema needed
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DocumentationWithSchema}
     */
    getSchemaFromInputType(type, tenant) {
      return this.getSchemaFromInputTypeWithHttpInfo(type, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get all json schemas for a type
     * The schema will be output as [http://json-schema.org/draft-07/schema](Json Schema Draft 7)
     * @param {module:model/SchemaType} type The schema needed
     * @param {Boolean} arrayOf If schema should be an array of requested type
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object.<String, {String: Object}>} and HTTP response
     */
    getSchemasFromTypeWithHttpInfo(type, arrayOf, tenant) {
      let postBody = null;
      // verify the required parameter 'type' is set
      if (type === undefined || type === null) {
        throw new Error("Missing the required parameter 'type' when calling getSchemasFromType");
      }
      // verify the required parameter 'arrayOf' is set
      if (arrayOf === undefined || arrayOf === null) {
        throw new Error("Missing the required parameter 'arrayOf' when calling getSchemasFromType");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getSchemasFromType");
      }

      let pathParams = {
        'type': type,
        'tenant': tenant
      };
      let queryParams = {
        'arrayOf': arrayOf
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = {'String': Object};
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins/schemas/{type}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get all json schemas for a type
     * The schema will be output as [http://json-schema.org/draft-07/schema](Json Schema Draft 7)
     * @param {module:model/SchemaType} type The schema needed
     * @param {Boolean} arrayOf If schema should be an array of requested type
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object.<String, {String: Object}>}
     */
    getSchemasFromType(type, arrayOf, tenant) {
      return this.getSchemasFromTypeWithHttpInfo(type, arrayOf, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get details about a Kestra's plugin artifact.
     * @param {String} groupId 
     * @param {String} artifactId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ClusterControllerApiPluginVersions} and HTTP response
     */
    getVersionedPluginDetailsWithHttpInfo(groupId, artifactId) {
      let postBody = null;
      // verify the required parameter 'groupId' is set
      if (groupId === undefined || groupId === null) {
        throw new Error("Missing the required parameter 'groupId' when calling getVersionedPluginDetails");
      }
      // verify the required parameter 'artifactId' is set
      if (artifactId === undefined || artifactId === null) {
        throw new Error("Missing the required parameter 'artifactId' when calling getVersionedPluginDetails");
      }

      let pathParams = {
        'groupId': groupId,
        'artifactId': artifactId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ClusterControllerApiPluginVersions;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/{groupId}/{artifactId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get details about a Kestra's plugin artifact.
     * @param {String} groupId 
     * @param {String} artifactId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ClusterControllerApiPluginVersions}
     */
    getVersionedPluginDetails(groupId, artifactId) {
      return this.getVersionedPluginDetailsWithHttpInfo(groupId, artifactId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get details about a specific Kestra's plugin artifact version.
     * @param {String} groupId 
     * @param {String} artifactId 
     * @param {String} version 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ClusterControllerApiPluginVersionDetails} and HTTP response
     */
    getVersionedPluginDetailsFromVersionWithHttpInfo(groupId, artifactId, version) {
      let postBody = null;
      // verify the required parameter 'groupId' is set
      if (groupId === undefined || groupId === null) {
        throw new Error("Missing the required parameter 'groupId' when calling getVersionedPluginDetailsFromVersion");
      }
      // verify the required parameter 'artifactId' is set
      if (artifactId === undefined || artifactId === null) {
        throw new Error("Missing the required parameter 'artifactId' when calling getVersionedPluginDetailsFromVersion");
      }
      // verify the required parameter 'version' is set
      if (version === undefined || version === null) {
        throw new Error("Missing the required parameter 'version' when calling getVersionedPluginDetailsFromVersion");
      }

      let pathParams = {
        'groupId': groupId,
        'artifactId': artifactId,
        'version': version
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ClusterControllerApiPluginVersionDetails;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/{groupId}/{artifactId}/{version}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get details about a specific Kestra's plugin artifact version.
     * @param {String} groupId 
     * @param {String} artifactId 
     * @param {String} version 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ClusterControllerApiPluginVersionDetails}
     */
    getVersionedPluginDetailsFromVersion(groupId, artifactId, version) {
      return this.getVersionedPluginDetailsFromVersionWithHttpInfo(groupId, artifactId, version)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Install a specific Kestra's plugin artifact
     * @param {module:model/ClusterControllerApiPluginListRequest} clusterControllerApiPluginListRequest List of plugins
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ClusterControllerApiPluginArtifactListPluginArtifact} and HTTP response
     */
    installVersionedPluginsWithHttpInfo(clusterControllerApiPluginListRequest) {
      let postBody = clusterControllerApiPluginListRequest;
      // verify the required parameter 'clusterControllerApiPluginListRequest' is set
      if (clusterControllerApiPluginListRequest === undefined || clusterControllerApiPluginListRequest === null) {
        throw new Error("Missing the required parameter 'clusterControllerApiPluginListRequest' when calling installVersionedPlugins");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ClusterControllerApiPluginArtifactListPluginArtifact;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/install', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Install a specific Kestra's plugin artifact
     * @param {module:model/ClusterControllerApiPluginListRequest} clusterControllerApiPluginListRequest List of plugins
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ClusterControllerApiPluginArtifactListPluginArtifact}
     */
    installVersionedPlugins(clusterControllerApiPluginListRequest) {
      return this.installVersionedPluginsWithHttpInfo(clusterControllerApiPluginListRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get the list of available Kestra's plugin artifact.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    listAvailableVersionedPluginsWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/available', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get the list of available Kestra's plugin artifact.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    listAvailableVersionedPlugins() {
      return this.listAvailableVersionedPluginsWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get list of plugins
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Plugin>} and HTTP response
     */
    listPluginsWithHttpInfo(tenant) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listPlugins");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Plugin];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/plugins', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get list of plugins
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Plugin>}
     */
    listPlugins(tenant) {
      return this.listPluginsWithHttpInfo(tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get the list of installed Kestra's plugin artifact.
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [sort] The sort of current page
     * @param {String} [q] The query
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsClusterControllerApiPluginArtifact} and HTTP response
     */
    listVersionedPluginWithHttpInfo(page, size, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling listVersionedPlugin");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling listVersionedPlugin");
      }

      let pathParams = {
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'q': opts['q']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsClusterControllerApiPluginArtifact;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get the list of installed Kestra's plugin artifact.
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.sort The sort of current page
     * @param {String} opts.q The query
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsClusterControllerApiPluginArtifact}
     */
    listVersionedPlugin(page, size, opts) {
      return this.listVersionedPluginWithHttpInfo(page, size, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Resolve a specific Kestra's plugin artifact
     * @param {module:model/ClusterControllerApiPluginListRequest} clusterControllerApiPluginListRequest List of plugins
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ClusterControllerApiPluginArtifactListPluginResolutionResult} and HTTP response
     */
    resolveVersionedPluginsWithHttpInfo(clusterControllerApiPluginListRequest) {
      let postBody = clusterControllerApiPluginListRequest;
      // verify the required parameter 'clusterControllerApiPluginListRequest' is set
      if (clusterControllerApiPluginListRequest === undefined || clusterControllerApiPluginListRequest === null) {
        throw new Error("Missing the required parameter 'clusterControllerApiPluginListRequest' when calling resolveVersionedPlugins");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ClusterControllerApiPluginArtifactListPluginResolutionResult;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/resolve', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Resolve a specific Kestra's plugin artifact
     * @param {module:model/ClusterControllerApiPluginListRequest} clusterControllerApiPluginListRequest List of plugins
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ClusterControllerApiPluginArtifactListPluginResolutionResult}
     */
    resolveVersionedPlugins(clusterControllerApiPluginListRequest) {
      return this.resolveVersionedPluginsWithHttpInfo(clusterControllerApiPluginListRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Uninstall Kestra's plugin artifacts
     * @param {module:model/ClusterControllerApiPluginListRequest} clusterControllerApiPluginListRequest List of plugins
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ClusterControllerApiPluginArtifactListPluginArtifact} and HTTP response
     */
    uninstallVersionedPluginsWithHttpInfo(clusterControllerApiPluginListRequest) {
      let postBody = clusterControllerApiPluginListRequest;
      // verify the required parameter 'clusterControllerApiPluginListRequest' is set
      if (clusterControllerApiPluginListRequest === undefined || clusterControllerApiPluginListRequest === null) {
        throw new Error("Missing the required parameter 'clusterControllerApiPluginListRequest' when calling uninstallVersionedPlugins");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ClusterControllerApiPluginArtifactListPluginArtifact;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/uninstall', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Uninstall Kestra's plugin artifacts
     * @param {module:model/ClusterControllerApiPluginListRequest} clusterControllerApiPluginListRequest List of plugins
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ClusterControllerApiPluginArtifactListPluginArtifact}
     */
    uninstallVersionedPlugins(clusterControllerApiPluginListRequest) {
      return this.uninstallVersionedPluginsWithHttpInfo(clusterControllerApiPluginListRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Upload a Kestra's plugin artifact
     * @param {Object} opts Optional parameters
     * @param {File} [file] 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PluginArtifact} and HTTP response
     */
    uploadVersionedPluginsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'file': opts['file']
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = PluginArtifact;
      return this.apiClient.callApi(
        '/api/v1/cluster/versioned-plugins/upload', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Upload a Kestra's plugin artifact
     * @param {Object} opts Optional parameters
     * @param {File} opts.file 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PluginArtifact}
     */
    uploadVersionedPlugins(opts) {
      return this.uploadVersionedPluginsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
