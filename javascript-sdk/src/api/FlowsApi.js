/**
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import BulkResponse from '../model/BulkResponse';
import Flow from '../model/Flow';
import FlowControllerTaskValidationType from '../model/FlowControllerTaskValidationType';
import FlowGraph from '../model/FlowGraph';
import FlowInterface from '../model/FlowInterface';
import FlowTopologyGraph from '../model/FlowTopologyGraph';
import FlowWithSource from '../model/FlowWithSource';
import IdWithNamespace from '../model/IdWithNamespace';
import PagedResultsFlow from '../model/PagedResultsFlow';
import PagedResultsSearchResultFlow from '../model/PagedResultsSearchResultFlow';
import QueryFilter from '../model/QueryFilter';
import Task from '../model/Task';
import ValidateConstraintViolation from '../model/ValidateConstraintViolation';

/**
* Flows service.
* @module api/FlowsApi
* @version v1.0.5
*/
export default class FlowsApi {

    /**
    * Constructs a new FlowsApi. 
    * @alias module:api/FlowsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }




            

    /**
     * Update from multiples yaml sources
     * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
     * @param {Boolean} _delete If missing flow should be deleted
     * @param {Boolean} allowNamespaceChild If namespace child should are allowed to be updated
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} [namespace] The namespace where to update flows
     * @param {String} [body] A list of flows source code splitted with \"---\"
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowInterface>} and HTTP response
     */
    bulkUpdateFlowsWithHttpInfo(_delete, allowNamespaceChild, tenant, opts) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter '_delete' is set
      if (_delete === undefined || _delete === null) {
        throw new Error("Missing the required parameter '_delete' when calling bulkUpdateFlows");
      }
      // verify the required parameter 'allowNamespaceChild' is set
      if (allowNamespaceChild === undefined || allowNamespaceChild === null) {
        throw new Error("Missing the required parameter 'allowNamespaceChild' when calling bulkUpdateFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling bulkUpdateFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'delete': _delete,
        'namespace': opts['namespace'],
        'allowNamespaceChild': allowNamespaceChild
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [FlowInterface];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/bulk', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update from multiples yaml sources
     * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
     * @param {Boolean} _delete If missing flow should be deleted
     * @param {Boolean} allowNamespaceChild If namespace child should are allowed to be updated
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} opts.namespace The namespace where to update flows
     * @param {String} opts.body A list of flows source code splitted with \"---\"
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowInterface>}
     */
    bulkUpdateFlows(_delete, allowNamespaceChild, tenant, opts) {
      return this.bulkUpdateFlowsWithHttpInfo(_delete, allowNamespaceChild, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Create a flow from yaml source
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowWithSource} and HTTP response
     */
    createFlowWithHttpInfo(tenant, body) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling createFlow");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createFlow");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowWithSource;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a flow from yaml source
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowWithSource}
     */
    createFlow(tenant, body) {
      return this.createFlowWithHttpInfo(tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Delete a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteFlowWithHttpInfo(namespace, id, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteFlow(namespace, id, tenant) {
      return this.deleteFlowWithHttpInfo(namespace, id, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Delete flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    deleteFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling deleteFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/delete/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    deleteFlowsByIds(tenant, idWithNamespace) {
      return this.deleteFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Delete flows returned by the query parameters.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    deleteFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/delete/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete flows returned by the query parameters.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    deleteFlowsByQuery(tenant, opts) {
      return this.deleteFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Disable flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    disableFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling disableFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling disableFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/disable/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Disable flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    disableFlowsByIds(tenant, idWithNamespace) {
      return this.disableFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Disable flows returned by the query parameters.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    disableFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling disableFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/disable/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Disable flows returned by the query parameters.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    disableFlowsByQuery(tenant, opts) {
      return this.disableFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Enable flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    enableFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling enableFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling enableFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/enable/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Enable flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    enableFlowsByIds(tenant, idWithNamespace) {
      return this.enableFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Enable flows returned by the query parameters.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BulkResponse} and HTTP response
     */
    enableFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling enableFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/enable/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Enable flows returned by the query parameters.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BulkResponse}
     */
    enableFlowsByQuery(tenant, opts) {
      return this.enableFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Export flows as a ZIP archive of yaml sources.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Blob} and HTTP response
     */
    exportFlowsByIdsWithHttpInfo(tenant, idWithNamespace) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling exportFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/export/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Export flows as a ZIP archive of yaml sources.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Blob}
     */
    exportFlowsByIds(tenant, idWithNamespace) {
      return this.exportFlowsByIdsWithHttpInfo(tenant, idWithNamespace)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Export flows as a ZIP archive of yaml sources.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Blob} and HTTP response
     */
    exportFlowsByQueryWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/export/by-query', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Export flows as a ZIP archive of yaml sources.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Blob}
     */
    exportFlowsByQuery(tenant, opts) {
      return this.exportFlowsByQueryWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Generate a graph for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] The flow revision
     * @param {Array.<String>} [subflows] The subflow tasks to display
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowGraph} and HTTP response
     */
    generateFlowGraphWithHttpInfo(namespace, id, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling generateFlowGraph");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling generateFlowGraph");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateFlowGraph");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision'],
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/graph', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Generate a graph for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.revision The flow revision
     * @param {Array.<String>} opts.subflows The subflow tasks to display
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowGraph}
     */
    generateFlowGraph(namespace, id, tenant, opts) {
      return this.generateFlowGraphWithHttpInfo(namespace, id, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Generate a graph for a flow source
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [subflows] The subflow tasks to display
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowGraph} and HTTP response
     */
    generateFlowGraphFromSourceWithHttpInfo(tenant, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateFlowGraphFromSource");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling generateFlowGraphFromSource");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/graph', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Generate a graph for a flow source
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.subflows The subflow tasks to display
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowGraph}
     */
    generateFlowGraphFromSource(tenant, body, opts) {
      return this.generateFlowGraphFromSourceWithHttpInfo(tenant, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} source Include the source code
     * @param {Boolean} allowDeleted Get flow even if deleted
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] Get latest revision by default
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */
    getFlowWithHttpInfo(namespace, id, source, allowDeleted, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFlow");
      }
      // verify the required parameter 'source' is set
      if (source === undefined || source === null) {
        throw new Error("Missing the required parameter 'source' when calling getFlow");
      }
      // verify the required parameter 'allowDeleted' is set
      if (allowDeleted === undefined || allowDeleted === null) {
        throw new Error("Missing the required parameter 'allowDeleted' when calling getFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'source': source,
        'revision': opts['revision'],
        'allowDeleted': allowDeleted
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} source Include the source code
     * @param {Boolean} allowDeleted Get flow even if deleted
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.revision Get latest revision by default
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */
    getFlow(namespace, id, source, allowDeleted, tenant, opts) {
      return this.getFlowWithHttpInfo(namespace, id, source, allowDeleted, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get flow dependencies
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} destinationOnly If true, list only destination dependencies, otherwise list also source dependencies
     * @param {Boolean} expandAll If true, expand all dependencies recursively
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowTopologyGraph} and HTTP response
     */
    getFlowDependenciesWithHttpInfo(namespace, id, destinationOnly, expandAll, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getFlowDependencies");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFlowDependencies");
      }
      // verify the required parameter 'destinationOnly' is set
      if (destinationOnly === undefined || destinationOnly === null) {
        throw new Error("Missing the required parameter 'destinationOnly' when calling getFlowDependencies");
      }
      // verify the required parameter 'expandAll' is set
      if (expandAll === undefined || expandAll === null) {
        throw new Error("Missing the required parameter 'expandAll' when calling getFlowDependencies");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlowDependencies");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'destinationOnly': destinationOnly,
        'expandAll': expandAll
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowTopologyGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/dependencies', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get flow dependencies
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} destinationOnly If true, list only destination dependencies, otherwise list also source dependencies
     * @param {Boolean} expandAll If true, expand all dependencies recursively
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowTopologyGraph}
     */
    getFlowDependencies(namespace, id, destinationOnly, expandAll, tenant) {
      return this.getFlowDependenciesWithHttpInfo(namespace, id, destinationOnly, expandAll, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Retrieve flow dependencies
     * @param {String} namespace The flow namespace
     * @param {Boolean} destinationOnly if true, list only destination dependencies, otherwise list also source dependencies
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowTopologyGraph} and HTTP response
     */
    getFlowDependenciesFromNamespaceWithHttpInfo(namespace, destinationOnly, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getFlowDependenciesFromNamespace");
      }
      // verify the required parameter 'destinationOnly' is set
      if (destinationOnly === undefined || destinationOnly === null) {
        throw new Error("Missing the required parameter 'destinationOnly' when calling getFlowDependenciesFromNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlowDependenciesFromNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
        'destinationOnly': destinationOnly
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowTopologyGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/namespaces/{namespace}/dependencies', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve flow dependencies
     * @param {String} namespace The flow namespace
     * @param {Boolean} destinationOnly if true, list only destination dependencies, otherwise list also source dependencies
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowTopologyGraph}
     */
    getFlowDependenciesFromNamespace(namespace, destinationOnly, tenant) {
      return this.getFlowDependenciesFromNamespaceWithHttpInfo(namespace, destinationOnly, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get a flow task
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} taskId The task id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] The flow revision
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Task} and HTTP response
     */
    getTaskFromFlowWithHttpInfo(namespace, id, taskId, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getTaskFromFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getTaskFromFlow");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling getTaskFromFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getTaskFromFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'taskId': taskId,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Task;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a flow task
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} taskId The task id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.revision The flow revision
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Task}
     */
    getTaskFromFlow(namespace, id, taskId, tenant, opts) {
      return this.getTaskFromFlowWithHttpInfo(namespace, id, taskId, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {File} [fileUpload] The file to import, can be a ZIP archive or a multi-objects YAML file
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
     */
    importFlowsWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling importFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'fileUpload': opts['fileUpload']
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/import', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {File} opts.fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
     */
    importFlows(tenant, opts) {
      return this.importFlowsWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * List all distinct namespaces
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} [q] A string filter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
     */
    listDistinctNamespacesWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listDistinctNamespaces");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'q': opts['q']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/distinct-namespaces', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all distinct namespaces
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} opts.q A string filter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
     */
    listDistinctNamespaces(tenant, opts) {
      return this.listDistinctNamespacesWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Get revisions for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowWithSource>} and HTTP response
     */
    listFlowRevisionsWithHttpInfo(namespace, id, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listFlowRevisions");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling listFlowRevisions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listFlowRevisions");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [FlowWithSource];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/revisions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get revisions for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowWithSource>}
     */
    listFlowRevisions(namespace, id, tenant) {
      return this.listFlowRevisionsWithHttpInfo(namespace, id, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Retrieve all flows from a given namespace
     * @param {String} namespace Namespace to filter flows
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Flow>} and HTTP response
     */
    listFlowsByNamespaceWithHttpInfo(namespace, tenant) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listFlowsByNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listFlowsByNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Flow];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve all flows from a given namespace
     * @param {String} namespace Namespace to filter flows
     * @param {String} tenant 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Flow>}
     */
    listFlowsByNamespace(namespace, tenant) {
      return this.listFlowsByNamespaceWithHttpInfo(namespace, tenant)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Search for flows
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [sort] The sort of current page
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsFlow} and HTTP response
     */
    searchFlowsWithHttpInfo(page, size, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchFlows");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsFlow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Search for flows
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.sort The sort of current page
     * @param {Array.<module:model/QueryFilter>} opts.filters Filters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsFlow}
     */
    searchFlows(page, size, tenant, opts) {
      return this.searchFlowsWithHttpInfo(page, size, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Search for flows source code
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [sort] The sort of current page
     * @param {String} [q] A string filter
     * @param {String} [namespace] A namespace filter prefix
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PagedResultsSearchResultFlow} and HTTP response
     */
    searchFlowsBySourceCodeWithHttpInfo(page, size, tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchFlowsBySourceCode");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchFlowsBySourceCode");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchFlowsBySourceCode");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'q': opts['q'],
        'namespace': opts['namespace']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsSearchResultFlow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/source', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Search for flows source code
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.sort The sort of current page
     * @param {String} opts.q A string filter
     * @param {String} opts.namespace A namespace filter prefix
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PagedResultsSearchResultFlow}
     */
    searchFlowsBySourceCode(page, size, tenant, opts) {
      return this.searchFlowsBySourceCodeWithHttpInfo(page, size, tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Update a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowWithSource} and HTTP response
     */
    updateFlowWithHttpInfo(namespace, id, tenant, body) {
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateFlow");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowWithSource;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowWithSource}
     */
    updateFlow(namespace, id, tenant, body) {
      return this.updateFlowWithHttpInfo(namespace, id, tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Update a complete namespace from yaml source
     * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
     * @param {String} namespace The flow namespace
     * @param {Boolean} _delete If missing flow should be deleted
     * @param {String} tenant 
     * @param {String} body A list of flows source code
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowInterface>} and HTTP response
     */
    updateFlowsInNamespaceWithHttpInfo(namespace, _delete, tenant, body) {
      let postBody = body;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateFlowsInNamespace");
      }
      // verify the required parameter '_delete' is set
      if (_delete === undefined || _delete === null) {
        throw new Error("Missing the required parameter '_delete' when calling updateFlowsInNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateFlowsInNamespace");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateFlowsInNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
        'delete': _delete
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [FlowInterface];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a complete namespace from yaml source
     * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
     * @param {String} namespace The flow namespace
     * @param {Boolean} _delete If missing flow should be deleted
     * @param {String} tenant 
     * @param {String} body A list of flows source code
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowInterface>}
     */
    updateFlowsInNamespace(namespace, _delete, tenant, body) {
      return this.updateFlowsInNamespaceWithHttpInfo(namespace, _delete, tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Validate a list of flows
     * @param {String} tenant 
     * @param {String} body A list of flows source code in a single string
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/ValidateConstraintViolation>} and HTTP response
     */
    validateFlowsWithHttpInfo(tenant, body) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateFlows");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [ValidateConstraintViolation];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Validate a list of flows
     * @param {String} tenant 
     * @param {String} body A list of flows source code in a single string
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/ValidateConstraintViolation>}
     */
    validateFlows(tenant, body) {
      return this.validateFlowsWithHttpInfo(tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Validate a task
     * @param {module:model/FlowControllerTaskValidationType} section The type of task
     * @param {String} tenant 
     * @param {Object.<String, Object>} body A task definition that can be from tasks or triggers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ValidateConstraintViolation} and HTTP response
     */
    validateTaskWithHttpInfo(section, tenant, body) {
      let postBody = body;
      // verify the required parameter 'section' is set
      if (section === undefined || section === null) {
        throw new Error("Missing the required parameter 'section' when calling validateTask");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateTask");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateTask");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'section': section
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml', 'application/json'];
      let accepts = ['application/json'];
      let returnType = ValidateConstraintViolation;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate/task', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Validate a task
     * @param {module:model/FlowControllerTaskValidationType} section The type of task
     * @param {String} tenant 
     * @param {Object.<String, Object>} body A task definition that can be from tasks or triggers
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ValidateConstraintViolation}
     */
    validateTask(section, tenant, body) {
      return this.validateTaskWithHttpInfo(section, tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }









            

    /**
     * Validate trigger
     * @param {String} tenant 
     * @param {Object.<String, Object>} body The trigger
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ValidateConstraintViolation} and HTTP response
     */
    validateTriggerWithHttpInfo(tenant, body) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateTrigger");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateTrigger");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ValidateConstraintViolation;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate/trigger', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Validate trigger
     * @param {String} tenant 
     * @param {Object.<String, Object>} body The trigger
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ValidateConstraintViolation}
     */
    validateTrigger(tenant, body) {
      return this.validateTriggerWithHttpInfo(tenant, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }








}
